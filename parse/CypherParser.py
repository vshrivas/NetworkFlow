# Generated from Cypher.g4 by ANTLR 4.5.3
# encoding: utf-8
from antlr4 import *
from io import StringIO

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u0430\ud6d1\u8206\uad2d\u4417\uaef1\u8d80\uaadd\3q")
        buf.write("\u0522\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\3\2\5\2\u00a4\n\2\3\2\3\2\5")
        buf.write("\2\u00a8\n\2\3\2\5\2\u00ab\n\2\3\2\5\2\u00ae\n\2\3\3\3")
        buf.write("\3\3\4\3\4\3\5\3\5\5\5\u00b6\n\5\3\5\7\5\u00b9\n\5\f\5")
        buf.write("\16\5\u00bc\13\5\3\6\3\6\5\6\u00c0\n\6\3\6\7\6\u00c3\n")
        buf.write("\6\f\6\16\6\u00c6\13\6\3\7\3\7\3\7\3\7\5\7\u00cc\n\7\3")
        buf.write("\7\3\7\3\7\5\7\u00d1\n\7\3\7\5\7\u00d4\n\7\3\b\3\b\3\b")
        buf.write("\3\b\3\b\3\b\3\b\3\b\3\b\5\b\u00df\n\b\3\t\3\t\5\t\u00e3")
        buf.write("\n\t\3\t\3\t\5\t\u00e7\n\t\3\t\3\t\5\t\u00eb\n\t\3\t\5")
        buf.write("\t\u00ee\n\t\3\n\3\n\5\n\u00f2\n\n\3\n\3\n\3\n\3\n\3\n")
        buf.write("\3\n\3\13\3\13\5\13\u00fc\n\13\3\13\3\13\3\13\7\13\u0101")
        buf.write("\n\13\f\13\16\13\u0104\13\13\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\3\f\3\f\3\f\5\f\u0110\n\f\3\r\3\r\5\r\u0114\n\r\3\r")
        buf.write("\3\r\3\16\3\16\5\16\u011a\n\16\3\16\3\16\3\16\7\16\u011f")
        buf.write("\n\16\f\16\16\16\u0122\13\16\3\17\3\17\5\17\u0126\n\17")
        buf.write("\3\17\3\17\5\17\u012a\n\17\3\17\3\17\3\17\3\17\5\17\u0130")
        buf.write("\n\17\3\17\3\17\5\17\u0134\n\17\3\17\3\17\3\17\3\17\5")
        buf.write("\17\u013a\n\17\3\17\3\17\5\17\u013e\n\17\3\17\3\17\3\17")
        buf.write("\3\17\5\17\u0144\n\17\3\17\3\17\5\17\u0148\n\17\3\20\3")
        buf.write("\20\5\20\u014c\n\20\3\20\3\20\5\20\u0150\n\20\3\20\3\20")
        buf.write("\5\20\u0154\n\20\3\20\3\20\5\20\u0158\n\20\3\20\7\20\u015b")
        buf.write("\n\20\f\20\16\20\u015e\13\20\3\21\3\21\3\21\3\21\5\21")
        buf.write("\u0164\n\21\3\21\3\21\5\21\u0168\n\21\3\21\7\21\u016b")
        buf.write("\n\21\f\21\16\21\u016e\13\21\3\22\3\22\3\22\3\22\5\22")
        buf.write("\u0174\n\22\3\23\3\23\5\23\u0178\n\23\3\23\5\23\u017b")
        buf.write("\n\23\3\23\3\23\3\23\5\23\u0180\n\23\3\23\5\23\u0183\n")
        buf.write("\23\3\24\3\24\5\24\u0187\n\24\3\24\5\24\u018a\n\24\3\24")
        buf.write("\3\24\3\24\3\25\3\25\3\25\5\25\u0192\n\25\3\25\3\25\5")
        buf.write("\25\u0196\n\25\3\25\3\25\5\25\u019a\n\25\3\26\3\26\5\26")
        buf.write("\u019e\n\26\3\26\3\26\5\26\u01a2\n\26\3\26\7\26\u01a5")
        buf.write("\n\26\f\26\16\26\u01a8\13\26\3\26\3\26\5\26\u01ac\n\26")
        buf.write("\3\26\3\26\5\26\u01b0\n\26\3\26\7\26\u01b3\n\26\f\26\16")
        buf.write("\26\u01b6\13\26\5\26\u01b8\n\26\3\27\3\27\3\27\3\27\3")
        buf.write("\27\3\27\3\27\5\27\u01c1\n\27\3\30\3\30\3\30\3\30\3\30")
        buf.write("\3\30\3\30\5\30\u01ca\n\30\3\30\7\30\u01cd\n\30\f\30\16")
        buf.write("\30\u01d0\13\30\3\31\3\31\3\31\3\31\3\32\3\32\3\32\3\32")
        buf.write("\3\33\3\33\5\33\u01dc\n\33\3\33\5\33\u01df\n\33\3\34\3")
        buf.write("\34\3\34\3\34\3\35\3\35\5\35\u01e7\n\35\3\35\3\35\5\35")
        buf.write("\u01eb\n\35\3\35\7\35\u01ee\n\35\f\35\16\35\u01f1\13\35")
        buf.write("\3\36\3\36\5\36\u01f5\n\36\3\36\3\36\5\36\u01f9\n\36\3")
        buf.write("\36\3\36\3\36\5\36\u01fe\n\36\3\37\3\37\3 \3 \5 \u0204")
        buf.write("\n \3 \7 \u0207\n \f \16 \u020a\13 \3 \3 \3 \3 \5 \u0210")
        buf.write("\n \3!\3!\5!\u0214\n!\3!\3!\5!\u0218\n!\5!\u021a\n!\3")
        buf.write("!\3!\5!\u021e\n!\5!\u0220\n!\3!\3!\5!\u0224\n!\5!\u0226")
        buf.write("\n!\3!\3!\3\"\3\"\5\"\u022c\n\"\3\"\3\"\3#\3#\5#\u0232")
        buf.write("\n#\3#\3#\5#\u0236\n#\3#\5#\u0239\n#\3#\5#\u023c\n#\3")
        buf.write("#\3#\5#\u0240\n#\3#\3#\3#\3#\5#\u0246\n#\3#\3#\5#\u024a")
        buf.write("\n#\3#\5#\u024d\n#\3#\5#\u0250\n#\3#\3#\3#\3#\5#\u0256")
        buf.write("\n#\3#\5#\u0259\n#\3#\5#\u025c\n#\3#\3#\5#\u0260\n#\3")
        buf.write("#\3#\3#\3#\5#\u0266\n#\3#\5#\u0269\n#\3#\5#\u026c\n#\3")
        buf.write("#\3#\5#\u0270\n#\3$\3$\5$\u0274\n$\3$\3$\5$\u0278\n$\5")
        buf.write("$\u027a\n$\3$\3$\5$\u027e\n$\5$\u0280\n$\3$\5$\u0283\n")
        buf.write("$\3$\3$\5$\u0287\n$\5$\u0289\n$\3$\3$\3%\3%\5%\u028f\n")
        buf.write("%\3&\3&\5&\u0293\n&\3&\3&\5&\u0297\n&\3&\3&\5&\u029b\n")
        buf.write("&\3&\5&\u029e\n&\3&\7&\u02a1\n&\f&\16&\u02a4\13&\3\'\3")
        buf.write("\'\5\'\u02a8\n\'\3\'\7\'\u02ab\n\'\f\'\16\'\u02ae\13\'")
        buf.write("\3(\3(\5(\u02b2\n(\3(\3(\3)\3)\5)\u02b8\n)\3)\3)\5)\u02bc")
        buf.write("\n)\5)\u02be\n)\3)\3)\5)\u02c2\n)\3)\3)\5)\u02c6\n)\5")
        buf.write(")\u02c8\n)\5)\u02ca\n)\3*\3*\3+\3+\3,\3,\3-\3-\3-\3-\3")
        buf.write("-\7-\u02d7\n-\f-\16-\u02da\13-\3.\3.\3.\3.\3.\7.\u02e1")
        buf.write("\n.\f.\16.\u02e4\13.\3/\3/\3/\3/\3/\7/\u02eb\n/\f/\16")
        buf.write("/\u02ee\13/\3\60\3\60\5\60\u02f2\n\60\7\60\u02f4\n\60")
        buf.write("\f\60\16\60\u02f7\13\60\3\60\3\60\3\61\3\61\5\61\u02fd")
        buf.write("\n\61\3\61\7\61\u0300\n\61\f\61\16\61\u0303\13\61\3\62")
        buf.write("\3\62\5\62\u0307\n\62\3\62\3\62\5\62\u030b\n\62\3\62\3")
        buf.write("\62\5\62\u030f\n\62\3\62\3\62\5\62\u0313\n\62\3\62\7\62")
        buf.write("\u0316\n\62\f\62\16\62\u0319\13\62\3\63\3\63\5\63\u031d")
        buf.write("\n\63\3\63\3\63\5\63\u0321\n\63\3\63\3\63\5\63\u0325\n")
        buf.write("\63\3\63\3\63\5\63\u0329\n\63\3\63\3\63\5\63\u032d\n\63")
        buf.write("\3\63\3\63\5\63\u0331\n\63\3\63\7\63\u0334\n\63\f\63\16")
        buf.write("\63\u0337\13\63\3\64\3\64\5\64\u033b\n\64\3\64\3\64\5")
        buf.write("\64\u033f\n\64\3\64\7\64\u0342\n\64\f\64\16\64\u0345\13")
        buf.write("\64\3\65\3\65\5\65\u0349\n\65\7\65\u034b\n\65\f\65\16")
        buf.write("\65\u034e\13\65\3\65\3\65\3\66\3\66\5\66\u0354\n\66\3")
        buf.write("\66\3\66\3\66\3\66\3\66\5\66\u035b\n\66\3\66\3\66\5\66")
        buf.write("\u035f\n\66\3\66\3\66\5\66\u0363\n\66\3\66\3\66\5\66\u0367")
        buf.write("\n\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\3\66\3\66\3\66\5\66\u0376\n\66\3\66\5\66\u0379\n\66\3")
        buf.write("\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66\3\66")
        buf.write("\7\66\u0386\n\66\f\66\16\66\u0389\13\66\3\67\3\67\5\67")
        buf.write("\u038d\n\67\3\67\3\67\5\67\u0391\n\67\7\67\u0393\n\67")
        buf.write("\f\67\16\67\u0396\13\67\38\38\38\38\58\u039c\n8\38\38")
        buf.write("\58\u03a0\n8\38\38\58\u03a4\n8\38\38\38\38\38\58\u03ab")
        buf.write("\n8\38\38\58\u03af\n8\38\38\58\u03b3\n8\38\38\38\38\5")
        buf.write("8\u03b9\n8\38\38\58\u03bd\n8\38\38\58\u03c1\n8\38\58\u03c4")
        buf.write("\n8\38\38\58\u03c8\n8\38\38\38\38\58\u03ce\n8\38\38\5")
        buf.write("8\u03d2\n8\38\38\58\u03d6\n8\38\38\38\38\58\u03dc\n8\3")
        buf.write("8\38\58\u03e0\n8\38\38\58\u03e4\n8\38\38\38\38\58\u03ea")
        buf.write("\n8\38\38\58\u03ee\n8\38\38\58\u03f2\n8\38\38\38\38\5")
        buf.write("8\u03f8\n8\38\38\58\u03fc\n8\38\38\58\u0400\n8\38\38\3")
        buf.write("8\38\38\38\58\u0408\n8\39\39\39\39\39\39\59\u0410\n9\3")
        buf.write(":\3:\3;\3;\5;\u0416\n;\3;\3;\5;\u041a\n;\3;\3;\5;\u041e")
        buf.write("\n;\3;\3;\5;\u0422\n;\7;\u0424\n;\f;\16;\u0427\13;\5;")
        buf.write("\u0429\n;\3;\3;\3<\3<\5<\u042f\n<\3<\3<\3<\5<\u0434\n")
        buf.write("<\3<\3<\3<\5<\u0439\n<\3<\3<\3<\5<\u043e\n<\3<\3<\3<\5")
        buf.write("<\u0443\n<\3<\3<\3<\5<\u0448\n<\3<\3<\3<\5<\u044d\n<\3")
        buf.write("<\5<\u0450\n<\3=\3=\5=\u0454\n=\3=\3=\5=\u0458\n=\3=\3")
        buf.write("=\3>\3>\5>\u045e\n>\3>\6>\u0461\n>\r>\16>\u0462\3?\3?")
        buf.write("\5?\u0467\n?\3?\5?\u046a\n?\3@\3@\3@\3@\3@\3@\3A\3A\5")
        buf.write("A\u0474\nA\3A\3A\5A\u0478\nA\3A\3A\5A\u047c\nA\5A\u047e")
        buf.write("\nA\3A\3A\5A\u0482\nA\3A\3A\5A\u0486\nA\3A\3A\5A\u048a")
        buf.write("\nA\7A\u048c\nA\fA\16A\u048f\13A\5A\u0491\nA\3A\3A\3B")
        buf.write("\3B\3C\3C\5C\u0499\nC\3C\3C\5C\u049d\nC\3C\3C\5C\u04a1")
        buf.write("\nC\3C\5C\u04a4\nC\3C\5C\u04a7\nC\3C\3C\3D\3D\5D\u04ad")
        buf.write("\nD\3D\3D\5D\u04b1\nD\3D\3D\5D\u04b5\nD\5D\u04b7\nD\3")
        buf.write("D\3D\5D\u04bb\nD\3D\3D\5D\u04bf\nD\3D\3D\5D\u04c3\nD\5")
        buf.write("D\u04c5\nD\3D\3D\5D\u04c9\nD\3D\3D\5D\u04cd\nD\3D\3D\3")
        buf.write("E\3E\5E\u04d3\nE\3E\3E\3F\3F\3G\3G\5G\u04db\nG\3H\3H\5")
        buf.write("H\u04df\nH\3H\3H\5H\u04e3\nH\3H\3H\5H\u04e7\nH\3H\3H\5")
        buf.write("H\u04eb\nH\3H\3H\5H\u04ef\nH\3H\3H\5H\u04f3\nH\3H\3H\5")
        buf.write("H\u04f7\nH\3H\3H\5H\u04fb\nH\7H\u04fd\nH\fH\16H\u0500")
        buf.write("\13H\5H\u0502\nH\3H\3H\3I\3I\3I\5I\u0509\nI\3J\3J\5J\u050d")
        buf.write("\nJ\3J\6J\u0510\nJ\rJ\16J\u0511\3K\3K\3L\3L\3M\3M\3N\3")
        buf.write("N\3O\3O\3P\3P\3Q\3Q\3Q\2\2R\2\4\6\b\n\f\16\20\22\24\26")
        buf.write("\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\")
        buf.write("^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a")
        buf.write("\u008c\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c")
        buf.write("\u009e\u00a0\2\f\3\2TW\3\2\17\20\3\2ij\5\2cckknn\3\2\64")
        buf.write("\66\3\2>?\5\2\67\67@knn\4\2\27\27\37\"\4\2\30\30#&\4\2")
        buf.write("\20\20\'\61\u05ea\2\u00a3\3\2\2\2\4\u00af\3\2\2\2\6\u00b1")
        buf.write("\3\2\2\2\b\u00b3\3\2\2\2\n\u00bd\3\2\2\2\f\u00d3\3\2\2")
        buf.write("\2\16\u00de\3\2\2\2\20\u00e2\3\2\2\2\22\u00ef\3\2\2\2")
        buf.write("\24\u00f9\3\2\2\2\26\u010f\3\2\2\2\30\u0111\3\2\2\2\32")
        buf.write("\u0117\3\2\2\2\34\u0147\3\2\2\2\36\u014b\3\2\2\2 \u015f")
        buf.write("\3\2\2\2\"\u0173\3\2\2\2$\u0175\3\2\2\2&\u0184\3\2\2\2")
        buf.write("(\u018e\3\2\2\2*\u01b7\3\2\2\2,\u01c0\3\2\2\2.\u01c2\3")
        buf.write("\2\2\2\60\u01d1\3\2\2\2\62\u01d5\3\2\2\2\64\u01d9\3\2")
        buf.write("\2\2\66\u01e0\3\2\2\28\u01e4\3\2\2\2:\u01fd\3\2\2\2<\u01ff")
        buf.write("\3\2\2\2>\u020f\3\2\2\2@\u0211\3\2\2\2B\u0229\3\2\2\2")
        buf.write("D\u026f\3\2\2\2F\u0271\3\2\2\2H\u028e\3\2\2\2J\u0290\3")
        buf.write("\2\2\2L\u02a5\3\2\2\2N\u02af\3\2\2\2P\u02b5\3\2\2\2R\u02cb")
        buf.write("\3\2\2\2T\u02cd\3\2\2\2V\u02cf\3\2\2\2X\u02d1\3\2\2\2")
        buf.write("Z\u02db\3\2\2\2\\\u02e5\3\2\2\2^\u02f5\3\2\2\2`\u02fa")
        buf.write("\3\2\2\2b\u0304\3\2\2\2d\u031a\3\2\2\2f\u0338\3\2\2\2")
        buf.write("h\u034c\3\2\2\2j\u0351\3\2\2\2l\u038a\3\2\2\2n\u0407\3")
        buf.write("\2\2\2p\u040f\3\2\2\2r\u0411\3\2\2\2t\u0413\3\2\2\2v\u044f")
        buf.write("\3\2\2\2x\u0451\3\2\2\2z\u045b\3\2\2\2|\u0464\3\2\2\2")
        buf.write("~\u046b\3\2\2\2\u0080\u0471\3\2\2\2\u0082\u0494\3\2\2")
        buf.write("\2\u0084\u0496\3\2\2\2\u0086\u04aa\3\2\2\2\u0088\u04d0")
        buf.write("\3\2\2\2\u008a\u04d6\3\2\2\2\u008c\u04da\3\2\2\2\u008e")
        buf.write("\u04dc\3\2\2\2\u0090\u0505\3\2\2\2\u0092\u050a\3\2\2\2")
        buf.write("\u0094\u0513\3\2\2\2\u0096\u0515\3\2\2\2\u0098\u0517\3")
        buf.write("\2\2\2\u009a\u0519\3\2\2\2\u009c\u051b\3\2\2\2\u009e\u051d")
        buf.write("\3\2\2\2\u00a0\u051f\3\2\2\2\u00a2\u00a4\7o\2\2\u00a3")
        buf.write("\u00a2\3\2\2\2\u00a3\u00a4\3\2\2\2\u00a4\u00a5\3\2\2\2")
        buf.write("\u00a5\u00aa\5\4\3\2\u00a6\u00a8\7o\2\2\u00a7\u00a6\3")
        buf.write("\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9\u00ab")
        buf.write("\7\3\2\2\u00aa\u00a7\3\2\2\2\u00aa\u00ab\3\2\2\2\u00ab")
        buf.write("\u00ad\3\2\2\2\u00ac\u00ae\7o\2\2\u00ad\u00ac\3\2\2\2")
        buf.write("\u00ad\u00ae\3\2\2\2\u00ae\3\3\2\2\2\u00af\u00b0\5\6\4")
        buf.write("\2\u00b0\5\3\2\2\2\u00b1\u00b2\5\b\5\2\u00b2\7\3\2\2\2")
        buf.write("\u00b3\u00ba\5\n\6\2\u00b4\u00b6\7o\2\2\u00b5\u00b4\3")
        buf.write("\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7\u00b9")
        buf.write("\5\f\7\2\u00b8\u00b5\3\2\2\2\u00b9\u00bc\3\2\2\2\u00ba")
        buf.write("\u00b8\3\2\2\2\u00ba\u00bb\3\2\2\2\u00bb\t\3\2\2\2\u00bc")
        buf.write("\u00ba\3\2\2\2\u00bd\u00c4\5\16\b\2\u00be\u00c0\7o\2\2")
        buf.write("\u00bf\u00be\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0\u00c1\3")
        buf.write("\2\2\2\u00c1\u00c3\5\16\b\2\u00c2\u00bf\3\2\2\2\u00c3")
        buf.write("\u00c6\3\2\2\2\u00c4\u00c2\3\2\2\2\u00c4\u00c5\3\2\2\2")
        buf.write("\u00c5\13\3\2\2\2\u00c6\u00c4\3\2\2\2\u00c7\u00c8\7@\2")
        buf.write("\2\u00c8\u00c9\7o\2\2\u00c9\u00cb\7A\2\2\u00ca\u00cc\7")
        buf.write("o\2\2\u00cb\u00ca\3\2\2\2\u00cb\u00cc\3\2\2\2\u00cc\u00cd")
        buf.write("\3\2\2\2\u00cd\u00d4\5\n\6\2\u00ce\u00d0\7@\2\2\u00cf")
        buf.write("\u00d1\7o\2\2\u00d0\u00cf\3\2\2\2\u00d0\u00d1\3\2\2\2")
        buf.write("\u00d1\u00d2\3\2\2\2\u00d2\u00d4\5\n\6\2\u00d3\u00c7\3")
        buf.write("\2\2\2\u00d3\u00ce\3\2\2\2\u00d4\r\3\2\2\2\u00d5\u00df")
        buf.write("\5\20\t\2\u00d6\u00df\5\22\n\2\u00d7\u00df\5\24\13\2\u00d8")
        buf.write("\u00df\5\30\r\2\u00d9\u00df\5\32\16\2\u00da\u00df\5\36")
        buf.write("\20\2\u00db\u00df\5 \21\2\u00dc\u00df\5$\23\2\u00dd\u00df")
        buf.write("\5&\24\2\u00de\u00d5\3\2\2\2\u00de\u00d6\3\2\2\2\u00de")
        buf.write("\u00d7\3\2\2\2\u00de\u00d8\3\2\2\2\u00de\u00d9\3\2\2\2")
        buf.write("\u00de\u00da\3\2\2\2\u00de\u00db\3\2\2\2\u00de\u00dc\3")
        buf.write("\2\2\2\u00de\u00dd\3\2\2\2\u00df\17\3\2\2\2\u00e0\u00e1")
        buf.write("\7B\2\2\u00e1\u00e3\7o\2\2\u00e2\u00e0\3\2\2\2\u00e2\u00e3")
        buf.write("\3\2\2\2\u00e3\u00e4\3\2\2\2\u00e4\u00e6\7C\2\2\u00e5")
        buf.write("\u00e7\7o\2\2\u00e6\u00e5\3\2\2\2\u00e6\u00e7\3\2\2\2")
        buf.write("\u00e7\u00e8\3\2\2\2\u00e8\u00ed\58\35\2\u00e9\u00eb\7")
        buf.write("o\2\2\u00ea\u00e9\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb\u00ec")
        buf.write("\3\2\2\2\u00ec\u00ee\5\66\34\2\u00ed\u00ea\3\2\2\2\u00ed")
        buf.write("\u00ee\3\2\2\2\u00ee\21\3\2\2\2\u00ef\u00f1\7D\2\2\u00f0")
        buf.write("\u00f2\7o\2\2\u00f1\u00f0\3\2\2\2\u00f1\u00f2\3\2\2\2")
        buf.write("\u00f2\u00f3\3\2\2\2\u00f3\u00f4\5V,\2\u00f4\u00f5\7o")
        buf.write("\2\2\u00f5\u00f6\7E\2\2\u00f6\u00f7\7o\2\2\u00f7\u00f8")
        buf.write("\5\u008aF\2\u00f8\23\3\2\2\2\u00f9\u00fb\7F\2\2\u00fa")
        buf.write("\u00fc\7o\2\2\u00fb\u00fa\3\2\2\2\u00fb\u00fc\3\2\2\2")
        buf.write("\u00fc\u00fd\3\2\2\2\u00fd\u0102\5:\36\2\u00fe\u00ff\7")
        buf.write("o\2\2\u00ff\u0101\5\26\f\2\u0100\u00fe\3\2\2\2\u0101\u0104")
        buf.write("\3\2\2\2\u0102\u0100\3\2\2\2\u0102\u0103\3\2\2\2\u0103")
        buf.write("\25\3\2\2\2\u0104\u0102\3\2\2\2\u0105\u0106\7G\2\2\u0106")
        buf.write("\u0107\7o\2\2\u0107\u0108\7C\2\2\u0108\u0109\7o\2\2\u0109")
        buf.write("\u0110\5\32\16\2\u010a\u010b\7G\2\2\u010b\u010c\7o\2\2")
        buf.write("\u010c\u010d\7H\2\2\u010d\u010e\7o\2\2\u010e\u0110\5\32")
        buf.write("\16\2\u010f\u0105\3\2\2\2\u010f\u010a\3\2\2\2\u0110\27")
        buf.write("\3\2\2\2\u0111\u0113\7H\2\2\u0112\u0114\7o\2\2\u0113\u0112")
        buf.write("\3\2\2\2\u0113\u0114\3\2\2\2\u0114\u0115\3\2\2\2\u0115")
        buf.write("\u0116\58\35\2\u0116\31\3\2\2\2\u0117\u0119\7I\2\2\u0118")
        buf.write("\u011a\7o\2\2\u0119\u0118\3\2\2\2\u0119\u011a\3\2\2\2")
        buf.write("\u011a\u011b\3\2\2\2\u011b\u0120\5\34\17\2\u011c\u011d")
        buf.write("\7\4\2\2\u011d\u011f\5\34\17\2\u011e\u011c\3\2\2\2\u011f")
        buf.write("\u0122\3\2\2\2\u0120\u011e\3\2\2\2\u0120\u0121\3\2\2\2")
        buf.write("\u0121\33\3\2\2\2\u0122\u0120\3\2\2\2\u0123\u0125\5\u0092")
        buf.write("J\2\u0124\u0126\7o\2\2\u0125\u0124\3\2\2\2\u0125\u0126")
        buf.write("\3\2\2\2\u0126\u0127\3\2\2\2\u0127\u0129\7\5\2\2\u0128")
        buf.write("\u012a\7o\2\2\u0129\u0128\3\2\2\2\u0129\u012a\3\2\2\2")
        buf.write("\u012a\u012b\3\2\2\2\u012b\u012c\5V,\2\u012c\u0148\3\2")
        buf.write("\2\2\u012d\u012f\5\u008aF\2\u012e\u0130\7o\2\2\u012f\u012e")
        buf.write("\3\2\2\2\u012f\u0130\3\2\2\2\u0130\u0131\3\2\2\2\u0131")
        buf.write("\u0133\7\5\2\2\u0132\u0134\7o\2\2\u0133\u0132\3\2\2\2")
        buf.write("\u0133\u0134\3\2\2\2\u0134\u0135\3\2\2\2\u0135\u0136\5")
        buf.write("V,\2\u0136\u0148\3\2\2\2\u0137\u0139\5\u008aF\2\u0138")
        buf.write("\u013a\7o\2\2\u0139\u0138\3\2\2\2\u0139\u013a\3\2\2\2")
        buf.write("\u013a\u013b\3\2\2\2\u013b\u013d\7\6\2\2\u013c\u013e\7")
        buf.write("o\2\2\u013d\u013c\3\2\2\2\u013d\u013e\3\2\2\2\u013e\u013f")
        buf.write("\3\2\2\2\u013f\u0140\5V,\2\u0140\u0148\3\2\2\2\u0141\u0143")
        buf.write("\5\u008aF\2\u0142\u0144\7o\2\2\u0143\u0142\3\2\2\2\u0143")
        buf.write("\u0144\3\2\2\2\u0144\u0145\3\2\2\2\u0145\u0146\5L\'\2")
        buf.write("\u0146\u0148\3\2\2\2\u0147\u0123\3\2\2\2\u0147\u012d\3")
        buf.write("\2\2\2\u0147\u0137\3\2\2\2\u0147\u0141\3\2\2\2\u0148\35")
        buf.write("\3\2\2\2\u0149\u014a\7J\2\2\u014a\u014c\7o\2\2\u014b\u0149")
        buf.write("\3\2\2\2\u014b\u014c\3\2\2\2\u014c\u014d\3\2\2\2\u014d")
        buf.write("\u014f\7K\2\2\u014e\u0150\7o\2\2\u014f\u014e\3\2\2\2\u014f")
        buf.write("\u0150\3\2\2\2\u0150\u0151\3\2\2\2\u0151\u015c\5V,\2\u0152")
        buf.write("\u0154\7o\2\2\u0153\u0152\3\2\2\2\u0153\u0154\3\2\2\2")
        buf.write("\u0154\u0155\3\2\2\2\u0155\u0157\7\4\2\2\u0156\u0158\7")
        buf.write("o\2\2\u0157\u0156\3\2\2\2\u0157\u0158\3\2\2\2\u0158\u0159")
        buf.write("\3\2\2\2\u0159\u015b\5V,\2\u015a\u0153\3\2\2\2\u015b\u015e")
        buf.write("\3\2\2\2\u015c\u015a\3\2\2\2\u015c\u015d\3\2\2\2\u015d")
        buf.write("\37\3\2\2\2\u015e\u015c\3\2\2\2\u015f\u0160\7L\2\2\u0160")
        buf.write("\u0161\7o\2\2\u0161\u016c\5\"\22\2\u0162\u0164\7o\2\2")
        buf.write("\u0163\u0162\3\2\2\2\u0163\u0164\3\2\2\2\u0164\u0165\3")
        buf.write("\2\2\2\u0165\u0167\7\4\2\2\u0166\u0168\7o\2\2\u0167\u0166")
        buf.write("\3\2\2\2\u0167\u0168\3\2\2\2\u0168\u0169\3\2\2\2\u0169")
        buf.write("\u016b\5\"\22\2\u016a\u0163\3\2\2\2\u016b\u016e\3\2\2")
        buf.write("\2\u016c\u016a\3\2\2\2\u016c\u016d\3\2\2\2\u016d!\3\2")
        buf.write("\2\2\u016e\u016c\3\2\2\2\u016f\u0170\5\u008aF\2\u0170")
        buf.write("\u0171\5L\'\2\u0171\u0174\3\2\2\2\u0172\u0174\5\u0092")
        buf.write("J\2\u0173\u016f\3\2\2\2\u0173\u0172\3\2\2\2\u0174#\3\2")
        buf.write("\2\2\u0175\u017a\7M\2\2\u0176\u0178\7o\2\2\u0177\u0176")
        buf.write("\3\2\2\2\u0177\u0178\3\2\2\2\u0178\u0179\3\2\2\2\u0179")
        buf.write("\u017b\7N\2\2\u017a\u0177\3\2\2\2\u017a\u017b\3\2\2\2")
        buf.write("\u017b\u017c\3\2\2\2\u017c\u017d\7o\2\2\u017d\u0182\5")
        buf.write("(\25\2\u017e\u0180\7o\2\2\u017f\u017e\3\2\2\2\u017f\u0180")
        buf.write("\3\2\2\2\u0180\u0181\3\2\2\2\u0181\u0183\5\66\34\2\u0182")
        buf.write("\u017f\3\2\2\2\u0182\u0183\3\2\2\2\u0183%\3\2\2\2\u0184")
        buf.write("\u0189\7O\2\2\u0185\u0187\7o\2\2\u0186\u0185\3\2\2\2\u0186")
        buf.write("\u0187\3\2\2\2\u0187\u0188\3\2\2\2\u0188\u018a\7N\2\2")
        buf.write("\u0189\u0186\3\2\2\2\u0189\u018a\3\2\2\2\u018a\u018b\3")
        buf.write("\2\2\2\u018b\u018c\7o\2\2\u018c\u018d\5(\25\2\u018d\'")
        buf.write("\3\2\2\2\u018e\u0191\5*\26\2\u018f\u0190\7o\2\2\u0190")
        buf.write("\u0192\5.\30\2\u0191\u018f\3\2\2\2\u0191\u0192\3\2\2\2")
        buf.write("\u0192\u0195\3\2\2\2\u0193\u0194\7o\2\2\u0194\u0196\5")
        buf.write("\60\31\2\u0195\u0193\3\2\2\2\u0195\u0196\3\2\2\2\u0196")
        buf.write("\u0199\3\2\2\2\u0197\u0198\7o\2\2\u0198\u019a\5\62\32")
        buf.write("\2\u0199\u0197\3\2\2\2\u0199\u019a\3\2\2\2\u019a)\3\2")
        buf.write("\2\2\u019b\u01a6\7\7\2\2\u019c\u019e\7o\2\2\u019d\u019c")
        buf.write("\3\2\2\2\u019d\u019e\3\2\2\2\u019e\u019f\3\2\2\2\u019f")
        buf.write("\u01a1\7\4\2\2\u01a0\u01a2\7o\2\2\u01a1\u01a0\3\2\2\2")
        buf.write("\u01a1\u01a2\3\2\2\2\u01a2\u01a3\3\2\2\2\u01a3\u01a5\5")
        buf.write(",\27\2\u01a4\u019d\3\2\2\2\u01a5\u01a8\3\2\2\2\u01a6\u01a4")
        buf.write("\3\2\2\2\u01a6\u01a7\3\2\2\2\u01a7\u01b8\3\2\2\2\u01a8")
        buf.write("\u01a6\3\2\2\2\u01a9\u01b4\5,\27\2\u01aa\u01ac\7o\2\2")
        buf.write("\u01ab\u01aa\3\2\2\2\u01ab\u01ac\3\2\2\2\u01ac\u01ad\3")
        buf.write("\2\2\2\u01ad\u01af\7\4\2\2\u01ae\u01b0\7o\2\2\u01af\u01ae")
        buf.write("\3\2\2\2\u01af\u01b0\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1")
        buf.write("\u01b3\5,\27\2\u01b2\u01ab\3\2\2\2\u01b3\u01b6\3\2\2\2")
        buf.write("\u01b4\u01b2\3\2\2\2\u01b4\u01b5\3\2\2\2\u01b5\u01b8\3")
        buf.write("\2\2\2\u01b6\u01b4\3\2\2\2\u01b7\u019b\3\2\2\2\u01b7\u01a9")
        buf.write("\3\2\2\2\u01b8+\3\2\2\2\u01b9\u01ba\5V,\2\u01ba\u01bb")
        buf.write("\7o\2\2\u01bb\u01bc\7E\2\2\u01bc\u01bd\7o\2\2\u01bd\u01be")
        buf.write("\5\u008aF\2\u01be\u01c1\3\2\2\2\u01bf\u01c1\5V,\2\u01c0")
        buf.write("\u01b9\3\2\2\2\u01c0\u01bf\3\2\2\2\u01c1-\3\2\2\2\u01c2")
        buf.write("\u01c3\7P\2\2\u01c3\u01c4\7o\2\2\u01c4\u01c5\7Q\2\2\u01c5")
        buf.write("\u01c6\7o\2\2\u01c6\u01ce\5\64\33\2\u01c7\u01c9\7\4\2")
        buf.write("\2\u01c8\u01ca\7o\2\2\u01c9\u01c8\3\2\2\2\u01c9\u01ca")
        buf.write("\3\2\2\2\u01ca\u01cb\3\2\2\2\u01cb\u01cd\5\64\33\2\u01cc")
        buf.write("\u01c7\3\2\2\2\u01cd\u01d0\3\2\2\2\u01ce\u01cc\3\2\2\2")
        buf.write("\u01ce\u01cf\3\2\2\2\u01cf/\3\2\2\2\u01d0\u01ce\3\2\2")
        buf.write("\2\u01d1\u01d2\7R\2\2\u01d2\u01d3\7o\2\2\u01d3\u01d4\5")
        buf.write("V,\2\u01d4\61\3\2\2\2\u01d5\u01d6\7S\2\2\u01d6\u01d7\7")
        buf.write("o\2\2\u01d7\u01d8\5V,\2\u01d8\63\3\2\2\2\u01d9\u01de\5")
        buf.write("V,\2\u01da\u01dc\7o\2\2\u01db\u01da\3\2\2\2\u01db\u01dc")
        buf.write("\3\2\2\2\u01dc\u01dd\3\2\2\2\u01dd\u01df\t\2\2\2\u01de")
        buf.write("\u01db\3\2\2\2\u01de\u01df\3\2\2\2\u01df\65\3\2\2\2\u01e0")
        buf.write("\u01e1\7X\2\2\u01e1\u01e2\7o\2\2\u01e2\u01e3\5V,\2\u01e3")
        buf.write("\67\3\2\2\2\u01e4\u01ef\5:\36\2\u01e5\u01e7\7o\2\2\u01e6")
        buf.write("\u01e5\3\2\2\2\u01e6\u01e7\3\2\2\2\u01e7\u01e8\3\2\2\2")
        buf.write("\u01e8\u01ea\7\4\2\2\u01e9\u01eb\7o\2\2\u01ea\u01e9\3")
        buf.write("\2\2\2\u01ea\u01eb\3\2\2\2\u01eb\u01ec\3\2\2\2\u01ec\u01ee")
        buf.write("\5:\36\2\u01ed\u01e6\3\2\2\2\u01ee\u01f1\3\2\2\2\u01ef")
        buf.write("\u01ed\3\2\2\2\u01ef\u01f0\3\2\2\2\u01f09\3\2\2\2\u01f1")
        buf.write("\u01ef\3\2\2\2\u01f2\u01f4\5\u008aF\2\u01f3\u01f5\7o\2")
        buf.write("\2\u01f4\u01f3\3\2\2\2\u01f4\u01f5\3\2\2\2\u01f5\u01f6")
        buf.write("\3\2\2\2\u01f6\u01f8\7\5\2\2\u01f7\u01f9\7o\2\2\u01f8")
        buf.write("\u01f7\3\2\2\2\u01f8\u01f9\3\2\2\2\u01f9\u01fa\3\2\2\2")
        buf.write("\u01fa\u01fb\5<\37\2\u01fb\u01fe\3\2\2\2\u01fc\u01fe\5")
        buf.write("<\37\2\u01fd\u01f2\3\2\2\2\u01fd\u01fc\3\2\2\2\u01fe;")
        buf.write("\3\2\2\2\u01ff\u0200\5> \2\u0200=\3\2\2\2\u0201\u0208")
        buf.write("\5@!\2\u0202\u0204\7o\2\2\u0203\u0202\3\2\2\2\u0203\u0204")
        buf.write("\3\2\2\2\u0204\u0205\3\2\2\2\u0205\u0207\5B\"\2\u0206")
        buf.write("\u0203\3\2\2\2\u0207\u020a\3\2\2\2\u0208\u0206\3\2\2\2")
        buf.write("\u0208\u0209\3\2\2\2\u0209\u0210\3\2\2\2\u020a\u0208\3")
        buf.write("\2\2\2\u020b\u020c\7\b\2\2\u020c\u020d\5> \2\u020d\u020e")
        buf.write("\7\t\2\2\u020e\u0210\3\2\2\2\u020f\u0201\3\2\2\2\u020f")
        buf.write("\u020b\3\2\2\2\u0210?\3\2\2\2\u0211\u0213\7\b\2\2\u0212")
        buf.write("\u0214\7o\2\2\u0213\u0212\3\2\2\2\u0213\u0214\3\2\2\2")
        buf.write("\u0214\u0219\3\2\2\2\u0215\u0217\5\u008aF\2\u0216\u0218")
        buf.write("\7o\2\2\u0217\u0216\3\2\2\2\u0217\u0218\3\2\2\2\u0218")
        buf.write("\u021a\3\2\2\2\u0219\u0215\3\2\2\2\u0219\u021a\3\2\2\2")
        buf.write("\u021a\u021f\3\2\2\2\u021b\u021d\5L\'\2\u021c\u021e\7")
        buf.write("o\2\2\u021d\u021c\3\2\2\2\u021d\u021e\3\2\2\2\u021e\u0220")
        buf.write("\3\2\2\2\u021f\u021b\3\2\2\2\u021f\u0220\3\2\2\2\u0220")
        buf.write("\u0225\3\2\2\2\u0221\u0223\5H%\2\u0222\u0224\7o\2\2\u0223")
        buf.write("\u0222\3\2\2\2\u0223\u0224\3\2\2\2\u0224\u0226\3\2\2\2")
        buf.write("\u0225\u0221\3\2\2\2\u0225\u0226\3\2\2\2\u0226\u0227\3")
        buf.write("\2\2\2\u0227\u0228\7\t\2\2\u0228A\3\2\2\2\u0229\u022b")
        buf.write("\5D#\2\u022a\u022c\7o\2\2\u022b\u022a\3\2\2\2\u022b\u022c")
        buf.write("\3\2\2\2\u022c\u022d\3\2\2\2\u022d\u022e\5@!\2\u022eC")
        buf.write("\3\2\2\2\u022f\u0231\5\u009cO\2\u0230\u0232\7o\2\2\u0231")
        buf.write("\u0230\3\2\2\2\u0231\u0232\3\2\2\2\u0232\u0233\3\2\2\2")
        buf.write("\u0233\u0235\5\u00a0Q\2\u0234\u0236\7o\2\2\u0235\u0234")
        buf.write("\3\2\2\2\u0235\u0236\3\2\2\2\u0236\u0238\3\2\2\2\u0237")
        buf.write("\u0239\5F$\2\u0238\u0237\3\2\2\2\u0238\u0239\3\2\2\2\u0239")
        buf.write("\u023b\3\2\2\2\u023a\u023c\7o\2\2\u023b\u023a\3\2\2\2")
        buf.write("\u023b\u023c\3\2\2\2\u023c\u023d\3\2\2\2\u023d\u023f\5")
        buf.write("\u00a0Q\2\u023e\u0240\7o\2\2\u023f\u023e\3\2\2\2\u023f")
        buf.write("\u0240\3\2\2\2\u0240\u0241\3\2\2\2\u0241\u0242\5\u009e")
        buf.write("P\2\u0242\u0270\3\2\2\2\u0243\u0245\5\u009cO\2\u0244\u0246")
        buf.write("\7o\2\2\u0245\u0244\3\2\2\2\u0245\u0246\3\2\2\2\u0246")
        buf.write("\u0247\3\2\2\2\u0247\u0249\5\u00a0Q\2\u0248\u024a\7o\2")
        buf.write("\2\u0249\u0248\3\2\2\2\u0249\u024a\3\2\2\2\u024a\u024c")
        buf.write("\3\2\2\2\u024b\u024d\5F$\2\u024c\u024b\3\2\2\2\u024c\u024d")
        buf.write("\3\2\2\2\u024d\u024f\3\2\2\2\u024e\u0250\7o\2\2\u024f")
        buf.write("\u024e\3\2\2\2\u024f\u0250\3\2\2\2\u0250\u0251\3\2\2\2")
        buf.write("\u0251\u0252\5\u00a0Q\2\u0252\u0270\3\2\2\2\u0253\u0255")
        buf.write("\5\u00a0Q\2\u0254\u0256\7o\2\2\u0255\u0254\3\2\2\2\u0255")
        buf.write("\u0256\3\2\2\2\u0256\u0258\3\2\2\2\u0257\u0259\5F$\2\u0258")
        buf.write("\u0257\3\2\2\2\u0258\u0259\3\2\2\2\u0259\u025b\3\2\2\2")
        buf.write("\u025a\u025c\7o\2\2\u025b\u025a\3\2\2\2\u025b\u025c\3")
        buf.write("\2\2\2\u025c\u025d\3\2\2\2\u025d\u025f\5\u00a0Q\2\u025e")
        buf.write("\u0260\7o\2\2\u025f\u025e\3\2\2\2\u025f\u0260\3\2\2\2")
        buf.write("\u0260\u0261\3\2\2\2\u0261\u0262\5\u009eP\2\u0262\u0270")
        buf.write("\3\2\2\2\u0263\u0265\5\u00a0Q\2\u0264\u0266\7o\2\2\u0265")
        buf.write("\u0264\3\2\2\2\u0265\u0266\3\2\2\2\u0266\u0268\3\2\2\2")
        buf.write("\u0267\u0269\5F$\2\u0268\u0267\3\2\2\2\u0268\u0269\3\2")
        buf.write("\2\2\u0269\u026b\3\2\2\2\u026a\u026c\7o\2\2\u026b\u026a")
        buf.write("\3\2\2\2\u026b\u026c\3\2\2\2\u026c\u026d\3\2\2\2\u026d")
        buf.write("\u026e\5\u00a0Q\2\u026e\u0270\3\2\2\2\u026f\u022f\3\2")
        buf.write("\2\2\u026f\u0243\3\2\2\2\u026f\u0253\3\2\2\2\u026f\u0263")
        buf.write("\3\2\2\2\u0270E\3\2\2\2\u0271\u0273\7\n\2\2\u0272\u0274")
        buf.write("\7o\2\2\u0273\u0272\3\2\2\2\u0273\u0274\3\2\2\2\u0274")
        buf.write("\u0279\3\2\2\2\u0275\u0277\5\u008aF\2\u0276\u0278\7o\2")
        buf.write("\2\u0277\u0276\3\2\2\2\u0277\u0278\3\2\2\2\u0278\u027a")
        buf.write("\3\2\2\2\u0279\u0275\3\2\2\2\u0279\u027a\3\2\2\2\u027a")
        buf.write("\u027f\3\2\2\2\u027b\u027d\5J&\2\u027c\u027e\7o\2\2\u027d")
        buf.write("\u027c\3\2\2\2\u027d\u027e\3\2\2\2\u027e\u0280\3\2\2\2")
        buf.write("\u027f\u027b\3\2\2\2\u027f\u0280\3\2\2\2\u0280\u0282\3")
        buf.write("\2\2\2\u0281\u0283\5P)\2\u0282\u0281\3\2\2\2\u0282\u0283")
        buf.write("\3\2\2\2\u0283\u0288\3\2\2\2\u0284\u0286\5H%\2\u0285\u0287")
        buf.write("\7o\2\2\u0286\u0285\3\2\2\2\u0286\u0287\3\2\2\2\u0287")
        buf.write("\u0289\3\2\2\2\u0288\u0284\3\2\2\2\u0288\u0289\3\2\2\2")
        buf.write("\u0289\u028a\3\2\2\2\u028a\u028b\7\13\2\2\u028bG\3\2\2")
        buf.write("\2\u028c\u028f\5\u008eH\2\u028d\u028f\5\u0090I\2\u028e")
        buf.write("\u028c\3\2\2\2\u028e\u028d\3\2\2\2\u028fI\3\2\2\2\u0290")
        buf.write("\u0292\7\f\2\2\u0291\u0293\7o\2\2\u0292\u0291\3\2\2\2")
        buf.write("\u0292\u0293\3\2\2\2\u0293\u0294\3\2\2\2\u0294\u02a2\5")
        buf.write("T+\2\u0295\u0297\7o\2\2\u0296\u0295\3\2\2\2\u0296\u0297")
        buf.write("\3\2\2\2\u0297\u0298\3\2\2\2\u0298\u029a\7\r\2\2\u0299")
        buf.write("\u029b\7\f\2\2\u029a\u0299\3\2\2\2\u029a\u029b\3\2\2\2")
        buf.write("\u029b\u029d\3\2\2\2\u029c\u029e\7o\2\2\u029d\u029c\3")
        buf.write("\2\2\2\u029d\u029e\3\2\2\2\u029e\u029f\3\2\2\2\u029f\u02a1")
        buf.write("\5T+\2\u02a0\u0296\3\2\2\2\u02a1\u02a4\3\2\2\2\u02a2\u02a0")
        buf.write("\3\2\2\2\u02a2\u02a3\3\2\2\2\u02a3K\3\2\2\2\u02a4\u02a2")
        buf.write("\3\2\2\2\u02a5\u02ac\5N(\2\u02a6\u02a8\7o\2\2\u02a7\u02a6")
        buf.write("\3\2\2\2\u02a7\u02a8\3\2\2\2\u02a8\u02a9\3\2\2\2\u02a9")
        buf.write("\u02ab\5N(\2\u02aa\u02a7\3\2\2\2\u02ab\u02ae\3\2\2\2\u02ac")
        buf.write("\u02aa\3\2\2\2\u02ac\u02ad\3\2\2\2\u02adM\3\2\2\2\u02ae")
        buf.write("\u02ac\3\2\2\2\u02af\u02b1\7\f\2\2\u02b0\u02b2\7o\2\2")
        buf.write("\u02b1\u02b0\3\2\2\2\u02b1\u02b2\3\2\2\2\u02b2\u02b3\3")
        buf.write("\2\2\2\u02b3\u02b4\5R*\2\u02b4O\3\2\2\2\u02b5\u02b7\7")
        buf.write("\7\2\2\u02b6\u02b8\7o\2\2\u02b7\u02b6\3\2\2\2\u02b7\u02b8")
        buf.write("\3\2\2\2\u02b8\u02bd\3\2\2\2\u02b9\u02bb\5\u0096L\2\u02ba")
        buf.write("\u02bc\7o\2\2\u02bb\u02ba\3\2\2\2\u02bb\u02bc\3\2\2\2")
        buf.write("\u02bc\u02be\3\2\2\2\u02bd\u02b9\3\2\2\2\u02bd\u02be\3")
        buf.write("\2\2\2\u02be\u02c9\3\2\2\2\u02bf\u02c1\7\16\2\2\u02c0")
        buf.write("\u02c2\7o\2\2\u02c1\u02c0\3\2\2\2\u02c1\u02c2\3\2\2\2")
        buf.write("\u02c2\u02c7\3\2\2\2\u02c3\u02c5\5\u0096L\2\u02c4\u02c6")
        buf.write("\7o\2\2\u02c5\u02c4\3\2\2\2\u02c5\u02c6\3\2\2\2\u02c6")
        buf.write("\u02c8\3\2\2\2\u02c7\u02c3\3\2\2\2\u02c7\u02c8\3\2\2\2")
        buf.write("\u02c8\u02ca\3\2\2\2\u02c9\u02bf\3\2\2\2\u02c9\u02ca\3")
        buf.write("\2\2\2\u02caQ\3\2\2\2\u02cb\u02cc\5\u009aN\2\u02ccS\3")
        buf.write("\2\2\2\u02cd\u02ce\5\u009aN\2\u02ceU\3\2\2\2\u02cf\u02d0")
        buf.write("\5X-\2\u02d0W\3\2\2\2\u02d1\u02d8\5Z.\2\u02d2\u02d3\7")
        buf.write("o\2\2\u02d3\u02d4\7Y\2\2\u02d4\u02d5\7o\2\2\u02d5\u02d7")
        buf.write("\5Z.\2\u02d6\u02d2\3\2\2\2\u02d7\u02da\3\2\2\2\u02d8\u02d6")
        buf.write("\3\2\2\2\u02d8\u02d9\3\2\2\2\u02d9Y\3\2\2\2\u02da\u02d8")
        buf.write("\3\2\2\2\u02db\u02e2\5\\/\2\u02dc\u02dd\7o\2\2\u02dd\u02de")
        buf.write("\7Z\2\2\u02de\u02df\7o\2\2\u02df\u02e1\5\\/\2\u02e0\u02dc")
        buf.write("\3\2\2\2\u02e1\u02e4\3\2\2\2\u02e2\u02e0\3\2\2\2\u02e2")
        buf.write("\u02e3\3\2\2\2\u02e3[\3\2\2\2\u02e4\u02e2\3\2\2\2\u02e5")
        buf.write("\u02ec\5^\60\2\u02e6\u02e7\7o\2\2\u02e7\u02e8\7[\2\2\u02e8")
        buf.write("\u02e9\7o\2\2\u02e9\u02eb\5^\60\2\u02ea\u02e6\3\2\2\2")
        buf.write("\u02eb\u02ee\3\2\2\2\u02ec\u02ea\3\2\2\2\u02ec\u02ed\3")
        buf.write("\2\2\2\u02ed]\3\2\2\2\u02ee\u02ec\3\2\2\2\u02ef\u02f1")
        buf.write("\7\\\2\2\u02f0\u02f2\7o\2\2\u02f1\u02f0\3\2\2\2\u02f1")
        buf.write("\u02f2\3\2\2\2\u02f2\u02f4\3\2\2\2\u02f3\u02ef\3\2\2\2")
        buf.write("\u02f4\u02f7\3\2\2\2\u02f5\u02f3\3\2\2\2\u02f5\u02f6\3")
        buf.write("\2\2\2\u02f6\u02f8\3\2\2\2\u02f7\u02f5\3\2\2\2\u02f8\u02f9")
        buf.write("\5`\61\2\u02f9_\3\2\2\2\u02fa\u0301\5b\62\2\u02fb\u02fd")
        buf.write("\7o\2\2\u02fc\u02fb\3\2\2\2\u02fc\u02fd\3\2\2\2\u02fd")
        buf.write("\u02fe\3\2\2\2\u02fe\u0300\5v<\2\u02ff\u02fc\3\2\2\2\u0300")
        buf.write("\u0303\3\2\2\2\u0301\u02ff\3\2\2\2\u0301\u0302\3\2\2\2")
        buf.write("\u0302a\3\2\2\2\u0303\u0301\3\2\2\2\u0304\u0317\5d\63")
        buf.write("\2\u0305\u0307\7o\2\2\u0306\u0305\3\2\2\2\u0306\u0307")
        buf.write("\3\2\2\2\u0307\u0308\3\2\2\2\u0308\u030a\7\17\2\2\u0309")
        buf.write("\u030b\7o\2\2\u030a\u0309\3\2\2\2\u030a\u030b\3\2\2\2")
        buf.write("\u030b\u030c\3\2\2\2\u030c\u0316\5d\63\2\u030d\u030f\7")
        buf.write("o\2\2\u030e\u030d\3\2\2\2\u030e\u030f\3\2\2\2\u030f\u0310")
        buf.write("\3\2\2\2\u0310\u0312\7\20\2\2\u0311\u0313\7o\2\2\u0312")
        buf.write("\u0311\3\2\2\2\u0312\u0313\3\2\2\2\u0313\u0314\3\2\2\2")
        buf.write("\u0314\u0316\5d\63\2\u0315\u0306\3\2\2\2\u0315\u030e\3")
        buf.write("\2\2\2\u0316\u0319\3\2\2\2\u0317\u0315\3\2\2\2\u0317\u0318")
        buf.write("\3\2\2\2\u0318c\3\2\2\2\u0319\u0317\3\2\2\2\u031a\u0335")
        buf.write("\5f\64\2\u031b\u031d\7o\2\2\u031c\u031b\3\2\2\2\u031c")
        buf.write("\u031d\3\2\2\2\u031d\u031e\3\2\2\2\u031e\u0320\7\7\2\2")
        buf.write("\u031f\u0321\7o\2\2\u0320\u031f\3\2\2\2\u0320\u0321\3")
        buf.write("\2\2\2\u0321\u0322\3\2\2\2\u0322\u0334\5f\64\2\u0323\u0325")
        buf.write("\7o\2\2\u0324\u0323\3\2\2\2\u0324\u0325\3\2\2\2\u0325")
        buf.write("\u0326\3\2\2\2\u0326\u0328\7\21\2\2\u0327\u0329\7o\2\2")
        buf.write("\u0328\u0327\3\2\2\2\u0328\u0329\3\2\2\2\u0329\u032a\3")
        buf.write("\2\2\2\u032a\u0334\5f\64\2\u032b\u032d\7o\2\2\u032c\u032b")
        buf.write("\3\2\2\2\u032c\u032d\3\2\2\2\u032d\u032e\3\2\2\2\u032e")
        buf.write("\u0330\7\22\2\2\u032f\u0331\7o\2\2\u0330\u032f\3\2\2\2")
        buf.write("\u0330\u0331\3\2\2\2\u0331\u0332\3\2\2\2\u0332\u0334\5")
        buf.write("f\64\2\u0333\u031c\3\2\2\2\u0333\u0324\3\2\2\2\u0333\u032c")
        buf.write("\3\2\2\2\u0334\u0337\3\2\2\2\u0335\u0333\3\2\2\2\u0335")
        buf.write("\u0336\3\2\2\2\u0336e\3\2\2\2\u0337\u0335\3\2\2\2\u0338")
        buf.write("\u0343\5h\65\2\u0339\u033b\7o\2\2\u033a\u0339\3\2\2\2")
        buf.write("\u033a\u033b\3\2\2\2\u033b\u033c\3\2\2\2\u033c\u033e\7")
        buf.write("\23\2\2\u033d\u033f\7o\2\2\u033e\u033d\3\2\2\2\u033e\u033f")
        buf.write("\3\2\2\2\u033f\u0340\3\2\2\2\u0340\u0342\5h\65\2\u0341")
        buf.write("\u033a\3\2\2\2\u0342\u0345\3\2\2\2\u0343\u0341\3\2\2\2")
        buf.write("\u0343\u0344\3\2\2\2\u0344g\3\2\2\2\u0345\u0343\3\2\2")
        buf.write("\2\u0346\u0348\t\3\2\2\u0347\u0349\7o\2\2\u0348\u0347")
        buf.write("\3\2\2\2\u0348\u0349\3\2\2\2\u0349\u034b\3\2\2\2\u034a")
        buf.write("\u0346\3\2\2\2\u034b\u034e\3\2\2\2\u034c\u034a\3\2\2\2")
        buf.write("\u034c\u034d\3\2\2\2\u034d\u034f\3\2\2\2\u034e\u034c\3")
        buf.write("\2\2\2\u034f\u0350\5j\66\2\u0350i\3\2\2\2\u0351\u0387")
        buf.write("\5l\67\2\u0352\u0354\7o\2\2\u0353\u0352\3\2\2\2\u0353")
        buf.write("\u0354\3\2\2\2\u0354\u0355\3\2\2\2\u0355\u0356\7\n\2\2")
        buf.write("\u0356\u0357\5V,\2\u0357\u0358\7\13\2\2\u0358\u0386\3")
        buf.write("\2\2\2\u0359\u035b\7o\2\2\u035a\u0359\3\2\2\2\u035a\u035b")
        buf.write("\3\2\2\2\u035b\u035c\3\2\2\2\u035c\u035e\7\n\2\2\u035d")
        buf.write("\u035f\5V,\2\u035e\u035d\3\2\2\2\u035e\u035f\3\2\2\2\u035f")
        buf.write("\u0360\3\2\2\2\u0360\u0362\7\16\2\2\u0361\u0363\5V,\2")
        buf.write("\u0362\u0361\3\2\2\2\u0362\u0363\3\2\2\2\u0363\u0364\3")
        buf.write("\2\2\2\u0364\u0386\7\13\2\2\u0365\u0367\7o\2\2\u0366\u0365")
        buf.write("\3\2\2\2\u0366\u0367\3\2\2\2\u0367\u0368\3\2\2\2\u0368")
        buf.write("\u0376\7\24\2\2\u0369\u036a\7o\2\2\u036a\u0376\7]\2\2")
        buf.write("\u036b\u036c\7o\2\2\u036c\u036d\7^\2\2\u036d\u036e\7o")
        buf.write("\2\2\u036e\u0376\7M\2\2\u036f\u0370\7o\2\2\u0370\u0371")
        buf.write("\7_\2\2\u0371\u0372\7o\2\2\u0372\u0376\7M\2\2\u0373\u0374")
        buf.write("\7o\2\2\u0374\u0376\7`\2\2\u0375\u0366\3\2\2\2\u0375\u0369")
        buf.write("\3\2\2\2\u0375\u036b\3\2\2\2\u0375\u036f\3\2\2\2\u0375")
        buf.write("\u0373\3\2\2\2\u0376\u0378\3\2\2\2\u0377\u0379\7o\2\2")
        buf.write("\u0378\u0377\3\2\2\2\u0378\u0379\3\2\2\2\u0379\u037a\3")
        buf.write("\2\2\2\u037a\u0386\5l\67\2\u037b\u037c\7o\2\2\u037c\u037d")
        buf.write("\7a\2\2\u037d\u037e\7o\2\2\u037e\u0386\7b\2\2\u037f\u0380")
        buf.write("\7o\2\2\u0380\u0381\7a\2\2\u0381\u0382\7o\2\2\u0382\u0383")
        buf.write("\7\\\2\2\u0383\u0384\7o\2\2\u0384\u0386\7b\2\2\u0385\u0353")
        buf.write("\3\2\2\2\u0385\u035a\3\2\2\2\u0385\u0375\3\2\2\2\u0385")
        buf.write("\u037b\3\2\2\2\u0385\u037f\3\2\2\2\u0386\u0389\3\2\2\2")
        buf.write("\u0387\u0385\3\2\2\2\u0387\u0388\3\2\2\2\u0388k\3\2\2")
        buf.write("\2\u0389\u0387\3\2\2\2\u038a\u0394\5n8\2\u038b\u038d\7")
        buf.write("o\2\2\u038c\u038b\3\2\2\2\u038c\u038d\3\2\2\2\u038d\u0390")
        buf.write("\3\2\2\2\u038e\u0391\5\u0088E\2\u038f\u0391\5L\'\2\u0390")
        buf.write("\u038e\3\2\2\2\u0390\u038f\3\2\2\2\u0391\u0393\3\2\2\2")
        buf.write("\u0392\u038c\3\2\2\2\u0393\u0396\3\2\2\2\u0394\u0392\3")
        buf.write("\2\2\2\u0394\u0395\3\2\2\2\u0395m\3\2\2\2\u0396\u0394")
        buf.write("\3\2\2\2\u0397\u0408\5p9\2\u0398\u0408\5\u0090I\2\u0399")
        buf.write("\u039b\7c\2\2\u039a\u039c\7o\2\2\u039b\u039a\3\2\2\2\u039b")
        buf.write("\u039c\3\2\2\2\u039c\u039d\3\2\2\2\u039d\u039f\7\b\2\2")
        buf.write("\u039e\u03a0\7o\2\2\u039f\u039e\3\2\2\2\u039f\u03a0\3")
        buf.write("\2\2\2\u03a0\u03a1\3\2\2\2\u03a1\u03a3\7\7\2\2\u03a2\u03a4")
        buf.write("\7o\2\2\u03a3\u03a2\3\2\2\2\u03a3\u03a4\3\2\2\2\u03a4")
        buf.write("\u03a5\3\2\2\2\u03a5\u0408\7\t\2\2\u03a6\u0408\5\u0084")
        buf.write("C\2\u03a7\u0408\5\u0086D\2\u03a8\u03aa\7d\2\2\u03a9\u03ab")
        buf.write("\7o\2\2\u03aa\u03a9\3\2\2\2\u03aa\u03ab\3\2\2\2\u03ab")
        buf.write("\u03ac\3\2\2\2\u03ac\u03ae\7\b\2\2\u03ad\u03af\7o\2\2")
        buf.write("\u03ae\u03ad\3\2\2\2\u03ae\u03af\3\2\2\2\u03af\u03b0\3")
        buf.write("\2\2\2\u03b0\u03b2\5|?\2\u03b1\u03b3\7o\2\2\u03b2\u03b1")
        buf.write("\3\2\2\2\u03b2\u03b3\3\2\2\2\u03b3\u03b4\3\2\2\2\u03b4")
        buf.write("\u03b5\7\t\2\2\u03b5\u0408\3\2\2\2\u03b6\u03b8\7e\2\2")
        buf.write("\u03b7\u03b9\7o\2\2\u03b8\u03b7\3\2\2\2\u03b8\u03b9\3")
        buf.write("\2\2\2\u03b9\u03ba\3\2\2\2\u03ba\u03bc\7\b\2\2\u03bb\u03bd")
        buf.write("\7o\2\2\u03bc\u03bb\3\2\2\2\u03bc\u03bd\3\2\2\2\u03bd")
        buf.write("\u03be\3\2\2\2\u03be\u03c0\5|?\2\u03bf\u03c1\7o\2\2\u03c0")
        buf.write("\u03bf\3\2\2\2\u03c0\u03c1\3\2\2\2\u03c1\u03c7\3\2\2\2")
        buf.write("\u03c2\u03c4\7o\2\2\u03c3\u03c2\3\2\2\2\u03c3\u03c4\3")
        buf.write("\2\2\2\u03c4\u03c5\3\2\2\2\u03c5\u03c6\7\r\2\2\u03c6\u03c8")
        buf.write("\5V,\2\u03c7\u03c3\3\2\2\2\u03c7\u03c8\3\2\2\2\u03c8\u03c9")
        buf.write("\3\2\2\2\u03c9\u03ca\7\t\2\2\u03ca\u0408\3\2\2\2\u03cb")
        buf.write("\u03cd\7A\2\2\u03cc\u03ce\7o\2\2\u03cd\u03cc\3\2\2\2\u03cd")
        buf.write("\u03ce\3\2\2\2\u03ce\u03cf\3\2\2\2\u03cf\u03d1\7\b\2\2")
        buf.write("\u03d0\u03d2\7o\2\2\u03d1\u03d0\3\2\2\2\u03d1\u03d2\3")
        buf.write("\2\2\2\u03d2\u03d3\3\2\2\2\u03d3\u03d5\5|?\2\u03d4\u03d6")
        buf.write("\7o\2\2\u03d5\u03d4\3\2\2\2\u03d5\u03d6\3\2\2\2\u03d6")
        buf.write("\u03d7\3\2\2\2\u03d7\u03d8\7\t\2\2\u03d8\u0408\3\2\2\2")
        buf.write("\u03d9\u03db\7f\2\2\u03da\u03dc\7o\2\2\u03db\u03da\3\2")
        buf.write("\2\2\u03db\u03dc\3\2\2\2\u03dc\u03dd\3\2\2\2\u03dd\u03df")
        buf.write("\7\b\2\2\u03de\u03e0\7o\2\2\u03df\u03de\3\2\2\2\u03df")
        buf.write("\u03e0\3\2\2\2\u03e0\u03e1\3\2\2\2\u03e1\u03e3\5|?\2\u03e2")
        buf.write("\u03e4\7o\2\2\u03e3\u03e2\3\2\2\2\u03e3\u03e4\3\2\2\2")
        buf.write("\u03e4\u03e5\3\2\2\2\u03e5\u03e6\7\t\2\2\u03e6\u0408\3")
        buf.write("\2\2\2\u03e7\u03e9\7g\2\2\u03e8\u03ea\7o\2\2\u03e9\u03e8")
        buf.write("\3\2\2\2\u03e9\u03ea\3\2\2\2\u03ea\u03eb\3\2\2\2\u03eb")
        buf.write("\u03ed\7\b\2\2\u03ec\u03ee\7o\2\2\u03ed\u03ec\3\2\2\2")
        buf.write("\u03ed\u03ee\3\2\2\2\u03ee\u03ef\3\2\2\2\u03ef\u03f1\5")
        buf.write("|?\2\u03f0\u03f2\7o\2\2\u03f1\u03f0\3\2\2\2\u03f1\u03f2")
        buf.write("\3\2\2\2\u03f2\u03f3\3\2\2\2\u03f3\u03f4\7\t\2\2\u03f4")
        buf.write("\u0408\3\2\2\2\u03f5\u03f7\7h\2\2\u03f6\u03f8\7o\2\2\u03f7")
        buf.write("\u03f6\3\2\2\2\u03f7\u03f8\3\2\2\2\u03f8\u03f9\3\2\2\2")
        buf.write("\u03f9\u03fb\7\b\2\2\u03fa\u03fc\7o\2\2\u03fb\u03fa\3")
        buf.write("\2\2\2\u03fb\u03fc\3\2\2\2\u03fc\u03fd\3\2\2\2\u03fd\u03ff")
        buf.write("\5|?\2\u03fe\u0400\7o\2\2\u03ff\u03fe\3\2\2\2\u03ff\u0400")
        buf.write("\3\2\2\2\u0400\u0401\3\2\2\2\u0401\u0402\7\t\2\2\u0402")
        buf.write("\u0408\3\2\2\2\u0403\u0408\5z>\2\u0404\u0408\5x=\2\u0405")
        buf.write("\u0408\5\u0080A\2\u0406\u0408\5\u008aF\2\u0407\u0397\3")
        buf.write("\2\2\2\u0407\u0398\3\2\2\2\u0407\u0399\3\2\2\2\u0407\u03a6")
        buf.write("\3\2\2\2\u0407\u03a7\3\2\2\2\u0407\u03a8\3\2\2\2\u0407")
        buf.write("\u03b6\3\2\2\2\u0407\u03cb\3\2\2\2\u0407\u03d9\3\2\2\2")
        buf.write("\u0407\u03e7\3\2\2\2\u0407\u03f5\3\2\2\2\u0407\u0403\3")
        buf.write("\2\2\2\u0407\u0404\3\2\2\2\u0407\u0405\3\2\2\2\u0407\u0406")
        buf.write("\3\2\2\2\u0408o\3\2\2\2\u0409\u0410\5\u008cG\2\u040a\u0410")
        buf.write("\7\62\2\2\u040b\u0410\5r:\2\u040c\u0410\7b\2\2\u040d\u0410")
        buf.write("\5\u008eH\2\u040e\u0410\5t;\2\u040f\u0409\3\2\2\2\u040f")
        buf.write("\u040a\3\2\2\2\u040f\u040b\3\2\2\2\u040f\u040c\3\2\2\2")
        buf.write("\u040f\u040d\3\2\2\2\u040f\u040e\3\2\2\2\u0410q\3\2\2")
        buf.write("\2\u0411\u0412\t\4\2\2\u0412s\3\2\2\2\u0413\u0415\7\n")
        buf.write("\2\2\u0414\u0416\7o\2\2\u0415\u0414\3\2\2\2\u0415\u0416")
        buf.write("\3\2\2\2\u0416\u0428\3\2\2\2\u0417\u0419\5V,\2\u0418\u041a")
        buf.write("\7o\2\2\u0419\u0418\3\2\2\2\u0419\u041a\3\2\2\2\u041a")
        buf.write("\u0425\3\2\2\2\u041b\u041d\7\4\2\2\u041c\u041e\7o\2\2")
        buf.write("\u041d\u041c\3\2\2\2\u041d\u041e\3\2\2\2\u041e\u041f\3")
        buf.write("\2\2\2\u041f\u0421\5V,\2\u0420\u0422\7o\2\2\u0421\u0420")
        buf.write("\3\2\2\2\u0421\u0422\3\2\2\2\u0422\u0424\3\2\2\2\u0423")
        buf.write("\u041b\3\2\2\2\u0424\u0427\3\2\2\2\u0425\u0423\3\2\2\2")
        buf.write("\u0425\u0426\3\2\2\2\u0426\u0429\3\2\2\2\u0427\u0425\3")
        buf.write("\2\2\2\u0428\u0417\3\2\2\2\u0428\u0429\3\2\2\2\u0429\u042a")
        buf.write("\3\2\2\2\u042a\u042b\7\13\2\2\u042bu\3\2\2\2\u042c\u042e")
        buf.write("\7\5\2\2\u042d\u042f\7o\2\2\u042e\u042d\3\2\2\2\u042e")
        buf.write("\u042f\3\2\2\2\u042f\u0430\3\2\2\2\u0430\u0450\5b\62\2")
        buf.write("\u0431\u0433\7\25\2\2\u0432\u0434\7o\2\2\u0433\u0432\3")
        buf.write("\2\2\2\u0433\u0434\3\2\2\2\u0434\u0435\3\2\2\2\u0435\u0450")
        buf.write("\5b\62\2\u0436\u0438\7\26\2\2\u0437\u0439\7o\2\2\u0438")
        buf.write("\u0437\3\2\2\2\u0438\u0439\3\2\2\2\u0439\u043a\3\2\2\2")
        buf.write("\u043a\u0450\5b\62\2\u043b\u043d\7\27\2\2\u043c\u043e")
        buf.write("\7o\2\2\u043d\u043c\3\2\2\2\u043d\u043e\3\2\2\2\u043e")
        buf.write("\u043f\3\2\2\2\u043f\u0450\5b\62\2\u0440\u0442\7\30\2")
        buf.write("\2\u0441\u0443\7o\2\2\u0442\u0441\3\2\2\2\u0442\u0443")
        buf.write("\3\2\2\2\u0443\u0444\3\2\2\2\u0444\u0450\5b\62\2\u0445")
        buf.write("\u0447\7\31\2\2\u0446\u0448\7o\2\2\u0447\u0446\3\2\2\2")
        buf.write("\u0447\u0448\3\2\2\2\u0448\u0449\3\2\2\2\u0449\u0450\5")
        buf.write("b\62\2\u044a\u044c\7\32\2\2\u044b\u044d\7o\2\2\u044c\u044b")
        buf.write("\3\2\2\2\u044c\u044d\3\2\2\2\u044d\u044e\3\2\2\2\u044e")
        buf.write("\u0450\5b\62\2\u044f\u042c\3\2\2\2\u044f\u0431\3\2\2\2")
        buf.write("\u044f\u0436\3\2\2\2\u044f\u043b\3\2\2\2\u044f\u0440\3")
        buf.write("\2\2\2\u044f\u0445\3\2\2\2\u044f\u044a\3\2\2\2\u0450w")
        buf.write("\3\2\2\2\u0451\u0453\7\b\2\2\u0452\u0454\7o\2\2\u0453")
        buf.write("\u0452\3\2\2\2\u0453\u0454\3\2\2\2\u0454\u0455\3\2\2\2")
        buf.write("\u0455\u0457\5V,\2\u0456\u0458\7o\2\2\u0457\u0456\3\2")
        buf.write("\2\2\u0457\u0458\3\2\2\2\u0458\u0459\3\2\2\2\u0459\u045a")
        buf.write("\7\t\2\2\u045ay\3\2\2\2\u045b\u0460\5@!\2\u045c\u045e")
        buf.write("\7o\2\2\u045d\u045c\3\2\2\2\u045d\u045e\3\2\2\2\u045e")
        buf.write("\u045f\3\2\2\2\u045f\u0461\5B\"\2\u0460\u045d\3\2\2\2")
        buf.write("\u0461\u0462\3\2\2\2\u0462\u0460\3\2\2\2\u0462\u0463\3")
        buf.write("\2\2\2\u0463{\3\2\2\2\u0464\u0469\5~@\2\u0465\u0467\7")
        buf.write("o\2\2\u0466\u0465\3\2\2\2\u0466\u0467\3\2\2\2\u0467\u0468")
        buf.write("\3\2\2\2\u0468\u046a\5\66\34\2\u0469\u0466\3\2\2\2\u0469")
        buf.write("\u046a\3\2\2\2\u046a}\3\2\2\2\u046b\u046c\5\u008aF\2\u046c")
        buf.write("\u046d\7o\2\2\u046d\u046e\7]\2\2\u046e\u046f\7o\2\2\u046f")
        buf.write("\u0470\5V,\2\u0470\177\3\2\2\2\u0471\u0473\5\u0082B\2")
        buf.write("\u0472\u0474\7o\2\2\u0473\u0472\3\2\2\2\u0473\u0474\3")
        buf.write("\2\2\2\u0474\u0475\3\2\2\2\u0475\u0477\7\b\2\2\u0476\u0478")
        buf.write("\7o\2\2\u0477\u0476\3\2\2\2\u0477\u0478\3\2\2\2\u0478")
        buf.write("\u047d\3\2\2\2\u0479\u047b\7N\2\2\u047a\u047c\7o\2\2\u047b")
        buf.write("\u047a\3\2\2\2\u047b\u047c\3\2\2\2\u047c\u047e\3\2\2\2")
        buf.write("\u047d\u0479\3\2\2\2\u047d\u047e\3\2\2\2\u047e\u0490\3")
        buf.write("\2\2\2\u047f\u0481\5V,\2\u0480\u0482\7o\2\2\u0481\u0480")
        buf.write("\3\2\2\2\u0481\u0482\3\2\2\2\u0482\u048d\3\2\2\2\u0483")
        buf.write("\u0485\7\4\2\2\u0484\u0486\7o\2\2\u0485\u0484\3\2\2\2")
        buf.write("\u0485\u0486\3\2\2\2\u0486\u0487\3\2\2\2\u0487\u0489\5")
        buf.write("V,\2\u0488\u048a\7o\2\2\u0489\u0488\3\2\2\2\u0489\u048a")
        buf.write("\3\2\2\2\u048a\u048c\3\2\2\2\u048b\u0483\3\2\2\2\u048c")
        buf.write("\u048f\3\2\2\2\u048d\u048b\3\2\2\2\u048d\u048e\3\2\2\2")
        buf.write("\u048e\u0491\3\2\2\2\u048f\u048d\3\2\2\2\u0490\u047f\3")
        buf.write("\2\2\2\u0490\u0491\3\2\2\2\u0491\u0492\3\2\2\2\u0492\u0493")
        buf.write("\7\t\2\2\u0493\u0081\3\2\2\2\u0494\u0495\t\5\2\2\u0495")
        buf.write("\u0083\3\2\2\2\u0496\u0498\7\n\2\2\u0497\u0499\7o\2\2")
        buf.write("\u0498\u0497\3\2\2\2\u0498\u0499\3\2\2\2\u0499\u049a\3")
        buf.write("\2\2\2\u049a\u04a3\5|?\2\u049b\u049d\7o\2\2\u049c\u049b")
        buf.write("\3\2\2\2\u049c\u049d\3\2\2\2\u049d\u049e\3\2\2\2\u049e")
        buf.write("\u04a0\7\r\2\2\u049f\u04a1\7o\2\2\u04a0\u049f\3\2\2\2")
        buf.write("\u04a0\u04a1\3\2\2\2\u04a1\u04a2\3\2\2\2\u04a2\u04a4\5")
        buf.write("V,\2\u04a3\u049c\3\2\2\2\u04a3\u04a4\3\2\2\2\u04a4\u04a6")
        buf.write("\3\2\2\2\u04a5\u04a7\7o\2\2\u04a6\u04a5\3\2\2\2\u04a6")
        buf.write("\u04a7\3\2\2\2\u04a7\u04a8\3\2\2\2\u04a8\u04a9\7\13\2")
        buf.write("\2\u04a9\u0085\3\2\2\2\u04aa\u04ac\7\n\2\2\u04ab\u04ad")
        buf.write("\7o\2\2\u04ac\u04ab\3\2\2\2\u04ac\u04ad\3\2\2\2\u04ad")
        buf.write("\u04b6\3\2\2\2\u04ae\u04b0\5\u008aF\2\u04af\u04b1\7o\2")
        buf.write("\2\u04b0\u04af\3\2\2\2\u04b0\u04b1\3\2\2\2\u04b1\u04b2")
        buf.write("\3\2\2\2\u04b2\u04b4\7\5\2\2\u04b3\u04b5\7o\2\2\u04b4")
        buf.write("\u04b3\3\2\2\2\u04b4\u04b5\3\2\2\2\u04b5\u04b7\3\2\2\2")
        buf.write("\u04b6\u04ae\3\2\2\2\u04b6\u04b7\3\2\2\2\u04b7\u04b8\3")
        buf.write("\2\2\2\u04b8\u04ba\5z>\2\u04b9\u04bb\7o\2\2\u04ba\u04b9")
        buf.write("\3\2\2\2\u04ba\u04bb\3\2\2\2\u04bb\u04c4\3\2\2\2\u04bc")
        buf.write("\u04be\7X\2\2\u04bd\u04bf\7o\2\2\u04be\u04bd\3\2\2\2\u04be")
        buf.write("\u04bf\3\2\2\2\u04bf\u04c0\3\2\2\2\u04c0\u04c2\5V,\2\u04c1")
        buf.write("\u04c3\7o\2\2\u04c2\u04c1\3\2\2\2\u04c2\u04c3\3\2\2\2")
        buf.write("\u04c3\u04c5\3\2\2\2\u04c4\u04bc\3\2\2\2\u04c4\u04c5\3")
        buf.write("\2\2\2\u04c5\u04c6\3\2\2\2\u04c6\u04c8\7\r\2\2\u04c7\u04c9")
        buf.write("\7o\2\2\u04c8\u04c7\3\2\2\2\u04c8\u04c9\3\2\2\2\u04c9")
        buf.write("\u04ca\3\2\2\2\u04ca\u04cc\5V,\2\u04cb\u04cd\7o\2\2\u04cc")
        buf.write("\u04cb\3\2\2\2\u04cc\u04cd\3\2\2\2\u04cd\u04ce\3\2\2\2")
        buf.write("\u04ce\u04cf\7\13\2\2\u04cf\u0087\3\2\2\2\u04d0\u04d2")
        buf.write("\7\33\2\2\u04d1\u04d3\7o\2\2\u04d2\u04d1\3\2\2\2\u04d2")
        buf.write("\u04d3\3\2\2\2\u04d3\u04d4\3\2\2\2\u04d4\u04d5\5\u0094")
        buf.write("K\2\u04d5\u0089\3\2\2\2\u04d6\u04d7\5\u009aN\2\u04d7\u008b")
        buf.write("\3\2\2\2\u04d8\u04db\5\u0098M\2\u04d9\u04db\5\u0096L\2")
        buf.write("\u04da\u04d8\3\2\2\2\u04da\u04d9\3\2\2\2\u04db\u008d\3")
        buf.write("\2\2\2\u04dc\u04de\7\34\2\2\u04dd\u04df\7o\2\2\u04de\u04dd")
        buf.write("\3\2\2\2\u04de\u04df\3\2\2\2\u04df\u0501\3\2\2\2\u04e0")
        buf.write("\u04e2\5\u0094K\2\u04e1\u04e3\7o\2\2\u04e2\u04e1\3\2\2")
        buf.write("\2\u04e2\u04e3\3\2\2\2\u04e3\u04e4\3\2\2\2\u04e4\u04e6")
        buf.write("\7\f\2\2\u04e5\u04e7\7o\2\2\u04e6\u04e5\3\2\2\2\u04e6")
        buf.write("\u04e7\3\2\2\2\u04e7\u04e8\3\2\2\2\u04e8\u04ea\5V,\2\u04e9")
        buf.write("\u04eb\7o\2\2\u04ea\u04e9\3\2\2\2\u04ea\u04eb\3\2\2\2")
        buf.write("\u04eb\u04fe\3\2\2\2\u04ec\u04ee\7\4\2\2\u04ed\u04ef\7")
        buf.write("o\2\2\u04ee\u04ed\3\2\2\2\u04ee\u04ef\3\2\2\2\u04ef\u04f0")
        buf.write("\3\2\2\2\u04f0\u04f2\5\u0094K\2\u04f1\u04f3\7o\2\2\u04f2")
        buf.write("\u04f1\3\2\2\2\u04f2\u04f3\3\2\2\2\u04f3\u04f4\3\2\2\2")
        buf.write("\u04f4\u04f6\7\f\2\2\u04f5\u04f7\7o\2\2\u04f6\u04f5\3")
        buf.write("\2\2\2\u04f6\u04f7\3\2\2\2\u04f7\u04f8\3\2\2\2\u04f8\u04fa")
        buf.write("\5V,\2\u04f9\u04fb\7o\2\2\u04fa\u04f9\3\2\2\2\u04fa\u04fb")
        buf.write("\3\2\2\2\u04fb\u04fd\3\2\2\2\u04fc\u04ec\3\2\2\2\u04fd")
        buf.write("\u0500\3\2\2\2\u04fe\u04fc\3\2\2\2\u04fe\u04ff\3\2\2\2")
        buf.write("\u04ff\u0502\3\2\2\2\u0500\u04fe\3\2\2\2\u0501\u04e0\3")
        buf.write("\2\2\2\u0501\u0502\3\2\2\2\u0502\u0503\3\2\2\2\u0503\u0504")
        buf.write("\7\35\2\2\u0504\u008f\3\2\2\2\u0505\u0508\7\36\2\2\u0506")
        buf.write("\u0509\5\u009aN\2\u0507\u0509\7\65\2\2\u0508\u0506\3\2")
        buf.write("\2\2\u0508\u0507\3\2\2\2\u0509\u0091\3\2\2\2\u050a\u050f")
        buf.write("\5n8\2\u050b\u050d\7o\2\2\u050c\u050b\3\2\2\2\u050c\u050d")
        buf.write("\3\2\2\2\u050d\u050e\3\2\2\2\u050e\u0510\5\u0088E\2\u050f")
        buf.write("\u050c\3\2\2\2\u0510\u0511\3\2\2\2\u0511\u050f\3\2\2\2")
        buf.write("\u0511\u0512\3\2\2\2\u0512\u0093\3\2\2\2\u0513\u0514\5")
        buf.write("\u009aN\2\u0514\u0095\3\2\2\2\u0515\u0516\t\6\2\2\u0516")
        buf.write("\u0097\3\2\2\2\u0517\u0518\t\7\2\2\u0518\u0099\3\2\2\2")
        buf.write("\u0519\u051a\t\b\2\2\u051a\u009b\3\2\2\2\u051b\u051c\t")
        buf.write("\t\2\2\u051c\u009d\3\2\2\2\u051d\u051e\t\n\2\2\u051e\u009f")
        buf.write("\3\2\2\2\u051f\u0520\t\13\2\2\u0520\u00a1\3\2\2\2\u00f3")
        buf.write("\u00a3\u00a7\u00aa\u00ad\u00b5\u00ba\u00bf\u00c4\u00cb")
        buf.write("\u00d0\u00d3\u00de\u00e2\u00e6\u00ea\u00ed\u00f1\u00fb")
        buf.write("\u0102\u010f\u0113\u0119\u0120\u0125\u0129\u012f\u0133")
        buf.write("\u0139\u013d\u0143\u0147\u014b\u014f\u0153\u0157\u015c")
        buf.write("\u0163\u0167\u016c\u0173\u0177\u017a\u017f\u0182\u0186")
        buf.write("\u0189\u0191\u0195\u0199\u019d\u01a1\u01a6\u01ab\u01af")
        buf.write("\u01b4\u01b7\u01c0\u01c9\u01ce\u01db\u01de\u01e6\u01ea")
        buf.write("\u01ef\u01f4\u01f8\u01fd\u0203\u0208\u020f\u0213\u0217")
        buf.write("\u0219\u021d\u021f\u0223\u0225\u022b\u0231\u0235\u0238")
        buf.write("\u023b\u023f\u0245\u0249\u024c\u024f\u0255\u0258\u025b")
        buf.write("\u025f\u0265\u0268\u026b\u026f\u0273\u0277\u0279\u027d")
        buf.write("\u027f\u0282\u0286\u0288\u028e\u0292\u0296\u029a\u029d")
        buf.write("\u02a2\u02a7\u02ac\u02b1\u02b7\u02bb\u02bd\u02c1\u02c5")
        buf.write("\u02c7\u02c9\u02d8\u02e2\u02ec\u02f1\u02f5\u02fc\u0301")
        buf.write("\u0306\u030a\u030e\u0312\u0315\u0317\u031c\u0320\u0324")
        buf.write("\u0328\u032c\u0330\u0333\u0335\u033a\u033e\u0343\u0348")
        buf.write("\u034c\u0353\u035a\u035e\u0362\u0366\u0375\u0378\u0385")
        buf.write("\u0387\u038c\u0390\u0394\u039b\u039f\u03a3\u03aa\u03ae")
        buf.write("\u03b2\u03b8\u03bc\u03c0\u03c3\u03c7\u03cd\u03d1\u03d5")
        buf.write("\u03db\u03df\u03e3\u03e9\u03ed\u03f1\u03f7\u03fb\u03ff")
        buf.write("\u0407\u040f\u0415\u0419\u041d\u0421\u0425\u0428\u042e")
        buf.write("\u0433\u0438\u043d\u0442\u0447\u044c\u044f\u0453\u0457")
        buf.write("\u045d\u0462\u0466\u0469\u0473\u0477\u047b\u047d\u0481")
        buf.write("\u0485\u0489\u048d\u0490\u0498\u049c\u04a0\u04a3\u04a6")
        buf.write("\u04ac\u04b0\u04b4\u04b6\u04ba\u04be\u04c2\u04c4\u04c8")
        buf.write("\u04cc\u04d2\u04da\u04de\u04e2\u04e6\u04ea\u04ee\u04f2")
        buf.write("\u04f6\u04fa\u04fe\u0501\u0508\u050c\u0511")
        return buf.getvalue()


class CypherParser ( Parser ):

    grammarFileName = "Cypher.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "','", "'='", "'+='", "'*'", "'('", 
                     "')'", "'['", "']'", "':'", "'|'", "'..'", "'+'", "'-'", 
                     "'/'", "'%'", "'^'", "'=~'", "'<>'", "'!='", "'<'", 
                     "'>'", "'<='", "'>='", "'.'", "'{'", "'}'", "'$'", 
                     "'⟨'", "'〈'", "'﹤'", "'＜'", "'⟩'", "'〉'", "'﹥'", "'＞'", 
                     "'­'", "'‐'", "'‑'", "'‒'", "'–'", "'—'", "'―'", "'−'", 
                     "'﹘'", "'﹣'", "'－'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'0'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "StringLiteral", "EscapedChar", "HexInteger", "DecimalInteger", 
                      "OctalInteger", "HexLetter", "HexDigit", "Digit", 
                      "NonZeroDigit", "NonZeroOctDigit", "OctDigit", "ZeroDigit", 
                      "ExponentDecimalReal", "RegularDecimalReal", "UNION", 
                      "ALL", "OPTIONAL", "MATCH", "UNWIND", "AS", "MERGE", 
                      "ON", "CREATE", "SET", "DETACH", "DELETE", "REMOVE", 
                      "WITH", "DISTINCT", "RETURN", "ORDER", "BY", "L_SKIP", 
                      "LIMIT", "ASCENDING", "ASC", "DESCENDING", "DESC", 
                      "WHERE", "OR", "XOR", "AND", "NOT", "IN", "STARTS", 
                      "ENDS", "CONTAINS", "IS", "NULL", "COUNT", "FILTER", 
                      "EXTRACT", "ANY", "NONE", "SINGLE", "TRUE", "FALSE", 
                      "UnescapedSymbolicName", "IdentifierStart", "IdentifierPart", 
                      "EscapedSymbolicName", "SP", "WHITESPACE", "Comment" ]

    RULE_cypher = 0
    RULE_statement = 1
    RULE_query = 2
    RULE_regularQuery = 3
    RULE_singleQuery = 4
    RULE_union = 5
    RULE_clause = 6
    RULE_match_ = 7
    RULE_unwind = 8
    RULE_merge = 9
    RULE_mergeAction = 10
    RULE_create = 11
    RULE_set_ = 12
    RULE_setItem = 13
    RULE_delete = 14
    RULE_remove = 15
    RULE_removeItem = 16
    RULE_with_ = 17
    RULE_return_ = 18
    RULE_returnBody = 19
    RULE_returnItems = 20
    RULE_returnItem = 21
    RULE_order = 22
    RULE_skip = 23
    RULE_limit = 24
    RULE_sortItem = 25
    RULE_where = 26
    RULE_pattern = 27
    RULE_patternPart = 28
    RULE_anonymousPatternPart = 29
    RULE_patternElement = 30
    RULE_nodePattern = 31
    RULE_patternElementChain = 32
    RULE_relationshipPattern = 33
    RULE_relationshipDetail = 34
    RULE_properties = 35
    RULE_relationshipTypes = 36
    RULE_nodeLabels = 37
    RULE_nodeLabel = 38
    RULE_rangeLiteral = 39
    RULE_labelName = 40
    RULE_relTypeName = 41
    RULE_expression = 42
    RULE_expression12 = 43
    RULE_expression11 = 44
    RULE_expression10 = 45
    RULE_expression9 = 46
    RULE_expression8 = 47
    RULE_expression7 = 48
    RULE_expression6 = 49
    RULE_expression5 = 50
    RULE_expression4 = 51
    RULE_expression3 = 52
    RULE_expression2 = 53
    RULE_atom = 54
    RULE_literal = 55
    RULE_booleanLiteral = 56
    RULE_listLiteral = 57
    RULE_partialComparisonExpression = 58
    RULE_parenthesizedExpression = 59
    RULE_relationshipsPattern = 60
    RULE_filterExpression = 61
    RULE_idInColl = 62
    RULE_functionInvocation = 63
    RULE_functionName = 64
    RULE_listComprehension = 65
    RULE_patternComprehension = 66
    RULE_propertyLookup = 67
    RULE_variable = 68
    RULE_numberLiteral = 69
    RULE_mapLiteral = 70
    RULE_parameter = 71
    RULE_propertyExpression = 72
    RULE_propertyKeyName = 73
    RULE_integerLiteral = 74
    RULE_doubleLiteral = 75
    RULE_symbolicName = 76
    RULE_leftArrowHead = 77
    RULE_rightArrowHead = 78
    RULE_dash = 79

    ruleNames =  [ "cypher", "statement", "query", "regularQuery", "singleQuery", 
                   "union", "clause", "match_", "unwind", "merge", "mergeAction", 
                   "create", "set_", "setItem", "delete", "remove", "removeItem", 
                   "with_", "return_", "returnBody", "returnItems", "returnItem", 
                   "order", "skip", "limit", "sortItem", "where", "pattern", 
                   "patternPart", "anonymousPatternPart", "patternElement", 
                   "nodePattern", "patternElementChain", "relationshipPattern", 
                   "relationshipDetail", "properties", "relationshipTypes", 
                   "nodeLabels", "nodeLabel", "rangeLiteral", "labelName", 
                   "relTypeName", "expression", "expression12", "expression11", 
                   "expression10", "expression9", "expression8", "expression7", 
                   "expression6", "expression5", "expression4", "expression3", 
                   "expression2", "atom", "literal", "booleanLiteral", "listLiteral", 
                   "partialComparisonExpression", "parenthesizedExpression", 
                   "relationshipsPattern", "filterExpression", "idInColl", 
                   "functionInvocation", "functionName", "listComprehension", 
                   "patternComprehension", "propertyLookup", "variable", 
                   "numberLiteral", "mapLiteral", "parameter", "propertyExpression", 
                   "propertyKeyName", "integerLiteral", "doubleLiteral", 
                   "symbolicName", "leftArrowHead", "rightArrowHead", "dash" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    StringLiteral=48
    EscapedChar=49
    HexInteger=50
    DecimalInteger=51
    OctalInteger=52
    HexLetter=53
    HexDigit=54
    Digit=55
    NonZeroDigit=56
    NonZeroOctDigit=57
    OctDigit=58
    ZeroDigit=59
    ExponentDecimalReal=60
    RegularDecimalReal=61
    UNION=62
    ALL=63
    OPTIONAL=64
    MATCH=65
    UNWIND=66
    AS=67
    MERGE=68
    ON=69
    CREATE=70
    SET=71
    DETACH=72
    DELETE=73
    REMOVE=74
    WITH=75
    DISTINCT=76
    RETURN=77
    ORDER=78
    BY=79
    L_SKIP=80
    LIMIT=81
    ASCENDING=82
    ASC=83
    DESCENDING=84
    DESC=85
    WHERE=86
    OR=87
    XOR=88
    AND=89
    NOT=90
    IN=91
    STARTS=92
    ENDS=93
    CONTAINS=94
    IS=95
    NULL=96
    COUNT=97
    FILTER=98
    EXTRACT=99
    ANY=100
    NONE=101
    SINGLE=102
    TRUE=103
    FALSE=104
    UnescapedSymbolicName=105
    IdentifierStart=106
    IdentifierPart=107
    EscapedSymbolicName=108
    SP=109
    WHITESPACE=110
    Comment=111

    def __init__(self, input:TokenStream):
        super().__init__(input)
        self.checkVersion("4.5.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class CypherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(CypherParser.StatementContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_cypher

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCypher" ):
                listener.enterCypher(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCypher" ):
                listener.exitCypher(self)




    def cypher(self):

        localctx = CypherParser.CypherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_cypher)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 160
                self.match(CypherParser.SP)


            self.state = 163
            self.statement()
            self.state = 168
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 165
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 164
                    self.match(CypherParser.SP)


                self.state = 167
                self.match(CypherParser.T__0)


            self.state = 171
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 170
                self.match(CypherParser.SP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def query(self):
            return self.getTypedRuleContext(CypherParser.QueryContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = CypherParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.query()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def regularQuery(self):
            return self.getTypedRuleContext(CypherParser.RegularQueryContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)




    def query(self):

        localctx = CypherParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_query)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.regularQuery()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegularQueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleQuery(self):
            return self.getTypedRuleContext(CypherParser.SingleQueryContext,0)


        def union(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.UnionContext)
            else:
                return self.getTypedRuleContext(CypherParser.UnionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_regularQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegularQuery" ):
                listener.enterRegularQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegularQuery" ):
                listener.exitRegularQuery(self)




    def regularQuery(self):

        localctx = CypherParser.RegularQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_regularQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.singleQuery()
            self.state = 184
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 179
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 178
                        self.match(CypherParser.SP)


                    self.state = 181
                    self.union() 
                self.state = 186
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SingleQueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ClauseContext)
            else:
                return self.getTypedRuleContext(CypherParser.ClauseContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_singleQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleQuery" ):
                listener.enterSingleQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleQuery" ):
                listener.exitSingleQuery(self)




    def singleQuery(self):

        localctx = CypherParser.SingleQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_singleQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.clause()
            self.state = 194
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,7,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 189
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 188
                        self.match(CypherParser.SP)


                    self.state = 191
                    self.clause() 
                self.state = 196
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,7,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION(self):
            return self.getToken(CypherParser.UNION, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def singleQuery(self):
            return self.getTypedRuleContext(CypherParser.SingleQueryContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_union

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnion" ):
                listener.enterUnion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnion" ):
                listener.exitUnion(self)




    def union(self):

        localctx = CypherParser.UnionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_union)
        self._la = 0 # Token type
        try:
            self.state = 209
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 197
                self.match(CypherParser.UNION)
                self.state = 198
                self.match(CypherParser.SP)
                self.state = 199
                self.match(CypherParser.ALL)
                self.state = 201
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 200
                    self.match(CypherParser.SP)


                self.state = 203
                self.singleQuery()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 204
                self.match(CypherParser.UNION)
                self.state = 206
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 205
                    self.match(CypherParser.SP)


                self.state = 208
                self.singleQuery()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def match_(self):
            return self.getTypedRuleContext(CypherParser.Match_Context,0)


        def unwind(self):
            return self.getTypedRuleContext(CypherParser.UnwindContext,0)


        def merge(self):
            return self.getTypedRuleContext(CypherParser.MergeContext,0)


        def create(self):
            return self.getTypedRuleContext(CypherParser.CreateContext,0)


        def set_(self):
            return self.getTypedRuleContext(CypherParser.Set_Context,0)


        def delete(self):
            return self.getTypedRuleContext(CypherParser.DeleteContext,0)


        def remove(self):
            return self.getTypedRuleContext(CypherParser.RemoveContext,0)


        def with_(self):
            return self.getTypedRuleContext(CypherParser.With_Context,0)


        def return_(self):
            return self.getTypedRuleContext(CypherParser.Return_Context,0)


        def getRuleIndex(self):
            return CypherParser.RULE_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClause" ):
                listener.enterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClause" ):
                listener.exitClause(self)




    def clause(self):

        localctx = CypherParser.ClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_clause)
        try:
            self.state = 220
            token = self._input.LA(1)
            if token in [CypherParser.OPTIONAL, CypherParser.MATCH]:
                self.enterOuterAlt(localctx, 1)
                self.state = 211
                self.match_()

            elif token in [CypherParser.UNWIND]:
                self.enterOuterAlt(localctx, 2)
                self.state = 212
                self.unwind()

            elif token in [CypherParser.MERGE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 213
                self.merge()

            elif token in [CypherParser.CREATE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 214
                self.create()

            elif token in [CypherParser.SET]:
                self.enterOuterAlt(localctx, 5)
                self.state = 215
                self.set_()

            elif token in [CypherParser.DETACH, CypherParser.DELETE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 216
                self.delete()

            elif token in [CypherParser.REMOVE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 217
                self.remove()

            elif token in [CypherParser.WITH]:
                self.enterOuterAlt(localctx, 8)
                self.state = 218
                self.with_()

            elif token in [CypherParser.RETURN]:
                self.enterOuterAlt(localctx, 9)
                self.state = 219
                self.return_()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Match_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def pattern(self):
            return self.getTypedRuleContext(CypherParser.PatternContext,0)


        def OPTIONAL(self):
            return self.getToken(CypherParser.OPTIONAL, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_match_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatch_" ):
                listener.enterMatch_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatch_" ):
                listener.exitMatch_(self)




    def match_(self):

        localctx = CypherParser.Match_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_match_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            _la = self._input.LA(1)
            if _la==CypherParser.OPTIONAL:
                self.state = 222
                self.match(CypherParser.OPTIONAL)
                self.state = 223
                self.match(CypherParser.SP)


            self.state = 226
            self.match(CypherParser.MATCH)
            self.state = 228
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 227
                self.match(CypherParser.SP)


            self.state = 230
            self.pattern()
            self.state = 235
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 232
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 231
                    self.match(CypherParser.SP)


                self.state = 234
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnwindContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNWIND(self):
            return self.getToken(CypherParser.UNWIND, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_unwind

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnwind" ):
                listener.enterUnwind(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnwind" ):
                listener.exitUnwind(self)




    def unwind(self):

        localctx = CypherParser.UnwindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unwind)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 237
            self.match(CypherParser.UNWIND)
            self.state = 239
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 238
                self.match(CypherParser.SP)


            self.state = 241
            self.expression()
            self.state = 242
            self.match(CypherParser.SP)
            self.state = 243
            self.match(CypherParser.AS)
            self.state = 244
            self.match(CypherParser.SP)
            self.state = 245
            self.variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MergeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MERGE(self):
            return self.getToken(CypherParser.MERGE, 0)

        def patternPart(self):
            return self.getTypedRuleContext(CypherParser.PatternPartContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def mergeAction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.MergeActionContext)
            else:
                return self.getTypedRuleContext(CypherParser.MergeActionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_merge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge" ):
                listener.enterMerge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge" ):
                listener.exitMerge(self)




    def merge(self):

        localctx = CypherParser.MergeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_merge)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            self.match(CypherParser.MERGE)
            self.state = 249
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 248
                self.match(CypherParser.SP)


            self.state = 251
            self.patternPart()
            self.state = 256
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,18,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 252
                    self.match(CypherParser.SP)
                    self.state = 253
                    self.mergeAction() 
                self.state = 258
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,18,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MergeActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(CypherParser.ON, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def set_(self):
            return self.getTypedRuleContext(CypherParser.Set_Context,0)


        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_mergeAction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMergeAction" ):
                listener.enterMergeAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMergeAction" ):
                listener.exitMergeAction(self)




    def mergeAction(self):

        localctx = CypherParser.MergeActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_mergeAction)
        try:
            self.state = 269
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 259
                self.match(CypherParser.ON)
                self.state = 260
                self.match(CypherParser.SP)
                self.state = 261
                self.match(CypherParser.MATCH)
                self.state = 262
                self.match(CypherParser.SP)
                self.state = 263
                self.set_()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 264
                self.match(CypherParser.ON)
                self.state = 265
                self.match(CypherParser.SP)
                self.state = 266
                self.match(CypherParser.CREATE)
                self.state = 267
                self.match(CypherParser.SP)
                self.state = 268
                self.set_()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CreateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def pattern(self):
            return self.getTypedRuleContext(CypherParser.PatternContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_create

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate" ):
                listener.enterCreate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate" ):
                listener.exitCreate(self)




    def create(self):

        localctx = CypherParser.CreateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_create)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(CypherParser.CREATE)
            self.state = 273
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 272
                self.match(CypherParser.SP)


            self.state = 275
            self.pattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Set_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(CypherParser.SET, 0)

        def setItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.SetItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.SetItemContext,i)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_set_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_" ):
                listener.enterSet_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_" ):
                listener.exitSet_(self)




    def set_(self):

        localctx = CypherParser.Set_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_set_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 277
            self.match(CypherParser.SET)
            self.state = 279
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 278
                self.match(CypherParser.SP)


            self.state = 281
            self.setItem()
            self.state = 286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CypherParser.T__1:
                self.state = 282
                self.match(CypherParser.T__1)
                self.state = 283
                self.setItem()
                self.state = 288
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SetItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyExpressionContext,0)


        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_setItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetItem" ):
                listener.enterSetItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetItem" ):
                listener.exitSetItem(self)




    def setItem(self):

        localctx = CypherParser.SetItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_setItem)
        self._la = 0 # Token type
        try:
            self.state = 325
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 289
                self.propertyExpression()
                self.state = 291
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 290
                    self.match(CypherParser.SP)


                self.state = 293
                self.match(CypherParser.T__2)
                self.state = 295
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 294
                    self.match(CypherParser.SP)


                self.state = 297
                self.expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 299
                self.variable()
                self.state = 301
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 300
                    self.match(CypherParser.SP)


                self.state = 303
                self.match(CypherParser.T__2)
                self.state = 305
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 304
                    self.match(CypherParser.SP)


                self.state = 307
                self.expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 309
                self.variable()
                self.state = 311
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 310
                    self.match(CypherParser.SP)


                self.state = 313
                self.match(CypherParser.T__3)
                self.state = 315
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 314
                    self.match(CypherParser.SP)


                self.state = 317
                self.expression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 319
                self.variable()
                self.state = 321
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 320
                    self.match(CypherParser.SP)


                self.state = 323
                self.nodeLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeleteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(CypherParser.DELETE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def DETACH(self):
            return self.getToken(CypherParser.DETACH, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_delete

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete" ):
                listener.enterDelete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete" ):
                listener.exitDelete(self)




    def delete(self):

        localctx = CypherParser.DeleteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_delete)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            _la = self._input.LA(1)
            if _la==CypherParser.DETACH:
                self.state = 327
                self.match(CypherParser.DETACH)
                self.state = 328
                self.match(CypherParser.SP)


            self.state = 331
            self.match(CypherParser.DELETE)
            self.state = 333
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 332
                self.match(CypherParser.SP)


            self.state = 335
            self.expression()
            self.state = 346
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 337
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 336
                        self.match(CypherParser.SP)


                    self.state = 339
                    self.match(CypherParser.T__1)
                    self.state = 341
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 340
                        self.match(CypherParser.SP)


                    self.state = 343
                    self.expression() 
                self.state = 348
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RemoveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REMOVE(self):
            return self.getToken(CypherParser.REMOVE, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def removeItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.RemoveItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.RemoveItemContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_remove

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemove" ):
                listener.enterRemove(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemove" ):
                listener.exitRemove(self)




    def remove(self):

        localctx = CypherParser.RemoveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_remove)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self.match(CypherParser.REMOVE)
            self.state = 350
            self.match(CypherParser.SP)
            self.state = 351
            self.removeItem()
            self.state = 362
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 353
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 352
                        self.match(CypherParser.SP)


                    self.state = 355
                    self.match(CypherParser.T__1)
                    self.state = 357
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 356
                        self.match(CypherParser.SP)


                    self.state = 359
                    self.removeItem() 
                self.state = 364
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RemoveItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def propertyExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_removeItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemoveItem" ):
                listener.enterRemoveItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemoveItem" ):
                listener.exitRemoveItem(self)




    def removeItem(self):

        localctx = CypherParser.RemoveItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_removeItem)
        try:
            self.state = 369
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 365
                self.variable()
                self.state = 366
                self.nodeLabels()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 368
                self.propertyExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class With_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(CypherParser.WITH, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def returnBody(self):
            return self.getTypedRuleContext(CypherParser.ReturnBodyContext,0)


        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_with_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWith_" ):
                listener.enterWith_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWith_" ):
                listener.exitWith_(self)




    def with_(self):

        localctx = CypherParser.With_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_with_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 371
            self.match(CypherParser.WITH)
            self.state = 376
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
            if la_ == 1:
                self.state = 373
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 372
                    self.match(CypherParser.SP)


                self.state = 375
                self.match(CypherParser.DISTINCT)


            self.state = 378
            self.match(CypherParser.SP)
            self.state = 379
            self.returnBody()
            self.state = 384
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.state = 381
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 380
                    self.match(CypherParser.SP)


                self.state = 383
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Return_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(CypherParser.RETURN, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def returnBody(self):
            return self.getTypedRuleContext(CypherParser.ReturnBodyContext,0)


        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_return_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturn_" ):
                listener.enterReturn_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturn_" ):
                listener.exitReturn_(self)




    def return_(self):

        localctx = CypherParser.Return_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_return_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 386
            self.match(CypherParser.RETURN)
            self.state = 391
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.state = 388
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 387
                    self.match(CypherParser.SP)


                self.state = 390
                self.match(CypherParser.DISTINCT)


            self.state = 393
            self.match(CypherParser.SP)
            self.state = 394
            self.returnBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def returnItems(self):
            return self.getTypedRuleContext(CypherParser.ReturnItemsContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def order(self):
            return self.getTypedRuleContext(CypherParser.OrderContext,0)


        def skip(self):
            return self.getTypedRuleContext(CypherParser.SkipContext,0)


        def limit(self):
            return self.getTypedRuleContext(CypherParser.LimitContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_returnBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnBody" ):
                listener.enterReturnBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnBody" ):
                listener.exitReturnBody(self)




    def returnBody(self):

        localctx = CypherParser.ReturnBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_returnBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 396
            self.returnItems()
            self.state = 399
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 397
                self.match(CypherParser.SP)
                self.state = 398
                self.order()


            self.state = 403
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
            if la_ == 1:
                self.state = 401
                self.match(CypherParser.SP)
                self.state = 402
                self.skip()


            self.state = 407
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 405
                self.match(CypherParser.SP)
                self.state = 406
                self.limit()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnItemsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def returnItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ReturnItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.ReturnItemContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_returnItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnItems" ):
                listener.enterReturnItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnItems" ):
                listener.exitReturnItems(self)




    def returnItems(self):

        localctx = CypherParser.ReturnItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_returnItems)
        self._la = 0 # Token type
        try:
            self.state = 437
            token = self._input.LA(1)
            if token in [CypherParser.T__4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 409
                self.match(CypherParser.T__4)
                self.state = 420
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,51,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 411
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 410
                            self.match(CypherParser.SP)


                        self.state = 413
                        self.match(CypherParser.T__1)
                        self.state = 415
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 414
                            self.match(CypherParser.SP)


                        self.state = 417
                        self.returnItem() 
                    self.state = 422
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,51,self._ctx)


            elif token in [CypherParser.T__5, CypherParser.T__7, CypherParser.T__12, CypherParser.T__13, CypherParser.T__25, CypherParser.T__27, CypherParser.StringLiteral, CypherParser.HexInteger, CypherParser.DecimalInteger, CypherParser.OctalInteger, CypherParser.HexLetter, CypherParser.ExponentDecimalReal, CypherParser.RegularDecimalReal, CypherParser.UNION, CypherParser.ALL, CypherParser.OPTIONAL, CypherParser.MATCH, CypherParser.UNWIND, CypherParser.AS, CypherParser.MERGE, CypherParser.ON, CypherParser.CREATE, CypherParser.SET, CypherParser.DETACH, CypherParser.DELETE, CypherParser.REMOVE, CypherParser.WITH, CypherParser.DISTINCT, CypherParser.RETURN, CypherParser.ORDER, CypherParser.BY, CypherParser.L_SKIP, CypherParser.LIMIT, CypherParser.ASCENDING, CypherParser.ASC, CypherParser.DESCENDING, CypherParser.DESC, CypherParser.WHERE, CypherParser.OR, CypherParser.XOR, CypherParser.AND, CypherParser.NOT, CypherParser.IN, CypherParser.STARTS, CypherParser.ENDS, CypherParser.CONTAINS, CypherParser.IS, CypherParser.NULL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.TRUE, CypherParser.FALSE, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.enterOuterAlt(localctx, 2)
                self.state = 423
                self.returnItem()
                self.state = 434
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,54,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 425
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 424
                            self.match(CypherParser.SP)


                        self.state = 427
                        self.match(CypherParser.T__1)
                        self.state = 429
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 428
                            self.match(CypherParser.SP)


                        self.state = 431
                        self.returnItem() 
                    self.state = 436
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,54,self._ctx)


            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_returnItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnItem" ):
                listener.enterReturnItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnItem" ):
                listener.exitReturnItem(self)




    def returnItem(self):

        localctx = CypherParser.ReturnItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_returnItem)
        try:
            self.state = 446
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 439
                self.expression()
                self.state = 440
                self.match(CypherParser.SP)
                self.state = 441
                self.match(CypherParser.AS)
                self.state = 442
                self.match(CypherParser.SP)
                self.state = 443
                self.variable()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 445
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(CypherParser.ORDER, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def BY(self):
            return self.getToken(CypherParser.BY, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.SortItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.SortItemContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)




    def order(self):

        localctx = CypherParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 448
            self.match(CypherParser.ORDER)
            self.state = 449
            self.match(CypherParser.SP)
            self.state = 450
            self.match(CypherParser.BY)
            self.state = 451
            self.match(CypherParser.SP)
            self.state = 452
            self.sortItem()
            self.state = 460
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CypherParser.T__1:
                self.state = 453
                self.match(CypherParser.T__1)
                self.state = 455
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 454
                    self.match(CypherParser.SP)


                self.state = 457
                self.sortItem()
                self.state = 462
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SkipContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_SKIP(self):
            return self.getToken(CypherParser.L_SKIP, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_skip

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkip" ):
                listener.enterSkip(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkip" ):
                listener.exitSkip(self)




    def skip(self):

        localctx = CypherParser.SkipContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_skip)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            self.match(CypherParser.L_SKIP)
            self.state = 464
            self.match(CypherParser.SP)
            self.state = 465
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LimitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT(self):
            return self.getToken(CypherParser.LIMIT, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_limit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimit" ):
                listener.enterLimit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimit" ):
                listener.exitLimit(self)




    def limit(self):

        localctx = CypherParser.LimitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_limit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 467
            self.match(CypherParser.LIMIT)
            self.state = 468
            self.match(CypherParser.SP)
            self.state = 469
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SortItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def ASCENDING(self):
            return self.getToken(CypherParser.ASCENDING, 0)

        def ASC(self):
            return self.getToken(CypherParser.ASC, 0)

        def DESCENDING(self):
            return self.getToken(CypherParser.DESCENDING, 0)

        def DESC(self):
            return self.getToken(CypherParser.DESC, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_sortItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortItem" ):
                listener.enterSortItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortItem" ):
                listener.exitSortItem(self)




    def sortItem(self):

        localctx = CypherParser.SortItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_sortItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.expression()
            self.state = 476
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                self.state = 473
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 472
                    self.match(CypherParser.SP)


                self.state = 475
                _la = self._input.LA(1)
                if not(((((_la - 82)) & ~0x3f) == 0 and ((1 << (_la - 82)) & ((1 << (CypherParser.ASCENDING - 82)) | (1 << (CypherParser.ASC - 82)) | (1 << (CypherParser.DESCENDING - 82)) | (1 << (CypherParser.DESC - 82)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhereContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_where

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere" ):
                listener.enterWhere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere" ):
                listener.exitWhere(self)




    def where(self):

        localctx = CypherParser.WhereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_where)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 478
            self.match(CypherParser.WHERE)
            self.state = 479
            self.match(CypherParser.SP)
            self.state = 480
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patternPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternPartContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternPartContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)




    def pattern(self):

        localctx = CypherParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 482
            self.patternPart()
            self.state = 493
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,63,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 484
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 483
                        self.match(CypherParser.SP)


                    self.state = 486
                    self.match(CypherParser.T__1)
                    self.state = 488
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 487
                        self.match(CypherParser.SP)


                    self.state = 490
                    self.patternPart() 
                self.state = 495
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,63,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternPartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def anonymousPatternPart(self):
            return self.getTypedRuleContext(CypherParser.AnonymousPatternPartContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_patternPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternPart" ):
                listener.enterPatternPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternPart" ):
                listener.exitPatternPart(self)




    def patternPart(self):

        localctx = CypherParser.PatternPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_patternPart)
        self._la = 0 # Token type
        try:
            self.state = 507
            token = self._input.LA(1)
            if token in [CypherParser.HexLetter, CypherParser.UNION, CypherParser.ALL, CypherParser.OPTIONAL, CypherParser.MATCH, CypherParser.UNWIND, CypherParser.AS, CypherParser.MERGE, CypherParser.ON, CypherParser.CREATE, CypherParser.SET, CypherParser.DETACH, CypherParser.DELETE, CypherParser.REMOVE, CypherParser.WITH, CypherParser.DISTINCT, CypherParser.RETURN, CypherParser.ORDER, CypherParser.BY, CypherParser.L_SKIP, CypherParser.LIMIT, CypherParser.ASCENDING, CypherParser.ASC, CypherParser.DESCENDING, CypherParser.DESC, CypherParser.WHERE, CypherParser.OR, CypherParser.XOR, CypherParser.AND, CypherParser.NOT, CypherParser.IN, CypherParser.STARTS, CypherParser.ENDS, CypherParser.CONTAINS, CypherParser.IS, CypherParser.NULL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.TRUE, CypherParser.FALSE, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.enterOuterAlt(localctx, 1)
                self.state = 496
                self.variable()
                self.state = 498
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 497
                    self.match(CypherParser.SP)


                self.state = 500
                self.match(CypherParser.T__2)
                self.state = 502
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 501
                    self.match(CypherParser.SP)


                self.state = 504
                self.anonymousPatternPart()

            elif token in [CypherParser.T__5]:
                self.enterOuterAlt(localctx, 2)
                self.state = 506
                self.anonymousPatternPart()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnonymousPatternPartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patternElement(self):
            return self.getTypedRuleContext(CypherParser.PatternElementContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_anonymousPatternPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnonymousPatternPart" ):
                listener.enterAnonymousPatternPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnonymousPatternPart" ):
                listener.exitAnonymousPatternPart(self)




    def anonymousPatternPart(self):

        localctx = CypherParser.AnonymousPatternPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_anonymousPatternPart)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 509
            self.patternElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternElementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def patternElementChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternElementChainContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternElementChainContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def patternElement(self):
            return self.getTypedRuleContext(CypherParser.PatternElementContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_patternElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternElement" ):
                listener.enterPatternElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternElement" ):
                listener.exitPatternElement(self)




    def patternElement(self):

        localctx = CypherParser.PatternElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_patternElement)
        self._la = 0 # Token type
        try:
            self.state = 525
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 511
                self.nodePattern()
                self.state = 518
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,68,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 513
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 512
                            self.match(CypherParser.SP)


                        self.state = 515
                        self.patternElementChain() 
                    self.state = 520
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,68,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 521
                self.match(CypherParser.T__5)
                self.state = 522
                self.patternElement()
                self.state = 523
                self.match(CypherParser.T__6)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NodePatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def properties(self):
            return self.getTypedRuleContext(CypherParser.PropertiesContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_nodePattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodePattern" ):
                listener.enterNodePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodePattern" ):
                listener.exitNodePattern(self)




    def nodePattern(self):

        localctx = CypherParser.NodePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_nodePattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 527
            self.match(CypherParser.T__5)
            self.state = 529
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 528
                self.match(CypherParser.SP)


            self.state = 535
            _la = self._input.LA(1)
            if ((((_la - 53)) & ~0x3f) == 0 and ((1 << (_la - 53)) & ((1 << (CypherParser.HexLetter - 53)) | (1 << (CypherParser.UNION - 53)) | (1 << (CypherParser.ALL - 53)) | (1 << (CypherParser.OPTIONAL - 53)) | (1 << (CypherParser.MATCH - 53)) | (1 << (CypherParser.UNWIND - 53)) | (1 << (CypherParser.AS - 53)) | (1 << (CypherParser.MERGE - 53)) | (1 << (CypherParser.ON - 53)) | (1 << (CypherParser.CREATE - 53)) | (1 << (CypherParser.SET - 53)) | (1 << (CypherParser.DETACH - 53)) | (1 << (CypherParser.DELETE - 53)) | (1 << (CypherParser.REMOVE - 53)) | (1 << (CypherParser.WITH - 53)) | (1 << (CypherParser.DISTINCT - 53)) | (1 << (CypherParser.RETURN - 53)) | (1 << (CypherParser.ORDER - 53)) | (1 << (CypherParser.BY - 53)) | (1 << (CypherParser.L_SKIP - 53)) | (1 << (CypherParser.LIMIT - 53)) | (1 << (CypherParser.ASCENDING - 53)) | (1 << (CypherParser.ASC - 53)) | (1 << (CypherParser.DESCENDING - 53)) | (1 << (CypherParser.DESC - 53)) | (1 << (CypherParser.WHERE - 53)) | (1 << (CypherParser.OR - 53)) | (1 << (CypherParser.XOR - 53)) | (1 << (CypherParser.AND - 53)) | (1 << (CypherParser.NOT - 53)) | (1 << (CypherParser.IN - 53)) | (1 << (CypherParser.STARTS - 53)) | (1 << (CypherParser.ENDS - 53)) | (1 << (CypherParser.CONTAINS - 53)) | (1 << (CypherParser.IS - 53)) | (1 << (CypherParser.NULL - 53)) | (1 << (CypherParser.COUNT - 53)) | (1 << (CypherParser.FILTER - 53)) | (1 << (CypherParser.EXTRACT - 53)) | (1 << (CypherParser.ANY - 53)) | (1 << (CypherParser.NONE - 53)) | (1 << (CypherParser.SINGLE - 53)) | (1 << (CypherParser.TRUE - 53)) | (1 << (CypherParser.FALSE - 53)) | (1 << (CypherParser.UnescapedSymbolicName - 53)) | (1 << (CypherParser.EscapedSymbolicName - 53)))) != 0):
                self.state = 531
                self.variable()
                self.state = 533
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 532
                    self.match(CypherParser.SP)




            self.state = 541
            _la = self._input.LA(1)
            if _la==CypherParser.T__9:
                self.state = 537
                self.nodeLabels()
                self.state = 539
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 538
                    self.match(CypherParser.SP)




            self.state = 547
            _la = self._input.LA(1)
            if _la==CypherParser.T__25 or _la==CypherParser.T__27:
                self.state = 543
                self.properties()
                self.state = 545
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 544
                    self.match(CypherParser.SP)




            self.state = 549
            self.match(CypherParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternElementChainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationshipPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipPatternContext,0)


        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_patternElementChain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternElementChain" ):
                listener.enterPatternElementChain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternElementChain" ):
                listener.exitPatternElementChain(self)




    def patternElementChain(self):

        localctx = CypherParser.PatternElementChainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_patternElementChain)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.relationshipPattern()
            self.state = 553
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 552
                self.match(CypherParser.SP)


            self.state = 555
            self.nodePattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipPatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def leftArrowHead(self):
            return self.getTypedRuleContext(CypherParser.LeftArrowHeadContext,0)


        def dash(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.DashContext)
            else:
                return self.getTypedRuleContext(CypherParser.DashContext,i)


        def rightArrowHead(self):
            return self.getTypedRuleContext(CypherParser.RightArrowHeadContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def relationshipDetail(self):
            return self.getTypedRuleContext(CypherParser.RelationshipDetailContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_relationshipPattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipPattern" ):
                listener.enterRelationshipPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipPattern" ):
                listener.exitRelationshipPattern(self)




    def relationshipPattern(self):

        localctx = CypherParser.RelationshipPatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_relationshipPattern)
        self._la = 0 # Token type
        try:
            self.state = 621
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 557
                self.leftArrowHead()
                self.state = 559
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 558
                    self.match(CypherParser.SP)


                self.state = 561
                self.dash()
                self.state = 563
                self._errHandler.sync(self);
                la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                if la_ == 1:
                    self.state = 562
                    self.match(CypherParser.SP)


                self.state = 566
                _la = self._input.LA(1)
                if _la==CypherParser.T__7:
                    self.state = 565
                    self.relationshipDetail()


                self.state = 569
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 568
                    self.match(CypherParser.SP)


                self.state = 571
                self.dash()
                self.state = 573
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 572
                    self.match(CypherParser.SP)


                self.state = 575
                self.rightArrowHead()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 577
                self.leftArrowHead()
                self.state = 579
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 578
                    self.match(CypherParser.SP)


                self.state = 581
                self.dash()
                self.state = 583
                self._errHandler.sync(self);
                la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                if la_ == 1:
                    self.state = 582
                    self.match(CypherParser.SP)


                self.state = 586
                _la = self._input.LA(1)
                if _la==CypherParser.T__7:
                    self.state = 585
                    self.relationshipDetail()


                self.state = 589
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 588
                    self.match(CypherParser.SP)


                self.state = 591
                self.dash()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 593
                self.dash()
                self.state = 595
                self._errHandler.sync(self);
                la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                if la_ == 1:
                    self.state = 594
                    self.match(CypherParser.SP)


                self.state = 598
                _la = self._input.LA(1)
                if _la==CypherParser.T__7:
                    self.state = 597
                    self.relationshipDetail()


                self.state = 601
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 600
                    self.match(CypherParser.SP)


                self.state = 603
                self.dash()
                self.state = 605
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 604
                    self.match(CypherParser.SP)


                self.state = 607
                self.rightArrowHead()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 609
                self.dash()
                self.state = 611
                self._errHandler.sync(self);
                la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                if la_ == 1:
                    self.state = 610
                    self.match(CypherParser.SP)


                self.state = 614
                _la = self._input.LA(1)
                if _la==CypherParser.T__7:
                    self.state = 613
                    self.relationshipDetail()


                self.state = 617
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 616
                    self.match(CypherParser.SP)


                self.state = 619
                self.dash()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipDetailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def relationshipTypes(self):
            return self.getTypedRuleContext(CypherParser.RelationshipTypesContext,0)


        def rangeLiteral(self):
            return self.getTypedRuleContext(CypherParser.RangeLiteralContext,0)


        def properties(self):
            return self.getTypedRuleContext(CypherParser.PropertiesContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_relationshipDetail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipDetail" ):
                listener.enterRelationshipDetail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipDetail" ):
                listener.exitRelationshipDetail(self)




    def relationshipDetail(self):

        localctx = CypherParser.RelationshipDetailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_relationshipDetail)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 623
            self.match(CypherParser.T__7)
            self.state = 625
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 624
                self.match(CypherParser.SP)


            self.state = 631
            _la = self._input.LA(1)
            if ((((_la - 53)) & ~0x3f) == 0 and ((1 << (_la - 53)) & ((1 << (CypherParser.HexLetter - 53)) | (1 << (CypherParser.UNION - 53)) | (1 << (CypherParser.ALL - 53)) | (1 << (CypherParser.OPTIONAL - 53)) | (1 << (CypherParser.MATCH - 53)) | (1 << (CypherParser.UNWIND - 53)) | (1 << (CypherParser.AS - 53)) | (1 << (CypherParser.MERGE - 53)) | (1 << (CypherParser.ON - 53)) | (1 << (CypherParser.CREATE - 53)) | (1 << (CypherParser.SET - 53)) | (1 << (CypherParser.DETACH - 53)) | (1 << (CypherParser.DELETE - 53)) | (1 << (CypherParser.REMOVE - 53)) | (1 << (CypherParser.WITH - 53)) | (1 << (CypherParser.DISTINCT - 53)) | (1 << (CypherParser.RETURN - 53)) | (1 << (CypherParser.ORDER - 53)) | (1 << (CypherParser.BY - 53)) | (1 << (CypherParser.L_SKIP - 53)) | (1 << (CypherParser.LIMIT - 53)) | (1 << (CypherParser.ASCENDING - 53)) | (1 << (CypherParser.ASC - 53)) | (1 << (CypherParser.DESCENDING - 53)) | (1 << (CypherParser.DESC - 53)) | (1 << (CypherParser.WHERE - 53)) | (1 << (CypherParser.OR - 53)) | (1 << (CypherParser.XOR - 53)) | (1 << (CypherParser.AND - 53)) | (1 << (CypherParser.NOT - 53)) | (1 << (CypherParser.IN - 53)) | (1 << (CypherParser.STARTS - 53)) | (1 << (CypherParser.ENDS - 53)) | (1 << (CypherParser.CONTAINS - 53)) | (1 << (CypherParser.IS - 53)) | (1 << (CypherParser.NULL - 53)) | (1 << (CypherParser.COUNT - 53)) | (1 << (CypherParser.FILTER - 53)) | (1 << (CypherParser.EXTRACT - 53)) | (1 << (CypherParser.ANY - 53)) | (1 << (CypherParser.NONE - 53)) | (1 << (CypherParser.SINGLE - 53)) | (1 << (CypherParser.TRUE - 53)) | (1 << (CypherParser.FALSE - 53)) | (1 << (CypherParser.UnescapedSymbolicName - 53)) | (1 << (CypherParser.EscapedSymbolicName - 53)))) != 0):
                self.state = 627
                self.variable()
                self.state = 629
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 628
                    self.match(CypherParser.SP)




            self.state = 637
            _la = self._input.LA(1)
            if _la==CypherParser.T__9:
                self.state = 633
                self.relationshipTypes()
                self.state = 635
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 634
                    self.match(CypherParser.SP)




            self.state = 640
            _la = self._input.LA(1)
            if _la==CypherParser.T__4:
                self.state = 639
                self.rangeLiteral()


            self.state = 646
            _la = self._input.LA(1)
            if _la==CypherParser.T__25 or _la==CypherParser.T__27:
                self.state = 642
                self.properties()
                self.state = 644
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 643
                    self.match(CypherParser.SP)




            self.state = 648
            self.match(CypherParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertiesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mapLiteral(self):
            return self.getTypedRuleContext(CypherParser.MapLiteralContext,0)


        def parameter(self):
            return self.getTypedRuleContext(CypherParser.ParameterContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_properties

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProperties" ):
                listener.enterProperties(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProperties" ):
                listener.exitProperties(self)




    def properties(self):

        localctx = CypherParser.PropertiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_properties)
        try:
            self.state = 652
            token = self._input.LA(1)
            if token in [CypherParser.T__25]:
                self.enterOuterAlt(localctx, 1)
                self.state = 650
                self.mapLiteral()

            elif token in [CypherParser.T__27]:
                self.enterOuterAlt(localctx, 2)
                self.state = 651
                self.parameter()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipTypesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relTypeName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.RelTypeNameContext)
            else:
                return self.getTypedRuleContext(CypherParser.RelTypeNameContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_relationshipTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipTypes" ):
                listener.enterRelationshipTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipTypes" ):
                listener.exitRelationshipTypes(self)




    def relationshipTypes(self):

        localctx = CypherParser.RelationshipTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_relationshipTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 654
            self.match(CypherParser.T__9)
            self.state = 656
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 655
                self.match(CypherParser.SP)


            self.state = 658
            self.relTypeName()
            self.state = 672
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,108,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 660
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 659
                        self.match(CypherParser.SP)


                    self.state = 662
                    self.match(CypherParser.T__10)
                    self.state = 664
                    _la = self._input.LA(1)
                    if _la==CypherParser.T__9:
                        self.state = 663
                        self.match(CypherParser.T__9)


                    self.state = 667
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 666
                        self.match(CypherParser.SP)


                    self.state = 669
                    self.relTypeName() 
                self.state = 674
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,108,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NodeLabelsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodeLabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NodeLabelContext)
            else:
                return self.getTypedRuleContext(CypherParser.NodeLabelContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_nodeLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeLabels" ):
                listener.enterNodeLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeLabels" ):
                listener.exitNodeLabels(self)




    def nodeLabels(self):

        localctx = CypherParser.NodeLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_nodeLabels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 675
            self.nodeLabel()
            self.state = 682
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,110,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 677
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 676
                        self.match(CypherParser.SP)


                    self.state = 679
                    self.nodeLabel() 
                self.state = 684
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,110,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NodeLabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelName(self):
            return self.getTypedRuleContext(CypherParser.LabelNameContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_nodeLabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeLabel" ):
                listener.enterNodeLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeLabel" ):
                listener.exitNodeLabel(self)




    def nodeLabel(self):

        localctx = CypherParser.NodeLabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_nodeLabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 685
            self.match(CypherParser.T__9)
            self.state = 687
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 686
                self.match(CypherParser.SP)


            self.state = 689
            self.labelName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RangeLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def integerLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.IntegerLiteralContext)
            else:
                return self.getTypedRuleContext(CypherParser.IntegerLiteralContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_rangeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangeLiteral" ):
                listener.enterRangeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangeLiteral" ):
                listener.exitRangeLiteral(self)




    def rangeLiteral(self):

        localctx = CypherParser.RangeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_rangeLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 691
            self.match(CypherParser.T__4)
            self.state = 693
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 692
                self.match(CypherParser.SP)


            self.state = 699
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.HexInteger) | (1 << CypherParser.DecimalInteger) | (1 << CypherParser.OctalInteger))) != 0):
                self.state = 695
                self.integerLiteral()
                self.state = 697
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 696
                    self.match(CypherParser.SP)




            self.state = 711
            _la = self._input.LA(1)
            if _la==CypherParser.T__11:
                self.state = 701
                self.match(CypherParser.T__11)
                self.state = 703
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 702
                    self.match(CypherParser.SP)


                self.state = 709
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.HexInteger) | (1 << CypherParser.DecimalInteger) | (1 << CypherParser.OctalInteger))) != 0):
                    self.state = 705
                    self.integerLiteral()
                    self.state = 707
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 706
                        self.match(CypherParser.SP)






        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LabelNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_labelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelName" ):
                listener.enterLabelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelName" ):
                listener.exitLabelName(self)




    def labelName(self):

        localctx = CypherParser.LabelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_labelName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 713
            self.symbolicName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelTypeNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_relTypeName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelTypeName" ):
                listener.enterRelTypeName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelTypeName" ):
                listener.exitRelTypeName(self)




    def relTypeName(self):

        localctx = CypherParser.RelTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_relTypeName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 715
            self.symbolicName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression12(self):
            return self.getTypedRuleContext(CypherParser.Expression12Context,0)


        def getRuleIndex(self):
            return CypherParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)




    def expression(self):

        localctx = CypherParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 717
            self.expression12()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression12Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression11(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.Expression11Context)
            else:
                return self.getTypedRuleContext(CypherParser.Expression11Context,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.OR)
            else:
                return self.getToken(CypherParser.OR, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression12

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression12" ):
                listener.enterExpression12(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression12" ):
                listener.exitExpression12(self)




    def expression12(self):

        localctx = CypherParser.Expression12Context(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_expression12)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 719
            self.expression11()
            self.state = 726
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,119,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 720
                    self.match(CypherParser.SP)
                    self.state = 721
                    self.match(CypherParser.OR)
                    self.state = 722
                    self.match(CypherParser.SP)
                    self.state = 723
                    self.expression11() 
                self.state = 728
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,119,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression11Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression10(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.Expression10Context)
            else:
                return self.getTypedRuleContext(CypherParser.Expression10Context,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def XOR(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.XOR)
            else:
                return self.getToken(CypherParser.XOR, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression11

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression11" ):
                listener.enterExpression11(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression11" ):
                listener.exitExpression11(self)




    def expression11(self):

        localctx = CypherParser.Expression11Context(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_expression11)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 729
            self.expression10()
            self.state = 736
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,120,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 730
                    self.match(CypherParser.SP)
                    self.state = 731
                    self.match(CypherParser.XOR)
                    self.state = 732
                    self.match(CypherParser.SP)
                    self.state = 733
                    self.expression10() 
                self.state = 738
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,120,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression10Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression9(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.Expression9Context)
            else:
                return self.getTypedRuleContext(CypherParser.Expression9Context,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.AND)
            else:
                return self.getToken(CypherParser.AND, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression10

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression10" ):
                listener.enterExpression10(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression10" ):
                listener.exitExpression10(self)




    def expression10(self):

        localctx = CypherParser.Expression10Context(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_expression10)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 739
            self.expression9()
            self.state = 746
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,121,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 740
                    self.match(CypherParser.SP)
                    self.state = 741
                    self.match(CypherParser.AND)
                    self.state = 742
                    self.match(CypherParser.SP)
                    self.state = 743
                    self.expression9() 
                self.state = 748
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,121,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression9Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression8(self):
            return self.getTypedRuleContext(CypherParser.Expression8Context,0)


        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.NOT)
            else:
                return self.getToken(CypherParser.NOT, i)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression9

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression9" ):
                listener.enterExpression9(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression9" ):
                listener.exitExpression9(self)




    def expression9(self):

        localctx = CypherParser.Expression9Context(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_expression9)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 755
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,123,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 749
                    self.match(CypherParser.NOT)
                    self.state = 751
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 750
                        self.match(CypherParser.SP)

             
                self.state = 757
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,123,self._ctx)

            self.state = 758
            self.expression8()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression8Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression7(self):
            return self.getTypedRuleContext(CypherParser.Expression7Context,0)


        def partialComparisonExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PartialComparisonExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.PartialComparisonExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression8

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression8" ):
                listener.enterExpression8(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression8" ):
                listener.exitExpression8(self)




    def expression8(self):

        localctx = CypherParser.Expression8Context(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_expression8)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 760
            self.expression7()
            self.state = 767
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,125,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 762
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 761
                        self.match(CypherParser.SP)


                    self.state = 764
                    self.partialComparisonExpression() 
                self.state = 769
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,125,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression7Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression6(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.Expression6Context)
            else:
                return self.getTypedRuleContext(CypherParser.Expression6Context,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression7

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression7" ):
                listener.enterExpression7(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression7" ):
                listener.exitExpression7(self)




    def expression7(self):

        localctx = CypherParser.Expression7Context(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_expression7)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 770
            self.expression6()
            self.state = 789
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,131,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 787
                    self._errHandler.sync(self);
                    la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
                    if la_ == 1:
                        self.state = 772
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 771
                            self.match(CypherParser.SP)


                        self.state = 774
                        self.match(CypherParser.T__12)
                        self.state = 776
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 775
                            self.match(CypherParser.SP)


                        self.state = 778
                        self.expression6()
                        pass

                    elif la_ == 2:
                        self.state = 780
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 779
                            self.match(CypherParser.SP)


                        self.state = 782
                        self.match(CypherParser.T__13)
                        self.state = 784
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 783
                            self.match(CypherParser.SP)


                        self.state = 786
                        self.expression6()
                        pass

             
                self.state = 791
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,131,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression6Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression5(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.Expression5Context)
            else:
                return self.getTypedRuleContext(CypherParser.Expression5Context,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression6

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression6" ):
                listener.enterExpression6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression6" ):
                listener.exitExpression6(self)




    def expression6(self):

        localctx = CypherParser.Expression6Context(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_expression6)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.expression5()
            self.state = 819
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,139,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 817
                    self._errHandler.sync(self);
                    la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
                    if la_ == 1:
                        self.state = 794
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 793
                            self.match(CypherParser.SP)


                        self.state = 796
                        self.match(CypherParser.T__4)
                        self.state = 798
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 797
                            self.match(CypherParser.SP)


                        self.state = 800
                        self.expression5()
                        pass

                    elif la_ == 2:
                        self.state = 802
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 801
                            self.match(CypherParser.SP)


                        self.state = 804
                        self.match(CypherParser.T__14)
                        self.state = 806
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 805
                            self.match(CypherParser.SP)


                        self.state = 808
                        self.expression5()
                        pass

                    elif la_ == 3:
                        self.state = 810
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 809
                            self.match(CypherParser.SP)


                        self.state = 812
                        self.match(CypherParser.T__15)
                        self.state = 814
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 813
                            self.match(CypherParser.SP)


                        self.state = 816
                        self.expression5()
                        pass

             
                self.state = 821
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,139,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression5Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression4(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.Expression4Context)
            else:
                return self.getTypedRuleContext(CypherParser.Expression4Context,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression5

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression5" ):
                listener.enterExpression5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression5" ):
                listener.exitExpression5(self)




    def expression5(self):

        localctx = CypherParser.Expression5Context(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_expression5)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 822
            self.expression4()
            self.state = 833
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,142,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 824
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 823
                        self.match(CypherParser.SP)


                    self.state = 826
                    self.match(CypherParser.T__16)
                    self.state = 828
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 827
                        self.match(CypherParser.SP)


                    self.state = 830
                    self.expression4() 
                self.state = 835
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,142,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression4Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression3(self):
            return self.getTypedRuleContext(CypherParser.Expression3Context,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression4

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression4" ):
                listener.enterExpression4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression4" ):
                listener.exitExpression4(self)




    def expression4(self):

        localctx = CypherParser.Expression4Context(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_expression4)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 842
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CypherParser.T__12 or _la==CypherParser.T__13:
                self.state = 836
                _la = self._input.LA(1)
                if not(_la==CypherParser.T__12 or _la==CypherParser.T__13):
                    self._errHandler.recoverInline(self)
                else:
                    self.consume()
                self.state = 838
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 837
                    self.match(CypherParser.SP)


                self.state = 844
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 845
            self.expression3()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression3Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression2(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.Expression2Context)
            else:
                return self.getTypedRuleContext(CypherParser.Expression2Context,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def IS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.IS)
            else:
                return self.getToken(CypherParser.IS, i)

        def NULL(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.NULL)
            else:
                return self.getToken(CypherParser.NULL, i)

        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.NOT)
            else:
                return self.getToken(CypherParser.NOT, i)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.IN)
            else:
                return self.getToken(CypherParser.IN, i)

        def STARTS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.STARTS)
            else:
                return self.getToken(CypherParser.STARTS, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.WITH)
            else:
                return self.getToken(CypherParser.WITH, i)

        def ENDS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.ENDS)
            else:
                return self.getToken(CypherParser.ENDS, i)

        def CONTAINS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.CONTAINS)
            else:
                return self.getToken(CypherParser.CONTAINS, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression3

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression3" ):
                listener.enterExpression3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression3" ):
                listener.exitExpression3(self)




    def expression3(self):

        localctx = CypherParser.Expression3Context(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_expression3)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 847
            self.expression2()
            self.state = 901
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,153,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 899
                    self._errHandler.sync(self);
                    la_ = self._interp.adaptivePredict(self._input,152,self._ctx)
                    if la_ == 1:
                        self.state = 849
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 848
                            self.match(CypherParser.SP)


                        self.state = 851
                        self.match(CypherParser.T__7)
                        self.state = 852
                        self.expression()
                        self.state = 853
                        self.match(CypherParser.T__8)
                        pass

                    elif la_ == 2:
                        self.state = 856
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 855
                            self.match(CypherParser.SP)


                        self.state = 858
                        self.match(CypherParser.T__7)
                        self.state = 860
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__5) | (1 << CypherParser.T__7) | (1 << CypherParser.T__12) | (1 << CypherParser.T__13) | (1 << CypherParser.T__25) | (1 << CypherParser.T__27) | (1 << CypherParser.StringLiteral) | (1 << CypherParser.HexInteger) | (1 << CypherParser.DecimalInteger) | (1 << CypherParser.OctalInteger) | (1 << CypherParser.HexLetter) | (1 << CypherParser.ExponentDecimalReal) | (1 << CypherParser.RegularDecimalReal) | (1 << CypherParser.UNION) | (1 << CypherParser.ALL))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.OPTIONAL - 64)) | (1 << (CypherParser.MATCH - 64)) | (1 << (CypherParser.UNWIND - 64)) | (1 << (CypherParser.AS - 64)) | (1 << (CypherParser.MERGE - 64)) | (1 << (CypherParser.ON - 64)) | (1 << (CypherParser.CREATE - 64)) | (1 << (CypherParser.SET - 64)) | (1 << (CypherParser.DETACH - 64)) | (1 << (CypherParser.DELETE - 64)) | (1 << (CypherParser.REMOVE - 64)) | (1 << (CypherParser.WITH - 64)) | (1 << (CypherParser.DISTINCT - 64)) | (1 << (CypherParser.RETURN - 64)) | (1 << (CypherParser.ORDER - 64)) | (1 << (CypherParser.BY - 64)) | (1 << (CypherParser.L_SKIP - 64)) | (1 << (CypherParser.LIMIT - 64)) | (1 << (CypherParser.ASCENDING - 64)) | (1 << (CypherParser.ASC - 64)) | (1 << (CypherParser.DESCENDING - 64)) | (1 << (CypherParser.DESC - 64)) | (1 << (CypherParser.WHERE - 64)) | (1 << (CypherParser.OR - 64)) | (1 << (CypherParser.XOR - 64)) | (1 << (CypherParser.AND - 64)) | (1 << (CypherParser.NOT - 64)) | (1 << (CypherParser.IN - 64)) | (1 << (CypherParser.STARTS - 64)) | (1 << (CypherParser.ENDS - 64)) | (1 << (CypherParser.CONTAINS - 64)) | (1 << (CypherParser.IS - 64)) | (1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                            self.state = 859
                            self.expression()


                        self.state = 862
                        self.match(CypherParser.T__11)
                        self.state = 864
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__5) | (1 << CypherParser.T__7) | (1 << CypherParser.T__12) | (1 << CypherParser.T__13) | (1 << CypherParser.T__25) | (1 << CypherParser.T__27) | (1 << CypherParser.StringLiteral) | (1 << CypherParser.HexInteger) | (1 << CypherParser.DecimalInteger) | (1 << CypherParser.OctalInteger) | (1 << CypherParser.HexLetter) | (1 << CypherParser.ExponentDecimalReal) | (1 << CypherParser.RegularDecimalReal) | (1 << CypherParser.UNION) | (1 << CypherParser.ALL))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.OPTIONAL - 64)) | (1 << (CypherParser.MATCH - 64)) | (1 << (CypherParser.UNWIND - 64)) | (1 << (CypherParser.AS - 64)) | (1 << (CypherParser.MERGE - 64)) | (1 << (CypherParser.ON - 64)) | (1 << (CypherParser.CREATE - 64)) | (1 << (CypherParser.SET - 64)) | (1 << (CypherParser.DETACH - 64)) | (1 << (CypherParser.DELETE - 64)) | (1 << (CypherParser.REMOVE - 64)) | (1 << (CypherParser.WITH - 64)) | (1 << (CypherParser.DISTINCT - 64)) | (1 << (CypherParser.RETURN - 64)) | (1 << (CypherParser.ORDER - 64)) | (1 << (CypherParser.BY - 64)) | (1 << (CypherParser.L_SKIP - 64)) | (1 << (CypherParser.LIMIT - 64)) | (1 << (CypherParser.ASCENDING - 64)) | (1 << (CypherParser.ASC - 64)) | (1 << (CypherParser.DESCENDING - 64)) | (1 << (CypherParser.DESC - 64)) | (1 << (CypherParser.WHERE - 64)) | (1 << (CypherParser.OR - 64)) | (1 << (CypherParser.XOR - 64)) | (1 << (CypherParser.AND - 64)) | (1 << (CypherParser.NOT - 64)) | (1 << (CypherParser.IN - 64)) | (1 << (CypherParser.STARTS - 64)) | (1 << (CypherParser.ENDS - 64)) | (1 << (CypherParser.CONTAINS - 64)) | (1 << (CypherParser.IS - 64)) | (1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                            self.state = 863
                            self.expression()


                        self.state = 866
                        self.match(CypherParser.T__8)
                        pass

                    elif la_ == 3:
                        self.state = 883
                        self._errHandler.sync(self);
                        la_ = self._interp.adaptivePredict(self._input,150,self._ctx)
                        if la_ == 1:
                            self.state = 868
                            _la = self._input.LA(1)
                            if _la==CypherParser.SP:
                                self.state = 867
                                self.match(CypherParser.SP)


                            self.state = 870
                            self.match(CypherParser.T__17)
                            pass

                        elif la_ == 2:
                            self.state = 871
                            self.match(CypherParser.SP)
                            self.state = 872
                            self.match(CypherParser.IN)
                            pass

                        elif la_ == 3:
                            self.state = 873
                            self.match(CypherParser.SP)
                            self.state = 874
                            self.match(CypherParser.STARTS)
                            self.state = 875
                            self.match(CypherParser.SP)
                            self.state = 876
                            self.match(CypherParser.WITH)
                            pass

                        elif la_ == 4:
                            self.state = 877
                            self.match(CypherParser.SP)
                            self.state = 878
                            self.match(CypherParser.ENDS)
                            self.state = 879
                            self.match(CypherParser.SP)
                            self.state = 880
                            self.match(CypherParser.WITH)
                            pass

                        elif la_ == 5:
                            self.state = 881
                            self.match(CypherParser.SP)
                            self.state = 882
                            self.match(CypherParser.CONTAINS)
                            pass


                        self.state = 886
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 885
                            self.match(CypherParser.SP)


                        self.state = 888
                        self.expression2()
                        pass

                    elif la_ == 4:
                        self.state = 889
                        self.match(CypherParser.SP)
                        self.state = 890
                        self.match(CypherParser.IS)
                        self.state = 891
                        self.match(CypherParser.SP)
                        self.state = 892
                        self.match(CypherParser.NULL)
                        pass

                    elif la_ == 5:
                        self.state = 893
                        self.match(CypherParser.SP)
                        self.state = 894
                        self.match(CypherParser.IS)
                        self.state = 895
                        self.match(CypherParser.SP)
                        self.state = 896
                        self.match(CypherParser.NOT)
                        self.state = 897
                        self.match(CypherParser.SP)
                        self.state = 898
                        self.match(CypherParser.NULL)
                        pass

             
                self.state = 903
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,153,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Expression2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CypherParser.AtomContext,0)


        def propertyLookup(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PropertyLookupContext)
            else:
                return self.getTypedRuleContext(CypherParser.PropertyLookupContext,i)


        def nodeLabels(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NodeLabelsContext)
            else:
                return self.getTypedRuleContext(CypherParser.NodeLabelsContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_expression2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression2" ):
                listener.enterExpression2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression2" ):
                listener.exitExpression2(self)




    def expression2(self):

        localctx = CypherParser.Expression2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_expression2)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 904
            self.atom()
            self.state = 914
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,156,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 906
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 905
                        self.match(CypherParser.SP)


                    self.state = 910
                    token = self._input.LA(1)
                    if token in [CypherParser.T__24]:
                        self.state = 908
                        self.propertyLookup()

                    elif token in [CypherParser.T__9]:
                        self.state = 909
                        self.nodeLabels()

                    else:
                        raise NoViableAltException(self)
             
                self.state = 916
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,156,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(CypherParser.LiteralContext,0)


        def parameter(self):
            return self.getTypedRuleContext(CypherParser.ParameterContext,0)


        def COUNT(self):
            return self.getToken(CypherParser.COUNT, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def listComprehension(self):
            return self.getTypedRuleContext(CypherParser.ListComprehensionContext,0)


        def patternComprehension(self):
            return self.getTypedRuleContext(CypherParser.PatternComprehensionContext,0)


        def FILTER(self):
            return self.getToken(CypherParser.FILTER, 0)

        def filterExpression(self):
            return self.getTypedRuleContext(CypherParser.FilterExpressionContext,0)


        def EXTRACT(self):
            return self.getToken(CypherParser.EXTRACT, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def ANY(self):
            return self.getToken(CypherParser.ANY, 0)

        def NONE(self):
            return self.getToken(CypherParser.NONE, 0)

        def SINGLE(self):
            return self.getToken(CypherParser.SINGLE, 0)

        def relationshipsPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipsPatternContext,0)


        def parenthesizedExpression(self):
            return self.getTypedRuleContext(CypherParser.ParenthesizedExpressionContext,0)


        def functionInvocation(self):
            return self.getTypedRuleContext(CypherParser.FunctionInvocationContext,0)


        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)




    def atom(self):

        localctx = CypherParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.state = 1029
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,180,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 917
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 918
                self.parameter()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 919
                self.match(CypherParser.COUNT)
                self.state = 921
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 920
                    self.match(CypherParser.SP)


                self.state = 923
                self.match(CypherParser.T__5)
                self.state = 925
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 924
                    self.match(CypherParser.SP)


                self.state = 927
                self.match(CypherParser.T__4)
                self.state = 929
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 928
                    self.match(CypherParser.SP)


                self.state = 931
                self.match(CypherParser.T__6)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 932
                self.listComprehension()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 933
                self.patternComprehension()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 934
                self.match(CypherParser.FILTER)
                self.state = 936
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 935
                    self.match(CypherParser.SP)


                self.state = 938
                self.match(CypherParser.T__5)
                self.state = 940
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 939
                    self.match(CypherParser.SP)


                self.state = 942
                self.filterExpression()
                self.state = 944
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 943
                    self.match(CypherParser.SP)


                self.state = 946
                self.match(CypherParser.T__6)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 948
                self.match(CypherParser.EXTRACT)
                self.state = 950
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 949
                    self.match(CypherParser.SP)


                self.state = 952
                self.match(CypherParser.T__5)
                self.state = 954
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 953
                    self.match(CypherParser.SP)


                self.state = 956
                self.filterExpression()
                self.state = 958
                self._errHandler.sync(self);
                la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
                if la_ == 1:
                    self.state = 957
                    self.match(CypherParser.SP)


                self.state = 965
                _la = self._input.LA(1)
                if _la==CypherParser.T__10 or _la==CypherParser.SP:
                    self.state = 961
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 960
                        self.match(CypherParser.SP)


                    self.state = 963
                    self.match(CypherParser.T__10)
                    self.state = 964
                    self.expression()


                self.state = 967
                self.match(CypherParser.T__6)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 969
                self.match(CypherParser.ALL)
                self.state = 971
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 970
                    self.match(CypherParser.SP)


                self.state = 973
                self.match(CypherParser.T__5)
                self.state = 975
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 974
                    self.match(CypherParser.SP)


                self.state = 977
                self.filterExpression()
                self.state = 979
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 978
                    self.match(CypherParser.SP)


                self.state = 981
                self.match(CypherParser.T__6)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 983
                self.match(CypherParser.ANY)
                self.state = 985
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 984
                    self.match(CypherParser.SP)


                self.state = 987
                self.match(CypherParser.T__5)
                self.state = 989
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 988
                    self.match(CypherParser.SP)


                self.state = 991
                self.filterExpression()
                self.state = 993
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 992
                    self.match(CypherParser.SP)


                self.state = 995
                self.match(CypherParser.T__6)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 997
                self.match(CypherParser.NONE)
                self.state = 999
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 998
                    self.match(CypherParser.SP)


                self.state = 1001
                self.match(CypherParser.T__5)
                self.state = 1003
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1002
                    self.match(CypherParser.SP)


                self.state = 1005
                self.filterExpression()
                self.state = 1007
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1006
                    self.match(CypherParser.SP)


                self.state = 1009
                self.match(CypherParser.T__6)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1011
                self.match(CypherParser.SINGLE)
                self.state = 1013
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1012
                    self.match(CypherParser.SP)


                self.state = 1015
                self.match(CypherParser.T__5)
                self.state = 1017
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1016
                    self.match(CypherParser.SP)


                self.state = 1019
                self.filterExpression()
                self.state = 1021
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1020
                    self.match(CypherParser.SP)


                self.state = 1023
                self.match(CypherParser.T__6)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1025
                self.relationshipsPattern()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1026
                self.parenthesizedExpression()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1027
                self.functionInvocation()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1028
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberLiteral(self):
            return self.getTypedRuleContext(CypherParser.NumberLiteralContext,0)


        def StringLiteral(self):
            return self.getToken(CypherParser.StringLiteral, 0)

        def booleanLiteral(self):
            return self.getTypedRuleContext(CypherParser.BooleanLiteralContext,0)


        def NULL(self):
            return self.getToken(CypherParser.NULL, 0)

        def mapLiteral(self):
            return self.getTypedRuleContext(CypherParser.MapLiteralContext,0)


        def listLiteral(self):
            return self.getTypedRuleContext(CypherParser.ListLiteralContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = CypherParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_literal)
        try:
            self.state = 1037
            token = self._input.LA(1)
            if token in [CypherParser.HexInteger, CypherParser.DecimalInteger, CypherParser.OctalInteger, CypherParser.ExponentDecimalReal, CypherParser.RegularDecimalReal]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1031
                self.numberLiteral()

            elif token in [CypherParser.StringLiteral]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1032
                self.match(CypherParser.StringLiteral)

            elif token in [CypherParser.TRUE, CypherParser.FALSE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1033
                self.booleanLiteral()

            elif token in [CypherParser.NULL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1034
                self.match(CypherParser.NULL)

            elif token in [CypherParser.T__25]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1035
                self.mapLiteral()

            elif token in [CypherParser.T__7]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1036
                self.listLiteral()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BooleanLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(CypherParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(CypherParser.FALSE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_booleanLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)




    def booleanLiteral(self):

        localctx = CypherParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_booleanLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1039
            _la = self._input.LA(1)
            if not(_la==CypherParser.TRUE or _la==CypherParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_listLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListLiteral" ):
                listener.enterListLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListLiteral" ):
                listener.exitListLiteral(self)




    def listLiteral(self):

        localctx = CypherParser.ListLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_listLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1041
            self.match(CypherParser.T__7)
            self.state = 1043
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1042
                self.match(CypherParser.SP)


            self.state = 1062
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__5) | (1 << CypherParser.T__7) | (1 << CypherParser.T__12) | (1 << CypherParser.T__13) | (1 << CypherParser.T__25) | (1 << CypherParser.T__27) | (1 << CypherParser.StringLiteral) | (1 << CypherParser.HexInteger) | (1 << CypherParser.DecimalInteger) | (1 << CypherParser.OctalInteger) | (1 << CypherParser.HexLetter) | (1 << CypherParser.ExponentDecimalReal) | (1 << CypherParser.RegularDecimalReal) | (1 << CypherParser.UNION) | (1 << CypherParser.ALL))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.OPTIONAL - 64)) | (1 << (CypherParser.MATCH - 64)) | (1 << (CypherParser.UNWIND - 64)) | (1 << (CypherParser.AS - 64)) | (1 << (CypherParser.MERGE - 64)) | (1 << (CypherParser.ON - 64)) | (1 << (CypherParser.CREATE - 64)) | (1 << (CypherParser.SET - 64)) | (1 << (CypherParser.DETACH - 64)) | (1 << (CypherParser.DELETE - 64)) | (1 << (CypherParser.REMOVE - 64)) | (1 << (CypherParser.WITH - 64)) | (1 << (CypherParser.DISTINCT - 64)) | (1 << (CypherParser.RETURN - 64)) | (1 << (CypherParser.ORDER - 64)) | (1 << (CypherParser.BY - 64)) | (1 << (CypherParser.L_SKIP - 64)) | (1 << (CypherParser.LIMIT - 64)) | (1 << (CypherParser.ASCENDING - 64)) | (1 << (CypherParser.ASC - 64)) | (1 << (CypherParser.DESCENDING - 64)) | (1 << (CypherParser.DESC - 64)) | (1 << (CypherParser.WHERE - 64)) | (1 << (CypherParser.OR - 64)) | (1 << (CypherParser.XOR - 64)) | (1 << (CypherParser.AND - 64)) | (1 << (CypherParser.NOT - 64)) | (1 << (CypherParser.IN - 64)) | (1 << (CypherParser.STARTS - 64)) | (1 << (CypherParser.ENDS - 64)) | (1 << (CypherParser.CONTAINS - 64)) | (1 << (CypherParser.IS - 64)) | (1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                self.state = 1045
                self.expression()
                self.state = 1047
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1046
                    self.match(CypherParser.SP)


                self.state = 1059
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CypherParser.T__1:
                    self.state = 1049
                    self.match(CypherParser.T__1)
                    self.state = 1051
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1050
                        self.match(CypherParser.SP)


                    self.state = 1053
                    self.expression()
                    self.state = 1055
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1054
                        self.match(CypherParser.SP)


                    self.state = 1061
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1064
            self.match(CypherParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PartialComparisonExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression7(self):
            return self.getTypedRuleContext(CypherParser.Expression7Context,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_partialComparisonExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartialComparisonExpression" ):
                listener.enterPartialComparisonExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartialComparisonExpression" ):
                listener.exitPartialComparisonExpression(self)




    def partialComparisonExpression(self):

        localctx = CypherParser.PartialComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_partialComparisonExpression)
        self._la = 0 # Token type
        try:
            self.state = 1101
            token = self._input.LA(1)
            if token in [CypherParser.T__2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1066
                self.match(CypherParser.T__2)
                self.state = 1068
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1067
                    self.match(CypherParser.SP)


                self.state = 1070
                self.expression7()

            elif token in [CypherParser.T__18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1071
                self.match(CypherParser.T__18)
                self.state = 1073
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1072
                    self.match(CypherParser.SP)


                self.state = 1075
                self.expression7()

            elif token in [CypherParser.T__19]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1076
                self.match(CypherParser.T__19)
                self.state = 1078
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1077
                    self.match(CypherParser.SP)


                self.state = 1080
                self.expression7()

            elif token in [CypherParser.T__20]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1081
                self.match(CypherParser.T__20)
                self.state = 1083
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1082
                    self.match(CypherParser.SP)


                self.state = 1085
                self.expression7()

            elif token in [CypherParser.T__21]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1086
                self.match(CypherParser.T__21)
                self.state = 1088
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1087
                    self.match(CypherParser.SP)


                self.state = 1090
                self.expression7()

            elif token in [CypherParser.T__22]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1091
                self.match(CypherParser.T__22)
                self.state = 1093
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1092
                    self.match(CypherParser.SP)


                self.state = 1095
                self.expression7()

            elif token in [CypherParser.T__23]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1096
                self.match(CypherParser.T__23)
                self.state = 1098
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1097
                    self.match(CypherParser.SP)


                self.state = 1100
                self.expression7()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParenthesizedExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_parenthesizedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)




    def parenthesizedExpression(self):

        localctx = CypherParser.ParenthesizedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_parenthesizedExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1103
            self.match(CypherParser.T__5)
            self.state = 1105
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1104
                self.match(CypherParser.SP)


            self.state = 1107
            self.expression()
            self.state = 1109
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1108
                self.match(CypherParser.SP)


            self.state = 1111
            self.match(CypherParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipsPatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def patternElementChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternElementChainContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternElementChainContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_relationshipsPattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipsPattern" ):
                listener.enterRelationshipsPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipsPattern" ):
                listener.exitRelationshipsPattern(self)




    def relationshipsPattern(self):

        localctx = CypherParser.RelationshipsPatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_relationshipsPattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1113
            self.nodePattern()
            self.state = 1118 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1115
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1114
                        self.match(CypherParser.SP)


                    self.state = 1117
                    self.patternElementChain()

                else:
                    raise NoViableAltException(self)
                self.state = 1120 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,199,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FilterExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def idInColl(self):
            return self.getTypedRuleContext(CypherParser.IdInCollContext,0)


        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_filterExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterExpression" ):
                listener.enterFilterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterExpression" ):
                listener.exitFilterExpression(self)




    def filterExpression(self):

        localctx = CypherParser.FilterExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_filterExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1122
            self.idInColl()
            self.state = 1127
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
            if la_ == 1:
                self.state = 1124
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1123
                    self.match(CypherParser.SP)


                self.state = 1126
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdInCollContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def IN(self):
            return self.getToken(CypherParser.IN, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_idInColl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdInColl" ):
                listener.enterIdInColl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdInColl" ):
                listener.exitIdInColl(self)




    def idInColl(self):

        localctx = CypherParser.IdInCollContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_idInColl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1129
            self.variable()
            self.state = 1130
            self.match(CypherParser.SP)
            self.state = 1131
            self.match(CypherParser.IN)
            self.state = 1132
            self.match(CypherParser.SP)
            self.state = 1133
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionInvocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionName(self):
            return self.getTypedRuleContext(CypherParser.FunctionNameContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_functionInvocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionInvocation" ):
                listener.enterFunctionInvocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionInvocation" ):
                listener.exitFunctionInvocation(self)




    def functionInvocation(self):

        localctx = CypherParser.FunctionInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_functionInvocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1135
            self.functionName()
            self.state = 1137
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1136
                self.match(CypherParser.SP)


            self.state = 1139
            self.match(CypherParser.T__5)
            self.state = 1141
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1140
                self.match(CypherParser.SP)


            self.state = 1147
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
            if la_ == 1:
                self.state = 1143
                self.match(CypherParser.DISTINCT)
                self.state = 1145
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1144
                    self.match(CypherParser.SP)




            self.state = 1166
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__5) | (1 << CypherParser.T__7) | (1 << CypherParser.T__12) | (1 << CypherParser.T__13) | (1 << CypherParser.T__25) | (1 << CypherParser.T__27) | (1 << CypherParser.StringLiteral) | (1 << CypherParser.HexInteger) | (1 << CypherParser.DecimalInteger) | (1 << CypherParser.OctalInteger) | (1 << CypherParser.HexLetter) | (1 << CypherParser.ExponentDecimalReal) | (1 << CypherParser.RegularDecimalReal) | (1 << CypherParser.UNION) | (1 << CypherParser.ALL))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.OPTIONAL - 64)) | (1 << (CypherParser.MATCH - 64)) | (1 << (CypherParser.UNWIND - 64)) | (1 << (CypherParser.AS - 64)) | (1 << (CypherParser.MERGE - 64)) | (1 << (CypherParser.ON - 64)) | (1 << (CypherParser.CREATE - 64)) | (1 << (CypherParser.SET - 64)) | (1 << (CypherParser.DETACH - 64)) | (1 << (CypherParser.DELETE - 64)) | (1 << (CypherParser.REMOVE - 64)) | (1 << (CypherParser.WITH - 64)) | (1 << (CypherParser.DISTINCT - 64)) | (1 << (CypherParser.RETURN - 64)) | (1 << (CypherParser.ORDER - 64)) | (1 << (CypherParser.BY - 64)) | (1 << (CypherParser.L_SKIP - 64)) | (1 << (CypherParser.LIMIT - 64)) | (1 << (CypherParser.ASCENDING - 64)) | (1 << (CypherParser.ASC - 64)) | (1 << (CypherParser.DESCENDING - 64)) | (1 << (CypherParser.DESC - 64)) | (1 << (CypherParser.WHERE - 64)) | (1 << (CypherParser.OR - 64)) | (1 << (CypherParser.XOR - 64)) | (1 << (CypherParser.AND - 64)) | (1 << (CypherParser.NOT - 64)) | (1 << (CypherParser.IN - 64)) | (1 << (CypherParser.STARTS - 64)) | (1 << (CypherParser.ENDS - 64)) | (1 << (CypherParser.CONTAINS - 64)) | (1 << (CypherParser.IS - 64)) | (1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                self.state = 1149
                self.expression()
                self.state = 1151
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1150
                    self.match(CypherParser.SP)


                self.state = 1163
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CypherParser.T__1:
                    self.state = 1153
                    self.match(CypherParser.T__1)
                    self.state = 1155
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1154
                        self.match(CypherParser.SP)


                    self.state = 1157
                    self.expression()
                    self.state = 1159
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1158
                        self.match(CypherParser.SP)


                    self.state = 1165
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1168
            self.match(CypherParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UnescapedSymbolicName(self):
            return self.getToken(CypherParser.UnescapedSymbolicName, 0)

        def EscapedSymbolicName(self):
            return self.getToken(CypherParser.EscapedSymbolicName, 0)

        def COUNT(self):
            return self.getToken(CypherParser.COUNT, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_functionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionName" ):
                listener.enterFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionName" ):
                listener.exitFunctionName(self)




    def functionName(self):

        localctx = CypherParser.FunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_functionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1170
            _la = self._input.LA(1)
            if not(((((_la - 97)) & ~0x3f) == 0 and ((1 << (_la - 97)) & ((1 << (CypherParser.COUNT - 97)) | (1 << (CypherParser.UnescapedSymbolicName - 97)) | (1 << (CypherParser.EscapedSymbolicName - 97)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListComprehensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filterExpression(self):
            return self.getTypedRuleContext(CypherParser.FilterExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_listComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListComprehension" ):
                listener.enterListComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListComprehension" ):
                listener.exitListComprehension(self)




    def listComprehension(self):

        localctx = CypherParser.ListComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_listComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1172
            self.match(CypherParser.T__7)
            self.state = 1174
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1173
                self.match(CypherParser.SP)


            self.state = 1176
            self.filterExpression()
            self.state = 1185
            self._errHandler.sync(self);
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                self.state = 1178
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1177
                    self.match(CypherParser.SP)


                self.state = 1180
                self.match(CypherParser.T__10)
                self.state = 1182
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1181
                    self.match(CypherParser.SP)


                self.state = 1184
                self.expression()


            self.state = 1188
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1187
                self.match(CypherParser.SP)


            self.state = 1190
            self.match(CypherParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternComprehensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationshipsPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipsPatternContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_patternComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternComprehension" ):
                listener.enterPatternComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternComprehension" ):
                listener.exitPatternComprehension(self)




    def patternComprehension(self):

        localctx = CypherParser.PatternComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_patternComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1192
            self.match(CypherParser.T__7)
            self.state = 1194
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1193
                self.match(CypherParser.SP)


            self.state = 1204
            _la = self._input.LA(1)
            if ((((_la - 53)) & ~0x3f) == 0 and ((1 << (_la - 53)) & ((1 << (CypherParser.HexLetter - 53)) | (1 << (CypherParser.UNION - 53)) | (1 << (CypherParser.ALL - 53)) | (1 << (CypherParser.OPTIONAL - 53)) | (1 << (CypherParser.MATCH - 53)) | (1 << (CypherParser.UNWIND - 53)) | (1 << (CypherParser.AS - 53)) | (1 << (CypherParser.MERGE - 53)) | (1 << (CypherParser.ON - 53)) | (1 << (CypherParser.CREATE - 53)) | (1 << (CypherParser.SET - 53)) | (1 << (CypherParser.DETACH - 53)) | (1 << (CypherParser.DELETE - 53)) | (1 << (CypherParser.REMOVE - 53)) | (1 << (CypherParser.WITH - 53)) | (1 << (CypherParser.DISTINCT - 53)) | (1 << (CypherParser.RETURN - 53)) | (1 << (CypherParser.ORDER - 53)) | (1 << (CypherParser.BY - 53)) | (1 << (CypherParser.L_SKIP - 53)) | (1 << (CypherParser.LIMIT - 53)) | (1 << (CypherParser.ASCENDING - 53)) | (1 << (CypherParser.ASC - 53)) | (1 << (CypherParser.DESCENDING - 53)) | (1 << (CypherParser.DESC - 53)) | (1 << (CypherParser.WHERE - 53)) | (1 << (CypherParser.OR - 53)) | (1 << (CypherParser.XOR - 53)) | (1 << (CypherParser.AND - 53)) | (1 << (CypherParser.NOT - 53)) | (1 << (CypherParser.IN - 53)) | (1 << (CypherParser.STARTS - 53)) | (1 << (CypherParser.ENDS - 53)) | (1 << (CypherParser.CONTAINS - 53)) | (1 << (CypherParser.IS - 53)) | (1 << (CypherParser.NULL - 53)) | (1 << (CypherParser.COUNT - 53)) | (1 << (CypherParser.FILTER - 53)) | (1 << (CypherParser.EXTRACT - 53)) | (1 << (CypherParser.ANY - 53)) | (1 << (CypherParser.NONE - 53)) | (1 << (CypherParser.SINGLE - 53)) | (1 << (CypherParser.TRUE - 53)) | (1 << (CypherParser.FALSE - 53)) | (1 << (CypherParser.UnescapedSymbolicName - 53)) | (1 << (CypherParser.EscapedSymbolicName - 53)))) != 0):
                self.state = 1196
                self.variable()
                self.state = 1198
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1197
                    self.match(CypherParser.SP)


                self.state = 1200
                self.match(CypherParser.T__2)
                self.state = 1202
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1201
                    self.match(CypherParser.SP)




            self.state = 1206
            self.relationshipsPattern()
            self.state = 1208
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1207
                self.match(CypherParser.SP)


            self.state = 1218
            _la = self._input.LA(1)
            if _la==CypherParser.WHERE:
                self.state = 1210
                self.match(CypherParser.WHERE)
                self.state = 1212
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1211
                    self.match(CypherParser.SP)


                self.state = 1214
                self.expression()
                self.state = 1216
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1215
                    self.match(CypherParser.SP)




            self.state = 1220
            self.match(CypherParser.T__10)
            self.state = 1222
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1221
                self.match(CypherParser.SP)


            self.state = 1224
            self.expression()
            self.state = 1226
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1225
                self.match(CypherParser.SP)


            self.state = 1228
            self.match(CypherParser.T__8)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertyLookupContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyKeyName(self):
            return self.getTypedRuleContext(CypherParser.PropertyKeyNameContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_propertyLookup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyLookup" ):
                listener.enterPropertyLookup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyLookup" ):
                listener.exitPropertyLookup(self)




    def propertyLookup(self):

        localctx = CypherParser.PropertyLookupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_propertyLookup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1230
            self.match(CypherParser.T__24)
            self.state = 1232
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1231
                self.match(CypherParser.SP)


            self.state = 1234
            self.propertyKeyName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)




    def variable(self):

        localctx = CypherParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1236
            self.symbolicName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def doubleLiteral(self):
            return self.getTypedRuleContext(CypherParser.DoubleLiteralContext,0)


        def integerLiteral(self):
            return self.getTypedRuleContext(CypherParser.IntegerLiteralContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_numberLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteral" ):
                listener.enterNumberLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteral" ):
                listener.exitNumberLiteral(self)




    def numberLiteral(self):

        localctx = CypherParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_numberLiteral)
        try:
            self.state = 1240
            token = self._input.LA(1)
            if token in [CypherParser.ExponentDecimalReal, CypherParser.RegularDecimalReal]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1238
                self.doubleLiteral()

            elif token in [CypherParser.HexInteger, CypherParser.DecimalInteger, CypherParser.OctalInteger]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1239
                self.integerLiteral()

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MapLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def propertyKeyName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PropertyKeyNameContext)
            else:
                return self.getTypedRuleContext(CypherParser.PropertyKeyNameContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_mapLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapLiteral" ):
                listener.enterMapLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapLiteral" ):
                listener.exitMapLiteral(self)




    def mapLiteral(self):

        localctx = CypherParser.MapLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_mapLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1242
            self.match(CypherParser.T__25)
            self.state = 1244
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1243
                self.match(CypherParser.SP)


            self.state = 1279
            _la = self._input.LA(1)
            if ((((_la - 53)) & ~0x3f) == 0 and ((1 << (_la - 53)) & ((1 << (CypherParser.HexLetter - 53)) | (1 << (CypherParser.UNION - 53)) | (1 << (CypherParser.ALL - 53)) | (1 << (CypherParser.OPTIONAL - 53)) | (1 << (CypherParser.MATCH - 53)) | (1 << (CypherParser.UNWIND - 53)) | (1 << (CypherParser.AS - 53)) | (1 << (CypherParser.MERGE - 53)) | (1 << (CypherParser.ON - 53)) | (1 << (CypherParser.CREATE - 53)) | (1 << (CypherParser.SET - 53)) | (1 << (CypherParser.DETACH - 53)) | (1 << (CypherParser.DELETE - 53)) | (1 << (CypherParser.REMOVE - 53)) | (1 << (CypherParser.WITH - 53)) | (1 << (CypherParser.DISTINCT - 53)) | (1 << (CypherParser.RETURN - 53)) | (1 << (CypherParser.ORDER - 53)) | (1 << (CypherParser.BY - 53)) | (1 << (CypherParser.L_SKIP - 53)) | (1 << (CypherParser.LIMIT - 53)) | (1 << (CypherParser.ASCENDING - 53)) | (1 << (CypherParser.ASC - 53)) | (1 << (CypherParser.DESCENDING - 53)) | (1 << (CypherParser.DESC - 53)) | (1 << (CypherParser.WHERE - 53)) | (1 << (CypherParser.OR - 53)) | (1 << (CypherParser.XOR - 53)) | (1 << (CypherParser.AND - 53)) | (1 << (CypherParser.NOT - 53)) | (1 << (CypherParser.IN - 53)) | (1 << (CypherParser.STARTS - 53)) | (1 << (CypherParser.ENDS - 53)) | (1 << (CypherParser.CONTAINS - 53)) | (1 << (CypherParser.IS - 53)) | (1 << (CypherParser.NULL - 53)) | (1 << (CypherParser.COUNT - 53)) | (1 << (CypherParser.FILTER - 53)) | (1 << (CypherParser.EXTRACT - 53)) | (1 << (CypherParser.ANY - 53)) | (1 << (CypherParser.NONE - 53)) | (1 << (CypherParser.SINGLE - 53)) | (1 << (CypherParser.TRUE - 53)) | (1 << (CypherParser.FALSE - 53)) | (1 << (CypherParser.UnescapedSymbolicName - 53)) | (1 << (CypherParser.EscapedSymbolicName - 53)))) != 0):
                self.state = 1246
                self.propertyKeyName()
                self.state = 1248
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1247
                    self.match(CypherParser.SP)


                self.state = 1250
                self.match(CypherParser.T__9)
                self.state = 1252
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1251
                    self.match(CypherParser.SP)


                self.state = 1254
                self.expression()
                self.state = 1256
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1255
                    self.match(CypherParser.SP)


                self.state = 1276
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CypherParser.T__1:
                    self.state = 1258
                    self.match(CypherParser.T__1)
                    self.state = 1260
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1259
                        self.match(CypherParser.SP)


                    self.state = 1262
                    self.propertyKeyName()
                    self.state = 1264
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1263
                        self.match(CypherParser.SP)


                    self.state = 1266
                    self.match(CypherParser.T__9)
                    self.state = 1268
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1267
                        self.match(CypherParser.SP)


                    self.state = 1270
                    self.expression()
                    self.state = 1272
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1271
                        self.match(CypherParser.SP)


                    self.state = 1278
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1281
            self.match(CypherParser.T__26)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def DecimalInteger(self):
            return self.getToken(CypherParser.DecimalInteger, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)




    def parameter(self):

        localctx = CypherParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1283
            self.match(CypherParser.T__27)
            self.state = 1286
            token = self._input.LA(1)
            if token in [CypherParser.HexLetter, CypherParser.UNION, CypherParser.ALL, CypherParser.OPTIONAL, CypherParser.MATCH, CypherParser.UNWIND, CypherParser.AS, CypherParser.MERGE, CypherParser.ON, CypherParser.CREATE, CypherParser.SET, CypherParser.DETACH, CypherParser.DELETE, CypherParser.REMOVE, CypherParser.WITH, CypherParser.DISTINCT, CypherParser.RETURN, CypherParser.ORDER, CypherParser.BY, CypherParser.L_SKIP, CypherParser.LIMIT, CypherParser.ASCENDING, CypherParser.ASC, CypherParser.DESCENDING, CypherParser.DESC, CypherParser.WHERE, CypherParser.OR, CypherParser.XOR, CypherParser.AND, CypherParser.NOT, CypherParser.IN, CypherParser.STARTS, CypherParser.ENDS, CypherParser.CONTAINS, CypherParser.IS, CypherParser.NULL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.TRUE, CypherParser.FALSE, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.state = 1284
                self.symbolicName()

            elif token in [CypherParser.DecimalInteger]:
                self.state = 1285
                self.match(CypherParser.DecimalInteger)

            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertyExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CypherParser.AtomContext,0)


        def propertyLookup(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PropertyLookupContext)
            else:
                return self.getTypedRuleContext(CypherParser.PropertyLookupContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_propertyExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyExpression" ):
                listener.enterPropertyExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyExpression" ):
                listener.exitPropertyExpression(self)




    def propertyExpression(self):

        localctx = CypherParser.PropertyExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_propertyExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1288
            self.atom()
            self.state = 1293 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1290
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1289
                        self.match(CypherParser.SP)


                    self.state = 1292
                    self.propertyLookup()

                else:
                    raise NoViableAltException(self)
                self.state = 1295 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,240,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertyKeyNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_propertyKeyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyKeyName" ):
                listener.enterPropertyKeyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyKeyName" ):
                listener.exitPropertyKeyName(self)




    def propertyKeyName(self):

        localctx = CypherParser.PropertyKeyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_propertyKeyName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1297
            self.symbolicName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegerLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HexInteger(self):
            return self.getToken(CypherParser.HexInteger, 0)

        def OctalInteger(self):
            return self.getToken(CypherParser.OctalInteger, 0)

        def DecimalInteger(self):
            return self.getToken(CypherParser.DecimalInteger, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_integerLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerLiteral" ):
                listener.enterIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerLiteral" ):
                listener.exitIntegerLiteral(self)




    def integerLiteral(self):

        localctx = CypherParser.IntegerLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_integerLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1299
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.HexInteger) | (1 << CypherParser.DecimalInteger) | (1 << CypherParser.OctalInteger))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DoubleLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ExponentDecimalReal(self):
            return self.getToken(CypherParser.ExponentDecimalReal, 0)

        def RegularDecimalReal(self):
            return self.getToken(CypherParser.RegularDecimalReal, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_doubleLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleLiteral" ):
                listener.enterDoubleLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleLiteral" ):
                listener.exitDoubleLiteral(self)




    def doubleLiteral(self):

        localctx = CypherParser.DoubleLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_doubleLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            _la = self._input.LA(1)
            if not(_la==CypherParser.ExponentDecimalReal or _la==CypherParser.RegularDecimalReal):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SymbolicNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UnescapedSymbolicName(self):
            return self.getToken(CypherParser.UnescapedSymbolicName, 0)

        def EscapedSymbolicName(self):
            return self.getToken(CypherParser.EscapedSymbolicName, 0)

        def UNION(self):
            return self.getToken(CypherParser.UNION, 0)

        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def OPTIONAL(self):
            return self.getToken(CypherParser.OPTIONAL, 0)

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def UNWIND(self):
            return self.getToken(CypherParser.UNWIND, 0)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def MERGE(self):
            return self.getToken(CypherParser.MERGE, 0)

        def ON(self):
            return self.getToken(CypherParser.ON, 0)

        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def SET(self):
            return self.getToken(CypherParser.SET, 0)

        def DETACH(self):
            return self.getToken(CypherParser.DETACH, 0)

        def DELETE(self):
            return self.getToken(CypherParser.DELETE, 0)

        def REMOVE(self):
            return self.getToken(CypherParser.REMOVE, 0)

        def WITH(self):
            return self.getToken(CypherParser.WITH, 0)

        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def RETURN(self):
            return self.getToken(CypherParser.RETURN, 0)

        def ORDER(self):
            return self.getToken(CypherParser.ORDER, 0)

        def BY(self):
            return self.getToken(CypherParser.BY, 0)

        def L_SKIP(self):
            return self.getToken(CypherParser.L_SKIP, 0)

        def LIMIT(self):
            return self.getToken(CypherParser.LIMIT, 0)

        def ASCENDING(self):
            return self.getToken(CypherParser.ASCENDING, 0)

        def ASC(self):
            return self.getToken(CypherParser.ASC, 0)

        def DESCENDING(self):
            return self.getToken(CypherParser.DESCENDING, 0)

        def DESC(self):
            return self.getToken(CypherParser.DESC, 0)

        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def OR(self):
            return self.getToken(CypherParser.OR, 0)

        def XOR(self):
            return self.getToken(CypherParser.XOR, 0)

        def AND(self):
            return self.getToken(CypherParser.AND, 0)

        def NOT(self):
            return self.getToken(CypherParser.NOT, 0)

        def IN(self):
            return self.getToken(CypherParser.IN, 0)

        def STARTS(self):
            return self.getToken(CypherParser.STARTS, 0)

        def ENDS(self):
            return self.getToken(CypherParser.ENDS, 0)

        def CONTAINS(self):
            return self.getToken(CypherParser.CONTAINS, 0)

        def IS(self):
            return self.getToken(CypherParser.IS, 0)

        def NULL(self):
            return self.getToken(CypherParser.NULL, 0)

        def COUNT(self):
            return self.getToken(CypherParser.COUNT, 0)

        def FILTER(self):
            return self.getToken(CypherParser.FILTER, 0)

        def EXTRACT(self):
            return self.getToken(CypherParser.EXTRACT, 0)

        def ANY(self):
            return self.getToken(CypherParser.ANY, 0)

        def NONE(self):
            return self.getToken(CypherParser.NONE, 0)

        def SINGLE(self):
            return self.getToken(CypherParser.SINGLE, 0)

        def TRUE(self):
            return self.getToken(CypherParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(CypherParser.FALSE, 0)

        def HexLetter(self):
            return self.getToken(CypherParser.HexLetter, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_symbolicName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolicName" ):
                listener.enterSymbolicName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolicName" ):
                listener.exitSymbolicName(self)




    def symbolicName(self):

        localctx = CypherParser.SymbolicNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_symbolicName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1303
            _la = self._input.LA(1)
            if not(((((_la - 53)) & ~0x3f) == 0 and ((1 << (_la - 53)) & ((1 << (CypherParser.HexLetter - 53)) | (1 << (CypherParser.UNION - 53)) | (1 << (CypherParser.ALL - 53)) | (1 << (CypherParser.OPTIONAL - 53)) | (1 << (CypherParser.MATCH - 53)) | (1 << (CypherParser.UNWIND - 53)) | (1 << (CypherParser.AS - 53)) | (1 << (CypherParser.MERGE - 53)) | (1 << (CypherParser.ON - 53)) | (1 << (CypherParser.CREATE - 53)) | (1 << (CypherParser.SET - 53)) | (1 << (CypherParser.DETACH - 53)) | (1 << (CypherParser.DELETE - 53)) | (1 << (CypherParser.REMOVE - 53)) | (1 << (CypherParser.WITH - 53)) | (1 << (CypherParser.DISTINCT - 53)) | (1 << (CypherParser.RETURN - 53)) | (1 << (CypherParser.ORDER - 53)) | (1 << (CypherParser.BY - 53)) | (1 << (CypherParser.L_SKIP - 53)) | (1 << (CypherParser.LIMIT - 53)) | (1 << (CypherParser.ASCENDING - 53)) | (1 << (CypherParser.ASC - 53)) | (1 << (CypherParser.DESCENDING - 53)) | (1 << (CypherParser.DESC - 53)) | (1 << (CypherParser.WHERE - 53)) | (1 << (CypherParser.OR - 53)) | (1 << (CypherParser.XOR - 53)) | (1 << (CypherParser.AND - 53)) | (1 << (CypherParser.NOT - 53)) | (1 << (CypherParser.IN - 53)) | (1 << (CypherParser.STARTS - 53)) | (1 << (CypherParser.ENDS - 53)) | (1 << (CypherParser.CONTAINS - 53)) | (1 << (CypherParser.IS - 53)) | (1 << (CypherParser.NULL - 53)) | (1 << (CypherParser.COUNT - 53)) | (1 << (CypherParser.FILTER - 53)) | (1 << (CypherParser.EXTRACT - 53)) | (1 << (CypherParser.ANY - 53)) | (1 << (CypherParser.NONE - 53)) | (1 << (CypherParser.SINGLE - 53)) | (1 << (CypherParser.TRUE - 53)) | (1 << (CypherParser.FALSE - 53)) | (1 << (CypherParser.UnescapedSymbolicName - 53)) | (1 << (CypherParser.EscapedSymbolicName - 53)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LeftArrowHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CypherParser.RULE_leftArrowHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeftArrowHead" ):
                listener.enterLeftArrowHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeftArrowHead" ):
                listener.exitLeftArrowHead(self)




    def leftArrowHead(self):

        localctx = CypherParser.LeftArrowHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_leftArrowHead)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1305
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__20) | (1 << CypherParser.T__28) | (1 << CypherParser.T__29) | (1 << CypherParser.T__30) | (1 << CypherParser.T__31))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RightArrowHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CypherParser.RULE_rightArrowHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightArrowHead" ):
                listener.enterRightArrowHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightArrowHead" ):
                listener.exitRightArrowHead(self)




    def rightArrowHead(self):

        localctx = CypherParser.RightArrowHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_rightArrowHead)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1307
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__21) | (1 << CypherParser.T__32) | (1 << CypherParser.T__33) | (1 << CypherParser.T__34) | (1 << CypherParser.T__35))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DashContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CypherParser.RULE_dash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDash" ):
                listener.enterDash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDash" ):
                listener.exitDash(self)




    def dash(self):

        localctx = CypherParser.DashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_dash)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1309
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__13) | (1 << CypherParser.T__36) | (1 << CypherParser.T__37) | (1 << CypherParser.T__38) | (1 << CypherParser.T__39) | (1 << CypherParser.T__40) | (1 << CypherParser.T__41) | (1 << CypherParser.T__42) | (1 << CypherParser.T__43) | (1 << CypherParser.T__44) | (1 << CypherParser.T__45) | (1 << CypherParser.T__46))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





