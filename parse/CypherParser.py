# Generated from Cypher.g4 by ANTLR 4.7
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3j")
        buf.write("\u05ca\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\3\2\5\2")
        buf.write("\u00bc\n\2\3\2\3\2\5\2\u00c0\n\2\3\2\5\2\u00c3\n\2\3\2")
        buf.write("\5\2\u00c6\n\2\3\3\3\3\3\4\3\4\5\4\u00cc\n\4\3\5\3\5\5")
        buf.write("\5\u00d0\n\5\3\5\7\5\u00d3\n\5\f\5\16\5\u00d6\13\5\3\6")
        buf.write("\3\6\5\6\u00da\n\6\3\6\7\6\u00dd\n\6\f\6\16\6\u00e0\13")
        buf.write("\6\3\7\3\7\3\7\3\7\5\7\u00e6\n\7\3\7\3\7\3\7\5\7\u00eb")
        buf.write("\n\7\3\7\5\7\u00ee\n\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b")
        buf.write("\3\b\3\b\5\b\u00fa\n\b\3\t\3\t\5\t\u00fe\n\t\3\t\3\t\5")
        buf.write("\t\u0102\n\t\3\t\3\t\5\t\u0106\n\t\3\t\5\t\u0109\n\t\3")
        buf.write("\n\3\n\5\n\u010d\n\n\3\n\3\n\3\n\3\n\3\n\3\n\3\13\3\13")
        buf.write("\5\13\u0117\n\13\3\13\3\13\3\13\7\13\u011c\n\13\f\13\16")
        buf.write("\13\u011f\13\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3")
        buf.write("\f\5\f\u012b\n\f\3\r\3\r\5\r\u012f\n\r\3\r\3\r\3\16\3")
        buf.write("\16\5\16\u0135\n\16\3\16\3\16\3\16\7\16\u013a\n\16\f\16")
        buf.write("\16\16\u013d\13\16\3\17\3\17\5\17\u0141\n\17\3\17\3\17")
        buf.write("\5\17\u0145\n\17\3\17\3\17\3\17\3\17\5\17\u014b\n\17\3")
        buf.write("\17\3\17\5\17\u014f\n\17\3\17\3\17\3\17\3\17\5\17\u0155")
        buf.write("\n\17\3\17\3\17\5\17\u0159\n\17\3\17\3\17\3\17\3\17\5")
        buf.write("\17\u015f\n\17\3\17\3\17\5\17\u0163\n\17\3\20\3\20\5\20")
        buf.write("\u0167\n\20\3\20\3\20\5\20\u016b\n\20\3\20\3\20\5\20\u016f")
        buf.write("\n\20\3\20\3\20\5\20\u0173\n\20\3\20\7\20\u0176\n\20\f")
        buf.write("\20\16\20\u0179\13\20\3\21\3\21\3\21\3\21\5\21\u017f\n")
        buf.write("\21\3\21\3\21\5\21\u0183\n\21\3\21\7\21\u0186\n\21\f\21")
        buf.write("\16\21\u0189\13\21\3\22\3\22\3\22\3\22\5\22\u018f\n\22")
        buf.write("\3\23\3\23\3\23\3\23\5\23\u0195\n\23\3\23\3\23\3\23\5")
        buf.write("\23\u019a\n\23\3\24\3\24\3\24\3\24\5\24\u01a0\n\24\3\24")
        buf.write("\3\24\3\24\3\24\5\24\u01a6\n\24\3\25\3\25\5\25\u01aa\n")
        buf.write("\25\3\25\3\25\5\25\u01ae\n\25\3\25\7\25\u01b1\n\25\f\25")
        buf.write("\16\25\u01b4\13\25\3\25\5\25\u01b7\n\25\3\26\3\26\3\26")
        buf.write("\3\26\3\26\5\26\u01be\n\26\3\26\3\26\3\27\3\27\5\27\u01c4")
        buf.write("\n\27\3\27\5\27\u01c7\n\27\3\27\3\27\3\27\5\27\u01cc\n")
        buf.write("\27\3\27\5\27\u01cf\n\27\3\30\3\30\5\30\u01d3\n\30\3\30")
        buf.write("\5\30\u01d6\n\30\3\30\3\30\3\30\3\31\3\31\3\31\5\31\u01de")
        buf.write("\n\31\3\31\3\31\5\31\u01e2\n\31\3\31\3\31\5\31\u01e6\n")
        buf.write("\31\3\32\3\32\5\32\u01ea\n\32\3\32\3\32\5\32\u01ee\n\32")
        buf.write("\3\32\7\32\u01f1\n\32\f\32\16\32\u01f4\13\32\3\32\3\32")
        buf.write("\5\32\u01f8\n\32\3\32\3\32\5\32\u01fc\n\32\3\32\7\32\u01ff")
        buf.write("\n\32\f\32\16\32\u0202\13\32\5\32\u0204\n\32\3\33\3\33")
        buf.write("\3\33\3\33\3\33\3\33\3\33\5\33\u020d\n\33\3\34\3\34\3")
        buf.write("\34\3\34\3\34\3\34\3\34\5\34\u0216\n\34\3\34\7\34\u0219")
        buf.write("\n\34\f\34\16\34\u021c\13\34\3\35\3\35\3\35\3\35\3\36")
        buf.write("\3\36\3\36\3\36\3\37\3\37\5\37\u0228\n\37\3\37\5\37\u022b")
        buf.write("\n\37\3 \3 \3 \3 \3!\3!\5!\u0233\n!\3!\3!\5!\u0237\n!")
        buf.write("\3!\7!\u023a\n!\f!\16!\u023d\13!\3\"\3\"\5\"\u0241\n\"")
        buf.write("\3\"\3\"\5\"\u0245\n\"\3\"\3\"\3\"\5\"\u024a\n\"\3#\3")
        buf.write("#\3$\3$\5$\u0250\n$\3$\7$\u0253\n$\f$\16$\u0256\13$\3")
        buf.write("$\3$\3$\3$\5$\u025c\n$\3%\3%\5%\u0260\n%\3%\3%\5%\u0264")
        buf.write("\n%\5%\u0266\n%\3%\3%\5%\u026a\n%\5%\u026c\n%\3%\3%\5")
        buf.write("%\u0270\n%\5%\u0272\n%\3%\3%\3&\3&\5&\u0278\n&\3&\3&\3")
        buf.write("\'\3\'\5\'\u027e\n\'\3\'\3\'\5\'\u0282\n\'\3\'\5\'\u0285")
        buf.write("\n\'\3\'\5\'\u0288\n\'\3\'\3\'\5\'\u028c\n\'\3\'\3\'\3")
        buf.write("\'\3\'\5\'\u0292\n\'\3\'\3\'\5\'\u0296\n\'\3\'\5\'\u0299")
        buf.write("\n\'\3\'\5\'\u029c\n\'\3\'\3\'\3\'\3\'\5\'\u02a2\n\'\3")
        buf.write("\'\5\'\u02a5\n\'\3\'\5\'\u02a8\n\'\3\'\3\'\5\'\u02ac\n")
        buf.write("\'\3\'\3\'\3\'\3\'\5\'\u02b2\n\'\3\'\5\'\u02b5\n\'\3\'")
        buf.write("\5\'\u02b8\n\'\3\'\3\'\5\'\u02bc\n\'\3(\3(\5(\u02c0\n")
        buf.write("(\3(\3(\5(\u02c4\n(\5(\u02c6\n(\3(\3(\5(\u02ca\n(\5(\u02cc")
        buf.write("\n(\3(\5(\u02cf\n(\3(\3(\5(\u02d3\n(\5(\u02d5\n(\3(\3")
        buf.write("(\3)\3)\5)\u02db\n)\3*\3*\5*\u02df\n*\3*\3*\5*\u02e3\n")
        buf.write("*\3*\3*\5*\u02e7\n*\3*\5*\u02ea\n*\3*\7*\u02ed\n*\f*\16")
        buf.write("*\u02f0\13*\3+\3+\5+\u02f4\n+\3+\7+\u02f7\n+\f+\16+\u02fa")
        buf.write("\13+\3,\3,\5,\u02fe\n,\3,\3,\3-\3-\5-\u0304\n-\3-\3-\5")
        buf.write("-\u0308\n-\5-\u030a\n-\3-\3-\5-\u030e\n-\3-\3-\5-\u0312")
        buf.write("\n-\5-\u0314\n-\5-\u0316\n-\3.\3.\3/\3/\3\60\3\60\3\61")
        buf.write("\3\61\3\61\3\61\3\61\7\61\u0323\n\61\f\61\16\61\u0326")
        buf.write("\13\61\3\62\3\62\3\62\3\62\3\62\7\62\u032d\n\62\f\62\16")
        buf.write("\62\u0330\13\62\3\63\3\63\3\63\3\63\3\63\7\63\u0337\n")
        buf.write("\63\f\63\16\63\u033a\13\63\3\64\3\64\5\64\u033e\n\64\7")
        buf.write("\64\u0340\n\64\f\64\16\64\u0343\13\64\3\64\3\64\3\65\3")
        buf.write("\65\5\65\u0349\n\65\3\65\7\65\u034c\n\65\f\65\16\65\u034f")
        buf.write("\13\65\3\66\3\66\5\66\u0353\n\66\3\66\3\66\5\66\u0357")
        buf.write("\n\66\3\66\3\66\5\66\u035b\n\66\3\66\3\66\5\66\u035f\n")
        buf.write("\66\3\66\7\66\u0362\n\66\f\66\16\66\u0365\13\66\3\67\3")
        buf.write("\67\5\67\u0369\n\67\3\67\3\67\5\67\u036d\n\67\3\67\3\67")
        buf.write("\5\67\u0371\n\67\3\67\3\67\5\67\u0375\n\67\3\67\3\67\5")
        buf.write("\67\u0379\n\67\3\67\3\67\5\67\u037d\n\67\3\67\7\67\u0380")
        buf.write("\n\67\f\67\16\67\u0383\13\67\38\38\58\u0387\n8\38\38\5")
        buf.write("8\u038b\n8\38\78\u038e\n8\f8\168\u0391\138\39\39\59\u0395")
        buf.write("\n9\79\u0397\n9\f9\169\u039a\139\39\39\3:\3:\5:\u03a0")
        buf.write("\n:\3:\3:\3:\3:\3:\5:\u03a7\n:\3:\3:\5:\u03ab\n:\3:\3")
        buf.write(":\5:\u03af\n:\3:\3:\5:\u03b3\n:\3:\3:\3:\3:\3:\3:\3:\3")
        buf.write(":\3:\3:\3:\3:\3:\5:\u03c2\n:\3:\5:\u03c5\n:\3:\3:\3:\3")
        buf.write(":\3:\3:\3:\3:\3:\3:\3:\7:\u03d2\n:\f:\16:\u03d5\13:\3")
        buf.write(";\3;\5;\u03d9\n;\3;\3;\5;\u03dd\n;\7;\u03df\n;\f;\16;")
        buf.write("\u03e2\13;\3<\3<\3<\3<\3<\5<\u03e9\n<\3<\3<\5<\u03ed\n")
        buf.write("<\3<\3<\5<\u03f1\n<\3<\3<\3<\3<\3<\5<\u03f8\n<\3<\3<\5")
        buf.write("<\u03fc\n<\3<\3<\5<\u0400\n<\3<\3<\3<\3<\5<\u0406\n<\3")
        buf.write("<\3<\5<\u040a\n<\3<\3<\5<\u040e\n<\3<\5<\u0411\n<\3<\3")
        buf.write("<\5<\u0415\n<\3<\3<\3<\3<\5<\u041b\n<\3<\3<\5<\u041f\n")
        buf.write("<\3<\3<\5<\u0423\n<\3<\3<\3<\3<\5<\u0429\n<\3<\3<\5<\u042d")
        buf.write("\n<\3<\3<\5<\u0431\n<\3<\3<\3<\3<\5<\u0437\n<\3<\3<\5")
        buf.write("<\u043b\n<\3<\3<\5<\u043f\n<\3<\3<\3<\3<\5<\u0445\n<\3")
        buf.write("<\3<\5<\u0449\n<\3<\3<\5<\u044d\n<\3<\3<\3<\3<\3<\3<\5")
        buf.write("<\u0455\n<\3=\3=\3=\3=\3=\3=\5=\u045d\n=\3>\3>\3?\3?\5")
        buf.write("?\u0463\n?\3?\3?\5?\u0467\n?\3?\3?\5?\u046b\n?\3?\3?\5")
        buf.write("?\u046f\n?\7?\u0471\n?\f?\16?\u0474\13?\5?\u0476\n?\3")
        buf.write("?\3?\3@\3@\5@\u047c\n@\3@\3@\3@\5@\u0481\n@\3@\3@\3@\5")
        buf.write("@\u0486\n@\3@\3@\3@\5@\u048b\n@\3@\3@\3@\5@\u0490\n@\3")
        buf.write("@\3@\3@\5@\u0495\n@\3@\5@\u0498\n@\3A\3A\5A\u049c\nA\3")
        buf.write("A\3A\5A\u04a0\nA\3A\3A\3B\3B\5B\u04a6\nB\3B\6B\u04a9\n")
        buf.write("B\rB\16B\u04aa\3C\3C\5C\u04af\nC\3C\5C\u04b2\nC\3D\3D")
        buf.write("\3D\3D\3D\3D\3E\3E\5E\u04bc\nE\3E\3E\5E\u04c0\nE\3E\3")
        buf.write("E\5E\u04c4\nE\5E\u04c6\nE\3E\3E\5E\u04ca\nE\3E\3E\5E\u04ce")
        buf.write("\nE\3E\3E\5E\u04d2\nE\7E\u04d4\nE\fE\16E\u04d7\13E\5E")
        buf.write("\u04d9\nE\3E\3E\3F\3F\5F\u04df\nF\3G\3G\5G\u04e3\nG\3")
        buf.write("G\3G\5G\u04e7\nG\3G\3G\5G\u04eb\nG\3G\3G\5G\u04ef\nG\3")
        buf.write("G\3G\5G\u04f3\nG\7G\u04f5\nG\fG\16G\u04f8\13G\5G\u04fa")
        buf.write("\nG\3G\3G\3H\3H\3I\3I\3J\3J\3K\3K\5K\u0506\nK\3K\3K\5")
        buf.write("K\u050a\nK\3K\3K\5K\u050e\nK\3K\5K\u0511\nK\3K\5K\u0514")
        buf.write("\nK\3K\3K\3L\3L\5L\u051a\nL\3L\3L\5L\u051e\nL\3L\3L\5")
        buf.write("L\u0522\nL\5L\u0524\nL\3L\3L\5L\u0528\nL\3L\3L\5L\u052c")
        buf.write("\nL\3L\3L\5L\u0530\nL\5L\u0532\nL\3L\3L\5L\u0536\nL\3")
        buf.write("L\3L\5L\u053a\nL\3L\3L\3M\3M\5M\u0540\nM\3M\3M\3N\3N\5")
        buf.write("N\u0546\nN\3N\6N\u0549\nN\rN\16N\u054a\3N\3N\5N\u054f")
        buf.write("\nN\3N\3N\5N\u0553\nN\3N\6N\u0556\nN\rN\16N\u0557\5N\u055a")
        buf.write("\nN\3N\5N\u055d\nN\3N\3N\5N\u0561\nN\3N\5N\u0564\nN\3")
        buf.write("N\5N\u0567\nN\3N\3N\3O\3O\5O\u056d\nO\3O\3O\5O\u0571\n")
        buf.write("O\3O\3O\5O\u0575\nO\3O\3O\3P\3P\3Q\3Q\5Q\u057d\nQ\3R\3")
        buf.write("R\5R\u0581\nR\3R\3R\5R\u0585\nR\3R\3R\5R\u0589\nR\3R\3")
        buf.write("R\5R\u058d\nR\3R\3R\5R\u0591\nR\3R\3R\5R\u0595\nR\3R\3")
        buf.write("R\5R\u0599\nR\3R\3R\5R\u059d\nR\7R\u059f\nR\fR\16R\u05a2")
        buf.write("\13R\5R\u05a4\nR\3R\3R\3S\3S\3S\5S\u05ab\nS\3T\3T\5T\u05af")
        buf.write("\nT\3T\6T\u05b2\nT\rT\16T\u05b3\3U\3U\3V\3V\3W\3W\3X\3")
        buf.write("X\5X\u05be\nX\3Y\3Y\3Z\3Z\3[\3[\3\\\3\\\3]\3]\3]\2\2^")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082")
        buf.write("\u0084\u0086\u0088\u008a\u008c\u008e\u0090\u0092\u0094")
        buf.write("\u0096\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6")
        buf.write("\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8")
        buf.write("\2\t\3\2\64\67\4\2\7\7\20\20\3\2IJ\3\2SU\3\2]^\6\2\36")
        buf.write("*-BIP_c\7\2\37\37CHVVddgg\2\u06a6\2\u00bb\3\2\2\2\4\u00c7")
        buf.write("\3\2\2\2\6\u00cb\3\2\2\2\b\u00cd\3\2\2\2\n\u00d7\3\2\2")
        buf.write("\2\f\u00ed\3\2\2\2\16\u00f9\3\2\2\2\20\u00fd\3\2\2\2\22")
        buf.write("\u010a\3\2\2\2\24\u0114\3\2\2\2\26\u012a\3\2\2\2\30\u012c")
        buf.write("\3\2\2\2\32\u0132\3\2\2\2\34\u0162\3\2\2\2\36\u0166\3")
        buf.write("\2\2\2 \u017a\3\2\2\2\"\u018e\3\2\2\2$\u0190\3\2\2\2&")
        buf.write("\u019b\3\2\2\2(\u01b6\3\2\2\2*\u01bd\3\2\2\2,\u01c1\3")
        buf.write("\2\2\2.\u01d0\3\2\2\2\60\u01da\3\2\2\2\62\u0203\3\2\2")
        buf.write("\2\64\u020c\3\2\2\2\66\u020e\3\2\2\28\u021d\3\2\2\2:\u0221")
        buf.write("\3\2\2\2<\u0225\3\2\2\2>\u022c\3\2\2\2@\u0230\3\2\2\2")
        buf.write("B\u0249\3\2\2\2D\u024b\3\2\2\2F\u025b\3\2\2\2H\u025d\3")
        buf.write("\2\2\2J\u0275\3\2\2\2L\u02bb\3\2\2\2N\u02bd\3\2\2\2P\u02da")
        buf.write("\3\2\2\2R\u02dc\3\2\2\2T\u02f1\3\2\2\2V\u02fb\3\2\2\2")
        buf.write("X\u0301\3\2\2\2Z\u0317\3\2\2\2\\\u0319\3\2\2\2^\u031b")
        buf.write("\3\2\2\2`\u031d\3\2\2\2b\u0327\3\2\2\2d\u0331\3\2\2\2")
        buf.write("f\u0341\3\2\2\2h\u0346\3\2\2\2j\u0350\3\2\2\2l\u0366\3")
        buf.write("\2\2\2n\u0384\3\2\2\2p\u0398\3\2\2\2r\u039d\3\2\2\2t\u03d6")
        buf.write("\3\2\2\2v\u0454\3\2\2\2x\u045c\3\2\2\2z\u045e\3\2\2\2")
        buf.write("|\u0460\3\2\2\2~\u0497\3\2\2\2\u0080\u0499\3\2\2\2\u0082")
        buf.write("\u04a3\3\2\2\2\u0084\u04ac\3\2\2\2\u0086\u04b3\3\2\2\2")
        buf.write("\u0088\u04b9\3\2\2\2\u008a\u04de\3\2\2\2\u008c\u04e0\3")
        buf.write("\2\2\2\u008e\u04fd\3\2\2\2\u0090\u04ff\3\2\2\2\u0092\u0501")
        buf.write("\3\2\2\2\u0094\u0503\3\2\2\2\u0096\u0517\3\2\2\2\u0098")
        buf.write("\u053d\3\2\2\2\u009a\u0559\3\2\2\2\u009c\u056a\3\2\2\2")
        buf.write("\u009e\u0578\3\2\2\2\u00a0\u057c\3\2\2\2\u00a2\u057e\3")
        buf.write("\2\2\2\u00a4\u05a7\3\2\2\2\u00a6\u05ac\3\2\2\2\u00a8\u05b5")
        buf.write("\3\2\2\2\u00aa\u05b7\3\2\2\2\u00ac\u05b9\3\2\2\2\u00ae")
        buf.write("\u05bd\3\2\2\2\u00b0\u05bf\3\2\2\2\u00b2\u05c1\3\2\2\2")
        buf.write("\u00b4\u05c3\3\2\2\2\u00b6\u05c5\3\2\2\2\u00b8\u05c7\3")
        buf.write("\2\2\2\u00ba\u00bc\7h\2\2\u00bb\u00ba\3\2\2\2\u00bb\u00bc")
        buf.write("\3\2\2\2\u00bc\u00bd\3\2\2\2\u00bd\u00c2\5\4\3\2\u00be")
        buf.write("\u00c0\7h\2\2\u00bf\u00be\3\2\2\2\u00bf\u00c0\3\2\2\2")
        buf.write("\u00c0\u00c1\3\2\2\2\u00c1\u00c3\7\3\2\2\u00c2\u00bf\3")
        buf.write("\2\2\2\u00c2\u00c3\3\2\2\2\u00c3\u00c5\3\2\2\2\u00c4\u00c6")
        buf.write("\7h\2\2\u00c5\u00c4\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6")
        buf.write("\3\3\2\2\2\u00c7\u00c8\5\6\4\2\u00c8\5\3\2\2\2\u00c9\u00cc")
        buf.write("\5\b\5\2\u00ca\u00cc\5&\24\2\u00cb\u00c9\3\2\2\2\u00cb")
        buf.write("\u00ca\3\2\2\2\u00cc\7\3\2\2\2\u00cd\u00d4\5\n\6\2\u00ce")
        buf.write("\u00d0\7h\2\2\u00cf\u00ce\3\2\2\2\u00cf\u00d0\3\2\2\2")
        buf.write("\u00d0\u00d1\3\2\2\2\u00d1\u00d3\5\f\7\2\u00d2\u00cf\3")
        buf.write("\2\2\2\u00d3\u00d6\3\2\2\2\u00d4\u00d2\3\2\2\2\u00d4\u00d5")
        buf.write("\3\2\2\2\u00d5\t\3\2\2\2\u00d6\u00d4\3\2\2\2\u00d7\u00de")
        buf.write("\5\16\b\2\u00d8\u00da\7h\2\2\u00d9\u00d8\3\2\2\2\u00d9")
        buf.write("\u00da\3\2\2\2\u00da\u00db\3\2\2\2\u00db\u00dd\5\16\b")
        buf.write("\2\u00dc\u00d9\3\2\2\2\u00dd\u00e0\3\2\2\2\u00de\u00dc")
        buf.write("\3\2\2\2\u00de\u00df\3\2\2\2\u00df\13\3\2\2\2\u00e0\u00de")
        buf.write("\3\2\2\2\u00e1\u00e2\7\36\2\2\u00e2\u00e3\7h\2\2\u00e3")
        buf.write("\u00e5\7\37\2\2\u00e4\u00e6\7h\2\2\u00e5\u00e4\3\2\2\2")
        buf.write("\u00e5\u00e6\3\2\2\2\u00e6\u00e7\3\2\2\2\u00e7\u00ee\5")
        buf.write("\n\6\2\u00e8\u00ea\7\36\2\2\u00e9\u00eb\7h\2\2\u00ea\u00e9")
        buf.write("\3\2\2\2\u00ea\u00eb\3\2\2\2\u00eb\u00ec\3\2\2\2\u00ec")
        buf.write("\u00ee\5\n\6\2\u00ed\u00e1\3\2\2\2\u00ed\u00e8\3\2\2\2")
        buf.write("\u00ee\r\3\2\2\2\u00ef\u00fa\5\20\t\2\u00f0\u00fa\5\22")
        buf.write("\n\2\u00f1\u00fa\5\24\13\2\u00f2\u00fa\5\30\r\2\u00f3")
        buf.write("\u00fa\5\32\16\2\u00f4\u00fa\5\36\20\2\u00f5\u00fa\5 ")
        buf.write("\21\2\u00f6\u00fa\5$\23\2\u00f7\u00fa\5,\27\2\u00f8\u00fa")
        buf.write("\5.\30\2\u00f9\u00ef\3\2\2\2\u00f9\u00f0\3\2\2\2\u00f9")
        buf.write("\u00f1\3\2\2\2\u00f9\u00f2\3\2\2\2\u00f9\u00f3\3\2\2\2")
        buf.write("\u00f9\u00f4\3\2\2\2\u00f9\u00f5\3\2\2\2\u00f9\u00f6\3")
        buf.write("\2\2\2\u00f9\u00f7\3\2\2\2\u00f9\u00f8\3\2\2\2\u00fa\17")
        buf.write("\3\2\2\2\u00fb\u00fc\7 \2\2\u00fc\u00fe\7h\2\2\u00fd\u00fb")
        buf.write("\3\2\2\2\u00fd\u00fe\3\2\2\2\u00fe\u00ff\3\2\2\2\u00ff")
        buf.write("\u0101\7!\2\2\u0100\u0102\7h\2\2\u0101\u0100\3\2\2\2\u0101")
        buf.write("\u0102\3\2\2\2\u0102\u0103\3\2\2\2\u0103\u0108\5@!\2\u0104")
        buf.write("\u0106\7h\2\2\u0105\u0104\3\2\2\2\u0105\u0106\3\2\2\2")
        buf.write("\u0106\u0107\3\2\2\2\u0107\u0109\5> \2\u0108\u0105\3\2")
        buf.write("\2\2\u0108\u0109\3\2\2\2\u0109\21\3\2\2\2\u010a\u010c")
        buf.write("\7\"\2\2\u010b\u010d\7h\2\2\u010c\u010b\3\2\2\2\u010c")
        buf.write("\u010d\3\2\2\2\u010d\u010e\3\2\2\2\u010e\u010f\5^\60\2")
        buf.write("\u010f\u0110\7h\2\2\u0110\u0111\7#\2\2\u0111\u0112\7h")
        buf.write("\2\2\u0112\u0113\5\u009eP\2\u0113\23\3\2\2\2\u0114\u0116")
        buf.write("\7$\2\2\u0115\u0117\7h\2\2\u0116\u0115\3\2\2\2\u0116\u0117")
        buf.write("\3\2\2\2\u0117\u0118\3\2\2\2\u0118\u011d\5B\"\2\u0119")
        buf.write("\u011a\7h\2\2\u011a\u011c\5\26\f\2\u011b\u0119\3\2\2\2")
        buf.write("\u011c\u011f\3\2\2\2\u011d\u011b\3\2\2\2\u011d\u011e\3")
        buf.write("\2\2\2\u011e\25\3\2\2\2\u011f\u011d\3\2\2\2\u0120\u0121")
        buf.write("\7%\2\2\u0121\u0122\7h\2\2\u0122\u0123\7!\2\2\u0123\u0124")
        buf.write("\7h\2\2\u0124\u012b\5\32\16\2\u0125\u0126\7%\2\2\u0126")
        buf.write("\u0127\7h\2\2\u0127\u0128\7&\2\2\u0128\u0129\7h\2\2\u0129")
        buf.write("\u012b\5\32\16\2\u012a\u0120\3\2\2\2\u012a\u0125\3\2\2")
        buf.write("\2\u012b\27\3\2\2\2\u012c\u012e\7&\2\2\u012d\u012f\7h")
        buf.write("\2\2\u012e\u012d\3\2\2\2\u012e\u012f\3\2\2\2\u012f\u0130")
        buf.write("\3\2\2\2\u0130\u0131\5@!\2\u0131\31\3\2\2\2\u0132\u0134")
        buf.write("\7\'\2\2\u0133\u0135\7h\2\2\u0134\u0133\3\2\2\2\u0134")
        buf.write("\u0135\3\2\2\2\u0135\u0136\3\2\2\2\u0136\u013b\5\34\17")
        buf.write("\2\u0137\u0138\7\4\2\2\u0138\u013a\5\34\17\2\u0139\u0137")
        buf.write("\3\2\2\2\u013a\u013d\3\2\2\2\u013b\u0139\3\2\2\2\u013b")
        buf.write("\u013c\3\2\2\2\u013c\33\3\2\2\2\u013d\u013b\3\2\2\2\u013e")
        buf.write("\u0140\5\u00a6T\2\u013f\u0141\7h\2\2\u0140\u013f\3\2\2")
        buf.write("\2\u0140\u0141\3\2\2\2\u0141\u0142\3\2\2\2\u0142\u0144")
        buf.write("\7\5\2\2\u0143\u0145\7h\2\2\u0144\u0143\3\2\2\2\u0144")
        buf.write("\u0145\3\2\2\2\u0145\u0146\3\2\2\2\u0146\u0147\5^\60\2")
        buf.write("\u0147\u0163\3\2\2\2\u0148\u014a\5\u009eP\2\u0149\u014b")
        buf.write("\7h\2\2\u014a\u0149\3\2\2\2\u014a\u014b\3\2\2\2\u014b")
        buf.write("\u014c\3\2\2\2\u014c\u014e\7\5\2\2\u014d\u014f\7h\2\2")
        buf.write("\u014e\u014d\3\2\2\2\u014e\u014f\3\2\2\2\u014f\u0150\3")
        buf.write("\2\2\2\u0150\u0151\5^\60\2\u0151\u0163\3\2\2\2\u0152\u0154")
        buf.write("\5\u009eP\2\u0153\u0155\7h\2\2\u0154\u0153\3\2\2\2\u0154")
        buf.write("\u0155\3\2\2\2\u0155\u0156\3\2\2\2\u0156\u0158\7\6\2\2")
        buf.write("\u0157\u0159\7h\2\2\u0158\u0157\3\2\2\2\u0158\u0159\3")
        buf.write("\2\2\2\u0159\u015a\3\2\2\2\u015a\u015b\5^\60\2\u015b\u0163")
        buf.write("\3\2\2\2\u015c\u015e\5\u009eP\2\u015d\u015f\7h\2\2\u015e")
        buf.write("\u015d\3\2\2\2\u015e\u015f\3\2\2\2\u015f\u0160\3\2\2\2")
        buf.write("\u0160\u0161\5T+\2\u0161\u0163\3\2\2\2\u0162\u013e\3\2")
        buf.write("\2\2\u0162\u0148\3\2\2\2\u0162\u0152\3\2\2\2\u0162\u015c")
        buf.write("\3\2\2\2\u0163\35\3\2\2\2\u0164\u0165\7(\2\2\u0165\u0167")
        buf.write("\7h\2\2\u0166\u0164\3\2\2\2\u0166\u0167\3\2\2\2\u0167")
        buf.write("\u0168\3\2\2\2\u0168\u016a\7)\2\2\u0169\u016b\7h\2\2\u016a")
        buf.write("\u0169\3\2\2\2\u016a\u016b\3\2\2\2\u016b\u016c\3\2\2\2")
        buf.write("\u016c\u0177\5^\60\2\u016d\u016f\7h\2\2\u016e\u016d\3")
        buf.write("\2\2\2\u016e\u016f\3\2\2\2\u016f\u0170\3\2\2\2\u0170\u0172")
        buf.write("\7\4\2\2\u0171\u0173\7h\2\2\u0172\u0171\3\2\2\2\u0172")
        buf.write("\u0173\3\2\2\2\u0173\u0174\3\2\2\2\u0174\u0176\5^\60\2")
        buf.write("\u0175\u016e\3\2\2\2\u0176\u0179\3\2\2\2\u0177\u0175\3")
        buf.write("\2\2\2\u0177\u0178\3\2\2\2\u0178\37\3\2\2\2\u0179\u0177")
        buf.write("\3\2\2\2\u017a\u017b\7*\2\2\u017b\u017c\7h\2\2\u017c\u0187")
        buf.write("\5\"\22\2\u017d\u017f\7h\2\2\u017e\u017d\3\2\2\2\u017e")
        buf.write("\u017f\3\2\2\2\u017f\u0180\3\2\2\2\u0180\u0182\7\4\2\2")
        buf.write("\u0181\u0183\7h\2\2\u0182\u0181\3\2\2\2\u0182\u0183\3")
        buf.write("\2\2\2\u0183\u0184\3\2\2\2\u0184\u0186\5\"\22\2\u0185")
        buf.write("\u017e\3\2\2\2\u0186\u0189\3\2\2\2\u0187\u0185\3\2\2\2")
        buf.write("\u0187\u0188\3\2\2\2\u0188!\3\2\2\2\u0189\u0187\3\2\2")
        buf.write("\2\u018a\u018b\5\u009eP\2\u018b\u018c\5T+\2\u018c\u018f")
        buf.write("\3\2\2\2\u018d\u018f\5\u00a6T\2\u018e\u018a\3\2\2\2\u018e")
        buf.write("\u018d\3\2\2\2\u018f#\3\2\2\2\u0190\u0191\7+\2\2\u0191")
        buf.write("\u0192\7h\2\2\u0192\u0199\5\u008cG\2\u0193\u0195\7h\2")
        buf.write("\2\u0194\u0193\3\2\2\2\u0194\u0195\3\2\2\2\u0195\u0196")
        buf.write("\3\2\2\2\u0196\u0197\7,\2\2\u0197\u0198\7h\2\2\u0198\u019a")
        buf.write("\5(\25\2\u0199\u0194\3\2\2\2\u0199\u019a\3\2\2\2\u019a")
        buf.write("%\3\2\2\2\u019b\u019c\7+\2\2\u019c\u019f\7h\2\2\u019d")
        buf.write("\u01a0\5\u008cG\2\u019e\u01a0\5\u008eH\2\u019f\u019d\3")
        buf.write("\2\2\2\u019f\u019e\3\2\2\2\u01a0\u01a5\3\2\2\2\u01a1\u01a2")
        buf.write("\7h\2\2\u01a2\u01a3\7,\2\2\u01a3\u01a4\7h\2\2\u01a4\u01a6")
        buf.write("\5(\25\2\u01a5\u01a1\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6")
        buf.write("\'\3\2\2\2\u01a7\u01b2\5*\26\2\u01a8\u01aa\7h\2\2\u01a9")
        buf.write("\u01a8\3\2\2\2\u01a9\u01aa\3\2\2\2\u01aa\u01ab\3\2\2\2")
        buf.write("\u01ab\u01ad\7\4\2\2\u01ac\u01ae\7h\2\2\u01ad\u01ac\3")
        buf.write("\2\2\2\u01ad\u01ae\3\2\2\2\u01ae\u01af\3\2\2\2\u01af\u01b1")
        buf.write("\5*\26\2\u01b0\u01a9\3\2\2\2\u01b1\u01b4\3\2\2\2\u01b2")
        buf.write("\u01b0\3\2\2\2\u01b2\u01b3\3\2\2\2\u01b3\u01b7\3\2\2\2")
        buf.write("\u01b4\u01b2\3\2\2\2\u01b5\u01b7\7\7\2\2\u01b6\u01a7\3")
        buf.write("\2\2\2\u01b6\u01b5\3\2\2\2\u01b7)\3\2\2\2\u01b8\u01b9")
        buf.write("\5\u0090I\2\u01b9\u01ba\7h\2\2\u01ba\u01bb\7#\2\2\u01bb")
        buf.write("\u01bc\7h\2\2\u01bc\u01be\3\2\2\2\u01bd\u01b8\3\2\2\2")
        buf.write("\u01bd\u01be\3\2\2\2\u01be\u01bf\3\2\2\2\u01bf\u01c0\5")
        buf.write("\u009eP\2\u01c0+\3\2\2\2\u01c1\u01c6\7-\2\2\u01c2\u01c4")
        buf.write("\7h\2\2\u01c3\u01c2\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4")
        buf.write("\u01c5\3\2\2\2\u01c5\u01c7\7.\2\2\u01c6\u01c3\3\2\2\2")
        buf.write("\u01c6\u01c7\3\2\2\2\u01c7\u01c8\3\2\2\2\u01c8\u01c9\7")
        buf.write("h\2\2\u01c9\u01ce\5\60\31\2\u01ca\u01cc\7h\2\2\u01cb\u01ca")
        buf.write("\3\2\2\2\u01cb\u01cc\3\2\2\2\u01cc\u01cd\3\2\2\2\u01cd")
        buf.write("\u01cf\5> \2\u01ce\u01cb\3\2\2\2\u01ce\u01cf\3\2\2\2\u01cf")
        buf.write("-\3\2\2\2\u01d0\u01d5\7/\2\2\u01d1\u01d3\7h\2\2\u01d2")
        buf.write("\u01d1\3\2\2\2\u01d2\u01d3\3\2\2\2\u01d3\u01d4\3\2\2\2")
        buf.write("\u01d4\u01d6\7.\2\2\u01d5\u01d2\3\2\2\2\u01d5\u01d6\3")
        buf.write("\2\2\2\u01d6\u01d7\3\2\2\2\u01d7\u01d8\7h\2\2\u01d8\u01d9")
        buf.write("\5\60\31\2\u01d9/\3\2\2\2\u01da\u01dd\5\62\32\2\u01db")
        buf.write("\u01dc\7h\2\2\u01dc\u01de\5\66\34\2\u01dd\u01db\3\2\2")
        buf.write("\2\u01dd\u01de\3\2\2\2\u01de\u01e1\3\2\2\2\u01df\u01e0")
        buf.write("\7h\2\2\u01e0\u01e2\58\35\2\u01e1\u01df\3\2\2\2\u01e1")
        buf.write("\u01e2\3\2\2\2\u01e2\u01e5\3\2\2\2\u01e3\u01e4\7h\2\2")
        buf.write("\u01e4\u01e6\5:\36\2\u01e5\u01e3\3\2\2\2\u01e5\u01e6\3")
        buf.write("\2\2\2\u01e6\61\3\2\2\2\u01e7\u01f2\7\b\2\2\u01e8\u01ea")
        buf.write("\7h\2\2\u01e9\u01e8\3\2\2\2\u01e9\u01ea\3\2\2\2\u01ea")
        buf.write("\u01eb\3\2\2\2\u01eb\u01ed\7\4\2\2\u01ec\u01ee\7h\2\2")
        buf.write("\u01ed\u01ec\3\2\2\2\u01ed\u01ee\3\2\2\2\u01ee\u01ef\3")
        buf.write("\2\2\2\u01ef\u01f1\5\64\33\2\u01f0\u01e9\3\2\2\2\u01f1")
        buf.write("\u01f4\3\2\2\2\u01f2\u01f0\3\2\2\2\u01f2\u01f3\3\2\2\2")
        buf.write("\u01f3\u0204\3\2\2\2\u01f4\u01f2\3\2\2\2\u01f5\u0200\5")
        buf.write("\64\33\2\u01f6\u01f8\7h\2\2\u01f7\u01f6\3\2\2\2\u01f7")
        buf.write("\u01f8\3\2\2\2\u01f8\u01f9\3\2\2\2\u01f9\u01fb\7\4\2\2")
        buf.write("\u01fa\u01fc\7h\2\2\u01fb\u01fa\3\2\2\2\u01fb\u01fc\3")
        buf.write("\2\2\2\u01fc\u01fd\3\2\2\2\u01fd\u01ff\5\64\33\2\u01fe")
        buf.write("\u01f7\3\2\2\2\u01ff\u0202\3\2\2\2\u0200\u01fe\3\2\2\2")
        buf.write("\u0200\u0201\3\2\2\2\u0201\u0204\3\2\2\2\u0202\u0200\3")
        buf.write("\2\2\2\u0203\u01e7\3\2\2\2\u0203\u01f5\3\2\2\2\u0204\63")
        buf.write("\3\2\2\2\u0205\u0206\5^\60\2\u0206\u0207\7h\2\2\u0207")
        buf.write("\u0208\7#\2\2\u0208\u0209\7h\2\2\u0209\u020a\5\u009eP")
        buf.write("\2\u020a\u020d\3\2\2\2\u020b\u020d\5^\60\2\u020c\u0205")
        buf.write("\3\2\2\2\u020c\u020b\3\2\2\2\u020d\65\3\2\2\2\u020e\u020f")
        buf.write("\7\60\2\2\u020f\u0210\7h\2\2\u0210\u0211\7\61\2\2\u0211")
        buf.write("\u0212\7h\2\2\u0212\u021a\5<\37\2\u0213\u0215\7\4\2\2")
        buf.write("\u0214\u0216\7h\2\2\u0215\u0214\3\2\2\2\u0215\u0216\3")
        buf.write("\2\2\2\u0216\u0217\3\2\2\2\u0217\u0219\5<\37\2\u0218\u0213")
        buf.write("\3\2\2\2\u0219\u021c\3\2\2\2\u021a\u0218\3\2\2\2\u021a")
        buf.write("\u021b\3\2\2\2\u021b\67\3\2\2\2\u021c\u021a\3\2\2\2\u021d")
        buf.write("\u021e\7\62\2\2\u021e\u021f\7h\2\2\u021f\u0220\5^\60\2")
        buf.write("\u02209\3\2\2\2\u0221\u0222\7\63\2\2\u0222\u0223\7h\2")
        buf.write("\2\u0223\u0224\5^\60\2\u0224;\3\2\2\2\u0225\u022a\5^\60")
        buf.write("\2\u0226\u0228\7h\2\2\u0227\u0226\3\2\2\2\u0227\u0228")
        buf.write("\3\2\2\2\u0228\u0229\3\2\2\2\u0229\u022b\t\2\2\2\u022a")
        buf.write("\u0227\3\2\2\2\u022a\u022b\3\2\2\2\u022b=\3\2\2\2\u022c")
        buf.write("\u022d\78\2\2\u022d\u022e\7h\2\2\u022e\u022f\5^\60\2\u022f")
        buf.write("?\3\2\2\2\u0230\u023b\5B\"\2\u0231\u0233\7h\2\2\u0232")
        buf.write("\u0231\3\2\2\2\u0232\u0233\3\2\2\2\u0233\u0234\3\2\2\2")
        buf.write("\u0234\u0236\7\4\2\2\u0235\u0237\7h\2\2\u0236\u0235\3")
        buf.write("\2\2\2\u0236\u0237\3\2\2\2\u0237\u0238\3\2\2\2\u0238\u023a")
        buf.write("\5B\"\2\u0239\u0232\3\2\2\2\u023a\u023d\3\2\2\2\u023b")
        buf.write("\u0239\3\2\2\2\u023b\u023c\3\2\2\2\u023cA\3\2\2\2\u023d")
        buf.write("\u023b\3\2\2\2\u023e\u0240\5\u009eP\2\u023f\u0241\7h\2")
        buf.write("\2\u0240\u023f\3\2\2\2\u0240\u0241\3\2\2\2\u0241\u0242")
        buf.write("\3\2\2\2\u0242\u0244\7\5\2\2\u0243\u0245\7h\2\2\u0244")
        buf.write("\u0243\3\2\2\2\u0244\u0245\3\2\2\2\u0245\u0246\3\2\2\2")
        buf.write("\u0246\u0247\5D#\2\u0247\u024a\3\2\2\2\u0248\u024a\5D")
        buf.write("#\2\u0249\u023e\3\2\2\2\u0249\u0248\3\2\2\2\u024aC\3\2")
        buf.write("\2\2\u024b\u024c\5F$\2\u024cE\3\2\2\2\u024d\u0254\5H%")
        buf.write("\2\u024e\u0250\7h\2\2\u024f\u024e\3\2\2\2\u024f\u0250")
        buf.write("\3\2\2\2\u0250\u0251\3\2\2\2\u0251\u0253\5J&\2\u0252\u024f")
        buf.write("\3\2\2\2\u0253\u0256\3\2\2\2\u0254\u0252\3\2\2\2\u0254")
        buf.write("\u0255\3\2\2\2\u0255\u025c\3\2\2\2\u0256\u0254\3\2\2\2")
        buf.write("\u0257\u0258\7\t\2\2\u0258\u0259\5F$\2\u0259\u025a\7\n")
        buf.write("\2\2\u025a\u025c\3\2\2\2\u025b\u024d\3\2\2\2\u025b\u0257")
        buf.write("\3\2\2\2\u025cG\3\2\2\2\u025d\u025f\7\t\2\2\u025e\u0260")
        buf.write("\7h\2\2\u025f\u025e\3\2\2\2\u025f\u0260\3\2\2\2\u0260")
        buf.write("\u0265\3\2\2\2\u0261\u0263\5\u009eP\2\u0262\u0264\7h\2")
        buf.write("\2\u0263\u0262\3\2\2\2\u0263\u0264\3\2\2\2\u0264\u0266")
        buf.write("\3\2\2\2\u0265\u0261\3\2\2\2\u0265\u0266\3\2\2\2\u0266")
        buf.write("\u026b\3\2\2\2\u0267\u0269\5T+\2\u0268\u026a\7h\2\2\u0269")
        buf.write("\u0268\3\2\2\2\u0269\u026a\3\2\2\2\u026a\u026c\3\2\2\2")
        buf.write("\u026b\u0267\3\2\2\2\u026b\u026c\3\2\2\2\u026c\u0271\3")
        buf.write("\2\2\2\u026d\u026f\5P)\2\u026e\u0270\7h\2\2\u026f\u026e")
        buf.write("\3\2\2\2\u026f\u0270\3\2\2\2\u0270\u0272\3\2\2\2\u0271")
        buf.write("\u026d\3\2\2\2\u0271\u0272\3\2\2\2\u0272\u0273\3\2\2\2")
        buf.write("\u0273\u0274\7\n\2\2\u0274I\3\2\2\2\u0275\u0277\5L\'\2")
        buf.write("\u0276\u0278\7h\2\2\u0277\u0276\3\2\2\2\u0277\u0278\3")
        buf.write("\2\2\2\u0278\u0279\3\2\2\2\u0279\u027a\5H%\2\u027aK\3")
        buf.write("\2\2\2\u027b\u027d\5\u00b4[\2\u027c\u027e\7h\2\2\u027d")
        buf.write("\u027c\3\2\2\2\u027d\u027e\3\2\2\2\u027e\u027f\3\2\2\2")
        buf.write("\u027f\u0281\5\u00b8]\2\u0280\u0282\7h\2\2\u0281\u0280")
        buf.write("\3\2\2\2\u0281\u0282\3\2\2\2\u0282\u0284\3\2\2\2\u0283")
        buf.write("\u0285\5N(\2\u0284\u0283\3\2\2\2\u0284\u0285\3\2\2\2\u0285")
        buf.write("\u0287\3\2\2\2\u0286\u0288\7h\2\2\u0287\u0286\3\2\2\2")
        buf.write("\u0287\u0288\3\2\2\2\u0288\u0289\3\2\2\2\u0289\u028b\5")
        buf.write("\u00b8]\2\u028a\u028c\7h\2\2\u028b\u028a\3\2\2\2\u028b")
        buf.write("\u028c\3\2\2\2\u028c\u028d\3\2\2\2\u028d\u028e\5\u00b6")
        buf.write("\\\2\u028e\u02bc\3\2\2\2\u028f\u0291\5\u00b4[\2\u0290")
        buf.write("\u0292\7h\2\2\u0291\u0290\3\2\2\2\u0291\u0292\3\2\2\2")
        buf.write("\u0292\u0293\3\2\2\2\u0293\u0295\5\u00b8]\2\u0294\u0296")
        buf.write("\7h\2\2\u0295\u0294\3\2\2\2\u0295\u0296\3\2\2\2\u0296")
        buf.write("\u0298\3\2\2\2\u0297\u0299\5N(\2\u0298\u0297\3\2\2\2\u0298")
        buf.write("\u0299\3\2\2\2\u0299\u029b\3\2\2\2\u029a\u029c\7h\2\2")
        buf.write("\u029b\u029a\3\2\2\2\u029b\u029c\3\2\2\2\u029c\u029d\3")
        buf.write("\2\2\2\u029d\u029e\5\u00b8]\2\u029e\u02bc\3\2\2\2\u029f")
        buf.write("\u02a1\5\u00b8]\2\u02a0\u02a2\7h\2\2\u02a1\u02a0\3\2\2")
        buf.write("\2\u02a1\u02a2\3\2\2\2\u02a2\u02a4\3\2\2\2\u02a3\u02a5")
        buf.write("\5N(\2\u02a4\u02a3\3\2\2\2\u02a4\u02a5\3\2\2\2\u02a5\u02a7")
        buf.write("\3\2\2\2\u02a6\u02a8\7h\2\2\u02a7\u02a6\3\2\2\2\u02a7")
        buf.write("\u02a8\3\2\2\2\u02a8\u02a9\3\2\2\2\u02a9\u02ab\5\u00b8")
        buf.write("]\2\u02aa\u02ac\7h\2\2\u02ab\u02aa\3\2\2\2\u02ab\u02ac")
        buf.write("\3\2\2\2\u02ac\u02ad\3\2\2\2\u02ad\u02ae\5\u00b6\\\2\u02ae")
        buf.write("\u02bc\3\2\2\2\u02af\u02b1\5\u00b8]\2\u02b0\u02b2\7h\2")
        buf.write("\2\u02b1\u02b0\3\2\2\2\u02b1\u02b2\3\2\2\2\u02b2\u02b4")
        buf.write("\3\2\2\2\u02b3\u02b5\5N(\2\u02b4\u02b3\3\2\2\2\u02b4\u02b5")
        buf.write("\3\2\2\2\u02b5\u02b7\3\2\2\2\u02b6\u02b8\7h\2\2\u02b7")
        buf.write("\u02b6\3\2\2\2\u02b7\u02b8\3\2\2\2\u02b8\u02b9\3\2\2\2")
        buf.write("\u02b9\u02ba\5\u00b8]\2\u02ba\u02bc\3\2\2\2\u02bb\u027b")
        buf.write("\3\2\2\2\u02bb\u028f\3\2\2\2\u02bb\u029f\3\2\2\2\u02bb")
        buf.write("\u02af\3\2\2\2\u02bcM\3\2\2\2\u02bd\u02bf\7\13\2\2\u02be")
        buf.write("\u02c0\7h\2\2\u02bf\u02be\3\2\2\2\u02bf\u02c0\3\2\2\2")
        buf.write("\u02c0\u02c5\3\2\2\2\u02c1\u02c3\5\u009eP\2\u02c2\u02c4")
        buf.write("\7h\2\2\u02c3\u02c2\3\2\2\2\u02c3\u02c4\3\2\2\2\u02c4")
        buf.write("\u02c6\3\2\2\2\u02c5\u02c1\3\2\2\2\u02c5\u02c6\3\2\2\2")
        buf.write("\u02c6\u02cb\3\2\2\2\u02c7\u02c9\5R*\2\u02c8\u02ca\7h")
        buf.write("\2\2\u02c9\u02c8\3\2\2\2\u02c9\u02ca\3\2\2\2\u02ca\u02cc")
        buf.write("\3\2\2\2\u02cb\u02c7\3\2\2\2\u02cb\u02cc\3\2\2\2\u02cc")
        buf.write("\u02ce\3\2\2\2\u02cd\u02cf\5X-\2\u02ce\u02cd\3\2\2\2\u02ce")
        buf.write("\u02cf\3\2\2\2\u02cf\u02d4\3\2\2\2\u02d0\u02d2\5P)\2\u02d1")
        buf.write("\u02d3\7h\2\2\u02d2\u02d1\3\2\2\2\u02d2\u02d3\3\2\2\2")
        buf.write("\u02d3\u02d5\3\2\2\2\u02d4\u02d0\3\2\2\2\u02d4\u02d5\3")
        buf.write("\2\2\2\u02d5\u02d6\3\2\2\2\u02d6\u02d7\7\f\2\2\u02d7O")
        buf.write("\3\2\2\2\u02d8\u02db\5\u00a2R\2\u02d9\u02db\5\u00a4S\2")
        buf.write("\u02da\u02d8\3\2\2\2\u02da\u02d9\3\2\2\2\u02dbQ\3\2\2")
        buf.write("\2\u02dc\u02de\7\r\2\2\u02dd\u02df\7h\2\2\u02de\u02dd")
        buf.write("\3\2\2\2\u02de\u02df\3\2\2\2\u02df\u02e0\3\2\2\2\u02e0")
        buf.write("\u02ee\5\\/\2\u02e1\u02e3\7h\2\2\u02e2\u02e1\3\2\2\2\u02e2")
        buf.write("\u02e3\3\2\2\2\u02e3\u02e4\3\2\2\2\u02e4\u02e6\7\16\2")
        buf.write("\2\u02e5\u02e7\7\r\2\2\u02e6\u02e5\3\2\2\2\u02e6\u02e7")
        buf.write("\3\2\2\2\u02e7\u02e9\3\2\2\2\u02e8\u02ea\7h\2\2\u02e9")
        buf.write("\u02e8\3\2\2\2\u02e9\u02ea\3\2\2\2\u02ea\u02eb\3\2\2\2")
        buf.write("\u02eb\u02ed\5\\/\2\u02ec\u02e2\3\2\2\2\u02ed\u02f0\3")
        buf.write("\2\2\2\u02ee\u02ec\3\2\2\2\u02ee\u02ef\3\2\2\2\u02efS")
        buf.write("\3\2\2\2\u02f0\u02ee\3\2\2\2\u02f1\u02f8\5V,\2\u02f2\u02f4")
        buf.write("\7h\2\2\u02f3\u02f2\3\2\2\2\u02f3\u02f4\3\2\2\2\u02f4")
        buf.write("\u02f5\3\2\2\2\u02f5\u02f7\5V,\2\u02f6\u02f3\3\2\2\2\u02f7")
        buf.write("\u02fa\3\2\2\2\u02f8\u02f6\3\2\2\2\u02f8\u02f9\3\2\2\2")
        buf.write("\u02f9U\3\2\2\2\u02fa\u02f8\3\2\2\2\u02fb\u02fd\7\r\2")
        buf.write("\2\u02fc\u02fe\7h\2\2\u02fd\u02fc\3\2\2\2\u02fd\u02fe")
        buf.write("\3\2\2\2\u02fe\u02ff\3\2\2\2\u02ff\u0300\5Z.\2\u0300W")
        buf.write("\3\2\2\2\u0301\u0303\7\b\2\2\u0302\u0304\7h\2\2\u0303")
        buf.write("\u0302\3\2\2\2\u0303\u0304\3\2\2\2\u0304\u0309\3\2\2\2")
        buf.write("\u0305\u0307\5\u00aaV\2\u0306\u0308\7h\2\2\u0307\u0306")
        buf.write("\3\2\2\2\u0307\u0308\3\2\2\2\u0308\u030a\3\2\2\2\u0309")
        buf.write("\u0305\3\2\2\2\u0309\u030a\3\2\2\2\u030a\u0315\3\2\2\2")
        buf.write("\u030b\u030d\7\17\2\2\u030c\u030e\7h\2\2\u030d\u030c\3")
        buf.write("\2\2\2\u030d\u030e\3\2\2\2\u030e\u0313\3\2\2\2\u030f\u0311")
        buf.write("\5\u00aaV\2\u0310\u0312\7h\2\2\u0311\u0310\3\2\2\2\u0311")
        buf.write("\u0312\3\2\2\2\u0312\u0314\3\2\2\2\u0313\u030f\3\2\2\2")
        buf.write("\u0313\u0314\3\2\2\2\u0314\u0316\3\2\2\2\u0315\u030b\3")
        buf.write("\2\2\2\u0315\u0316\3\2\2\2\u0316Y\3\2\2\2\u0317\u0318")
        buf.write("\5\u00aeX\2\u0318[\3\2\2\2\u0319\u031a\5\u00aeX\2\u031a")
        buf.write("]\3\2\2\2\u031b\u031c\5`\61\2\u031c_\3\2\2\2\u031d\u0324")
        buf.write("\5b\62\2\u031e\u031f\7h\2\2\u031f\u0320\79\2\2\u0320\u0321")
        buf.write("\7h\2\2\u0321\u0323\5b\62\2\u0322\u031e\3\2\2\2\u0323")
        buf.write("\u0326\3\2\2\2\u0324\u0322\3\2\2\2\u0324\u0325\3\2\2\2")
        buf.write("\u0325a\3\2\2\2\u0326\u0324\3\2\2\2\u0327\u032e\5d\63")
        buf.write("\2\u0328\u0329\7h\2\2\u0329\u032a\7:\2\2\u032a\u032b\7")
        buf.write("h\2\2\u032b\u032d\5d\63\2\u032c\u0328\3\2\2\2\u032d\u0330")
        buf.write("\3\2\2\2\u032e\u032c\3\2\2\2\u032e\u032f\3\2\2\2\u032f")
        buf.write("c\3\2\2\2\u0330\u032e\3\2\2\2\u0331\u0338\5f\64\2\u0332")
        buf.write("\u0333\7h\2\2\u0333\u0334\7;\2\2\u0334\u0335\7h\2\2\u0335")
        buf.write("\u0337\5f\64\2\u0336\u0332\3\2\2\2\u0337\u033a\3\2\2\2")
        buf.write("\u0338\u0336\3\2\2\2\u0338\u0339\3\2\2\2\u0339e\3\2\2")
        buf.write("\2\u033a\u0338\3\2\2\2\u033b\u033d\7<\2\2\u033c\u033e")
        buf.write("\7h\2\2\u033d\u033c\3\2\2\2\u033d\u033e\3\2\2\2\u033e")
        buf.write("\u0340\3\2\2\2\u033f\u033b\3\2\2\2\u0340\u0343\3\2\2\2")
        buf.write("\u0341\u033f\3\2\2\2\u0341\u0342\3\2\2\2\u0342\u0344\3")
        buf.write("\2\2\2\u0343\u0341\3\2\2\2\u0344\u0345\5h\65\2\u0345g")
        buf.write("\3\2\2\2\u0346\u034d\5j\66\2\u0347\u0349\7h\2\2\u0348")
        buf.write("\u0347\3\2\2\2\u0348\u0349\3\2\2\2\u0349\u034a\3\2\2\2")
        buf.write("\u034a\u034c\5~@\2\u034b\u0348\3\2\2\2\u034c\u034f\3\2")
        buf.write("\2\2\u034d\u034b\3\2\2\2\u034d\u034e\3\2\2\2\u034ei\3")
        buf.write("\2\2\2\u034f\u034d\3\2\2\2\u0350\u0363\5l\67\2\u0351\u0353")
        buf.write("\7h\2\2\u0352\u0351\3\2\2\2\u0352\u0353\3\2\2\2\u0353")
        buf.write("\u0354\3\2\2\2\u0354\u0356\7\20\2\2\u0355\u0357\7h\2\2")
        buf.write("\u0356\u0355\3\2\2\2\u0356\u0357\3\2\2\2\u0357\u0358\3")
        buf.write("\2\2\2\u0358\u0362\5l\67\2\u0359\u035b\7h\2\2\u035a\u0359")
        buf.write("\3\2\2\2\u035a\u035b\3\2\2\2\u035b\u035c\3\2\2\2\u035c")
        buf.write("\u035e\7\7\2\2\u035d\u035f\7h\2\2\u035e\u035d\3\2\2\2")
        buf.write("\u035e\u035f\3\2\2\2\u035f\u0360\3\2\2\2\u0360\u0362\5")
        buf.write("l\67\2\u0361\u0352\3\2\2\2\u0361\u035a\3\2\2\2\u0362\u0365")
        buf.write("\3\2\2\2\u0363\u0361\3\2\2\2\u0363\u0364\3\2\2\2\u0364")
        buf.write("k\3\2\2\2\u0365\u0363\3\2\2\2\u0366\u0381\5n8\2\u0367")
        buf.write("\u0369\7h\2\2\u0368\u0367\3\2\2\2\u0368\u0369\3\2\2\2")
        buf.write("\u0369\u036a\3\2\2\2\u036a\u036c\7\b\2\2\u036b\u036d\7")
        buf.write("h\2\2\u036c\u036b\3\2\2\2\u036c\u036d\3\2\2\2\u036d\u036e")
        buf.write("\3\2\2\2\u036e\u0380\5n8\2\u036f\u0371\7h\2\2\u0370\u036f")
        buf.write("\3\2\2\2\u0370\u0371\3\2\2\2\u0371\u0372\3\2\2\2\u0372")
        buf.write("\u0374\7\21\2\2\u0373\u0375\7h\2\2\u0374\u0373\3\2\2\2")
        buf.write("\u0374\u0375\3\2\2\2\u0375\u0376\3\2\2\2\u0376\u0380\5")
        buf.write("n8\2\u0377\u0379\7h\2\2\u0378\u0377\3\2\2\2\u0378\u0379")
        buf.write("\3\2\2\2\u0379\u037a\3\2\2\2\u037a\u037c\7\22\2\2\u037b")
        buf.write("\u037d\7h\2\2\u037c\u037b\3\2\2\2\u037c\u037d\3\2\2\2")
        buf.write("\u037d\u037e\3\2\2\2\u037e\u0380\5n8\2\u037f\u0368\3\2")
        buf.write("\2\2\u037f\u0370\3\2\2\2\u037f\u0378\3\2\2\2\u0380\u0383")
        buf.write("\3\2\2\2\u0381\u037f\3\2\2\2\u0381\u0382\3\2\2\2\u0382")
        buf.write("m\3\2\2\2\u0383\u0381\3\2\2\2\u0384\u038f\5p9\2\u0385")
        buf.write("\u0387\7h\2\2\u0386\u0385\3\2\2\2\u0386\u0387\3\2\2\2")
        buf.write("\u0387\u0388\3\2\2\2\u0388\u038a\7\23\2\2\u0389\u038b")
        buf.write("\7h\2\2\u038a\u0389\3\2\2\2\u038a\u038b\3\2\2\2\u038b")
        buf.write("\u038c\3\2\2\2\u038c\u038e\5p9\2\u038d\u0386\3\2\2\2\u038e")
        buf.write("\u0391\3\2\2\2\u038f\u038d\3\2\2\2\u038f\u0390\3\2\2\2")
        buf.write("\u0390o\3\2\2\2\u0391\u038f\3\2\2\2\u0392\u0394\t\3\2")
        buf.write("\2\u0393\u0395\7h\2\2\u0394\u0393\3\2\2\2\u0394\u0395")
        buf.write("\3\2\2\2\u0395\u0397\3\2\2\2\u0396\u0392\3\2\2\2\u0397")
        buf.write("\u039a\3\2\2\2\u0398\u0396\3\2\2\2\u0398\u0399\3\2\2\2")
        buf.write("\u0399\u039b\3\2\2\2\u039a\u0398\3\2\2\2\u039b\u039c\5")
        buf.write("r:\2\u039cq\3\2\2\2\u039d\u03d3\5t;\2\u039e\u03a0\7h\2")
        buf.write("\2\u039f\u039e\3\2\2\2\u039f\u03a0\3\2\2\2\u03a0\u03a1")
        buf.write("\3\2\2\2\u03a1\u03a2\7\13\2\2\u03a2\u03a3\5^\60\2\u03a3")
        buf.write("\u03a4\7\f\2\2\u03a4\u03d2\3\2\2\2\u03a5\u03a7\7h\2\2")
        buf.write("\u03a6\u03a5\3\2\2\2\u03a6\u03a7\3\2\2\2\u03a7\u03a8\3")
        buf.write("\2\2\2\u03a8\u03aa\7\13\2\2\u03a9\u03ab\5^\60\2\u03aa")
        buf.write("\u03a9\3\2\2\2\u03aa\u03ab\3\2\2\2\u03ab\u03ac\3\2\2\2")
        buf.write("\u03ac\u03ae\7\17\2\2\u03ad\u03af\5^\60\2\u03ae\u03ad")
        buf.write("\3\2\2\2\u03ae\u03af\3\2\2\2\u03af\u03b0\3\2\2\2\u03b0")
        buf.write("\u03d2\7\f\2\2\u03b1\u03b3\7h\2\2\u03b2\u03b1\3\2\2\2")
        buf.write("\u03b2\u03b3\3\2\2\2\u03b3\u03b4\3\2\2\2\u03b4\u03c2\7")
        buf.write("\24\2\2\u03b5\u03b6\7h\2\2\u03b6\u03c2\7=\2\2\u03b7\u03b8")
        buf.write("\7h\2\2\u03b8\u03b9\7>\2\2\u03b9\u03ba\7h\2\2\u03ba\u03c2")
        buf.write("\7-\2\2\u03bb\u03bc\7h\2\2\u03bc\u03bd\7?\2\2\u03bd\u03be")
        buf.write("\7h\2\2\u03be\u03c2\7-\2\2\u03bf\u03c0\7h\2\2\u03c0\u03c2")
        buf.write("\7@\2\2\u03c1\u03b2\3\2\2\2\u03c1\u03b5\3\2\2\2\u03c1")
        buf.write("\u03b7\3\2\2\2\u03c1\u03bb\3\2\2\2\u03c1\u03bf\3\2\2\2")
        buf.write("\u03c2\u03c4\3\2\2\2\u03c3\u03c5\7h\2\2\u03c4\u03c3\3")
        buf.write("\2\2\2\u03c4\u03c5\3\2\2\2\u03c5\u03c6\3\2\2\2\u03c6\u03d2")
        buf.write("\5t;\2\u03c7\u03c8\7h\2\2\u03c8\u03c9\7A\2\2\u03c9\u03ca")
        buf.write("\7h\2\2\u03ca\u03d2\7B\2\2\u03cb\u03cc\7h\2\2\u03cc\u03cd")
        buf.write("\7A\2\2\u03cd\u03ce\7h\2\2\u03ce\u03cf\7<\2\2\u03cf\u03d0")
        buf.write("\7h\2\2\u03d0\u03d2\7B\2\2\u03d1\u039f\3\2\2\2\u03d1\u03a6")
        buf.write("\3\2\2\2\u03d1\u03c1\3\2\2\2\u03d1\u03c7\3\2\2\2\u03d1")
        buf.write("\u03cb\3\2\2\2\u03d2\u03d5\3\2\2\2\u03d3\u03d1\3\2\2\2")
        buf.write("\u03d3\u03d4\3\2\2\2\u03d4s\3\2\2\2\u03d5\u03d3\3\2\2")
        buf.write("\2\u03d6\u03e0\5v<\2\u03d7\u03d9\7h\2\2\u03d8\u03d7\3")
        buf.write("\2\2\2\u03d8\u03d9\3\2\2\2\u03d9\u03dc\3\2\2\2\u03da\u03dd")
        buf.write("\5\u0098M\2\u03db\u03dd\5T+\2\u03dc\u03da\3\2\2\2\u03dc")
        buf.write("\u03db\3\2\2\2\u03dd\u03df\3\2\2\2\u03de\u03d8\3\2\2\2")
        buf.write("\u03df\u03e2\3\2\2\2\u03e0\u03de\3\2\2\2\u03e0\u03e1\3")
        buf.write("\2\2\2\u03e1u\3\2\2\2\u03e2\u03e0\3\2\2\2\u03e3\u0455")
        buf.write("\5x=\2\u03e4\u0455\5\u00a4S\2\u03e5\u0455\5\u009aN\2\u03e6")
        buf.write("\u03e8\7C\2\2\u03e7\u03e9\7h\2\2\u03e8\u03e7\3\2\2\2\u03e8")
        buf.write("\u03e9\3\2\2\2\u03e9\u03ea\3\2\2\2\u03ea\u03ec\7\t\2\2")
        buf.write("\u03eb\u03ed\7h\2\2\u03ec\u03eb\3\2\2\2\u03ec\u03ed\3")
        buf.write("\2\2\2\u03ed\u03ee\3\2\2\2\u03ee\u03f0\7\b\2\2\u03ef\u03f1")
        buf.write("\7h\2\2\u03f0\u03ef\3\2\2\2\u03f0\u03f1\3\2\2\2\u03f1")
        buf.write("\u03f2\3\2\2\2\u03f2\u0455\7\n\2\2\u03f3\u0455\5\u0094")
        buf.write("K\2\u03f4\u0455\5\u0096L\2\u03f5\u03f7\7D\2\2\u03f6\u03f8")
        buf.write("\7h\2\2\u03f7\u03f6\3\2\2\2\u03f7\u03f8\3\2\2\2\u03f8")
        buf.write("\u03f9\3\2\2\2\u03f9\u03fb\7\t\2\2\u03fa\u03fc\7h\2\2")
        buf.write("\u03fb\u03fa\3\2\2\2\u03fb\u03fc\3\2\2\2\u03fc\u03fd\3")
        buf.write("\2\2\2\u03fd\u03ff\5\u0084C\2\u03fe\u0400\7h\2\2\u03ff")
        buf.write("\u03fe\3\2\2\2\u03ff\u0400\3\2\2\2\u0400\u0401\3\2\2\2")
        buf.write("\u0401\u0402\7\n\2\2\u0402\u0455\3\2\2\2\u0403\u0405\7")
        buf.write("E\2\2\u0404\u0406\7h\2\2\u0405\u0404\3\2\2\2\u0405\u0406")
        buf.write("\3\2\2\2\u0406\u0407\3\2\2\2\u0407\u0409\7\t\2\2\u0408")
        buf.write("\u040a\7h\2\2\u0409\u0408\3\2\2\2\u0409\u040a\3\2\2\2")
        buf.write("\u040a\u040b\3\2\2\2\u040b\u040d\5\u0084C\2\u040c\u040e")
        buf.write("\7h\2\2\u040d\u040c\3\2\2\2\u040d\u040e\3\2\2\2\u040e")
        buf.write("\u0414\3\2\2\2\u040f\u0411\7h\2\2\u0410\u040f\3\2\2\2")
        buf.write("\u0410\u0411\3\2\2\2\u0411\u0412\3\2\2\2\u0412\u0413\7")
        buf.write("\16\2\2\u0413\u0415\5^\60\2\u0414\u0410\3\2\2\2\u0414")
        buf.write("\u0415\3\2\2\2\u0415\u0416\3\2\2\2\u0416\u0417\7\n\2\2")
        buf.write("\u0417\u0455\3\2\2\2\u0418\u041a\7\37\2\2\u0419\u041b")
        buf.write("\7h\2\2\u041a\u0419\3\2\2\2\u041a\u041b\3\2\2\2\u041b")
        buf.write("\u041c\3\2\2\2\u041c\u041e\7\t\2\2\u041d\u041f\7h\2\2")
        buf.write("\u041e\u041d\3\2\2\2\u041e\u041f\3\2\2\2\u041f\u0420\3")
        buf.write("\2\2\2\u0420\u0422\5\u0084C\2\u0421\u0423\7h\2\2\u0422")
        buf.write("\u0421\3\2\2\2\u0422\u0423\3\2\2\2\u0423\u0424\3\2\2\2")
        buf.write("\u0424\u0425\7\n\2\2\u0425\u0455\3\2\2\2\u0426\u0428\7")
        buf.write("F\2\2\u0427\u0429\7h\2\2\u0428\u0427\3\2\2\2\u0428\u0429")
        buf.write("\3\2\2\2\u0429\u042a\3\2\2\2\u042a\u042c\7\t\2\2\u042b")
        buf.write("\u042d\7h\2\2\u042c\u042b\3\2\2\2\u042c\u042d\3\2\2\2")
        buf.write("\u042d\u042e\3\2\2\2\u042e\u0430\5\u0084C\2\u042f\u0431")
        buf.write("\7h\2\2\u0430\u042f\3\2\2\2\u0430\u0431\3\2\2\2\u0431")
        buf.write("\u0432\3\2\2\2\u0432\u0433\7\n\2\2\u0433\u0455\3\2\2\2")
        buf.write("\u0434\u0436\7G\2\2\u0435\u0437\7h\2\2\u0436\u0435\3\2")
        buf.write("\2\2\u0436\u0437\3\2\2\2\u0437\u0438\3\2\2\2\u0438\u043a")
        buf.write("\7\t\2\2\u0439\u043b\7h\2\2\u043a\u0439\3\2\2\2\u043a")
        buf.write("\u043b\3\2\2\2\u043b\u043c\3\2\2\2\u043c\u043e\5\u0084")
        buf.write("C\2\u043d\u043f\7h\2\2\u043e\u043d\3\2\2\2\u043e\u043f")
        buf.write("\3\2\2\2\u043f\u0440\3\2\2\2\u0440\u0441\7\n\2\2\u0441")
        buf.write("\u0455\3\2\2\2\u0442\u0444\7H\2\2\u0443\u0445\7h\2\2\u0444")
        buf.write("\u0443\3\2\2\2\u0444\u0445\3\2\2\2\u0445\u0446\3\2\2\2")
        buf.write("\u0446\u0448\7\t\2\2\u0447\u0449\7h\2\2\u0448\u0447\3")
        buf.write("\2\2\2\u0448\u0449\3\2\2\2\u0449\u044a\3\2\2\2\u044a\u044c")
        buf.write("\5\u0084C\2\u044b\u044d\7h\2\2\u044c\u044b\3\2\2\2\u044c")
        buf.write("\u044d\3\2\2\2\u044d\u044e\3\2\2\2\u044e\u044f\7\n\2\2")
        buf.write("\u044f\u0455\3\2\2\2\u0450\u0455\5\u0082B\2\u0451\u0455")
        buf.write("\5\u0080A\2\u0452\u0455\5\u0088E\2\u0453\u0455\5\u009e")
        buf.write("P\2\u0454\u03e3\3\2\2\2\u0454\u03e4\3\2\2\2\u0454\u03e5")
        buf.write("\3\2\2\2\u0454\u03e6\3\2\2\2\u0454\u03f3\3\2\2\2\u0454")
        buf.write("\u03f4\3\2\2\2\u0454\u03f5\3\2\2\2\u0454\u0403\3\2\2\2")
        buf.write("\u0454\u0418\3\2\2\2\u0454\u0426\3\2\2\2\u0454\u0434\3")
        buf.write("\2\2\2\u0454\u0442\3\2\2\2\u0454\u0450\3\2\2\2\u0454\u0451")
        buf.write("\3\2\2\2\u0454\u0452\3\2\2\2\u0454\u0453\3\2\2\2\u0455")
        buf.write("w\3\2\2\2\u0456\u045d\5\u00a0Q\2\u0457\u045d\7Q\2\2\u0458")
        buf.write("\u045d\5z>\2\u0459\u045d\7B\2\2\u045a\u045d\5\u00a2R\2")
        buf.write("\u045b\u045d\5|?\2\u045c\u0456\3\2\2\2\u045c\u0457\3\2")
        buf.write("\2\2\u045c\u0458\3\2\2\2\u045c\u0459\3\2\2\2\u045c\u045a")
        buf.write("\3\2\2\2\u045c\u045b\3\2\2\2\u045dy\3\2\2\2\u045e\u045f")
        buf.write("\t\4\2\2\u045f{\3\2\2\2\u0460\u0462\7\13\2\2\u0461\u0463")
        buf.write("\7h\2\2\u0462\u0461\3\2\2\2\u0462\u0463\3\2\2\2\u0463")
        buf.write("\u0475\3\2\2\2\u0464\u0466\5^\60\2\u0465\u0467\7h\2\2")
        buf.write("\u0466\u0465\3\2\2\2\u0466\u0467\3\2\2\2\u0467\u0472\3")
        buf.write("\2\2\2\u0468\u046a\7\4\2\2\u0469\u046b\7h\2\2\u046a\u0469")
        buf.write("\3\2\2\2\u046a\u046b\3\2\2\2\u046b\u046c\3\2\2\2\u046c")
        buf.write("\u046e\5^\60\2\u046d\u046f\7h\2\2\u046e\u046d\3\2\2\2")
        buf.write("\u046e\u046f\3\2\2\2\u046f\u0471\3\2\2\2\u0470\u0468\3")
        buf.write("\2\2\2\u0471\u0474\3\2\2\2\u0472\u0470\3\2\2\2\u0472\u0473")
        buf.write("\3\2\2\2\u0473\u0476\3\2\2\2\u0474\u0472\3\2\2\2\u0475")
        buf.write("\u0464\3\2\2\2\u0475\u0476\3\2\2\2\u0476\u0477\3\2\2\2")
        buf.write("\u0477\u0478\7\f\2\2\u0478}\3\2\2\2\u0479\u047b\7\5\2")
        buf.write("\2\u047a\u047c\7h\2\2\u047b\u047a\3\2\2\2\u047b\u047c")
        buf.write("\3\2\2\2\u047c\u047d\3\2\2\2\u047d\u0498\5j\66\2\u047e")
        buf.write("\u0480\7\25\2\2\u047f\u0481\7h\2\2\u0480\u047f\3\2\2\2")
        buf.write("\u0480\u0481\3\2\2\2\u0481\u0482\3\2\2\2\u0482\u0498\5")
        buf.write("j\66\2\u0483\u0485\7\26\2\2\u0484\u0486\7h\2\2\u0485\u0484")
        buf.write("\3\2\2\2\u0485\u0486\3\2\2\2\u0486\u0487\3\2\2\2\u0487")
        buf.write("\u0498\5j\66\2\u0488\u048a\7\27\2\2\u0489\u048b\7h\2\2")
        buf.write("\u048a\u0489\3\2\2\2\u048a\u048b\3\2\2\2\u048b\u048c\3")
        buf.write("\2\2\2\u048c\u0498\5j\66\2\u048d\u048f\7\30\2\2\u048e")
        buf.write("\u0490\7h\2\2\u048f\u048e\3\2\2\2\u048f\u0490\3\2\2\2")
        buf.write("\u0490\u0491\3\2\2\2\u0491\u0498\5j\66\2\u0492\u0494\7")
        buf.write("\31\2\2\u0493\u0495\7h\2\2\u0494\u0493\3\2\2\2\u0494\u0495")
        buf.write("\3\2\2\2\u0495\u0496\3\2\2\2\u0496\u0498\5j\66\2\u0497")
        buf.write("\u0479\3\2\2\2\u0497\u047e\3\2\2\2\u0497\u0483\3\2\2\2")
        buf.write("\u0497\u0488\3\2\2\2\u0497\u048d\3\2\2\2\u0497\u0492\3")
        buf.write("\2\2\2\u0498\177\3\2\2\2\u0499\u049b\7\t\2\2\u049a\u049c")
        buf.write("\7h\2\2\u049b\u049a\3\2\2\2\u049b\u049c\3\2\2\2\u049c")
        buf.write("\u049d\3\2\2\2\u049d\u049f\5^\60\2\u049e\u04a0\7h\2\2")
        buf.write("\u049f\u049e\3\2\2\2\u049f\u04a0\3\2\2\2\u04a0\u04a1\3")
        buf.write("\2\2\2\u04a1\u04a2\7\n\2\2\u04a2\u0081\3\2\2\2\u04a3\u04a8")
        buf.write("\5H%\2\u04a4\u04a6\7h\2\2\u04a5\u04a4\3\2\2\2\u04a5\u04a6")
        buf.write("\3\2\2\2\u04a6\u04a7\3\2\2\2\u04a7\u04a9\5J&\2\u04a8\u04a5")
        buf.write("\3\2\2\2\u04a9\u04aa\3\2\2\2\u04aa\u04a8\3\2\2\2\u04aa")
        buf.write("\u04ab\3\2\2\2\u04ab\u0083\3\2\2\2\u04ac\u04b1\5\u0086")
        buf.write("D\2\u04ad\u04af\7h\2\2\u04ae\u04ad\3\2\2\2\u04ae\u04af")
        buf.write("\3\2\2\2\u04af\u04b0\3\2\2\2\u04b0\u04b2\5> \2\u04b1\u04ae")
        buf.write("\3\2\2\2\u04b1\u04b2\3\2\2\2\u04b2\u0085\3\2\2\2\u04b3")
        buf.write("\u04b4\5\u009eP\2\u04b4\u04b5\7h\2\2\u04b5\u04b6\7=\2")
        buf.write("\2\u04b6\u04b7\7h\2\2\u04b7\u04b8\5^\60\2\u04b8\u0087")
        buf.write("\3\2\2\2\u04b9\u04bb\5\u008aF\2\u04ba\u04bc\7h\2\2\u04bb")
        buf.write("\u04ba\3\2\2\2\u04bb\u04bc\3\2\2\2\u04bc\u04bd\3\2\2\2")
        buf.write("\u04bd\u04bf\7\t\2\2\u04be\u04c0\7h\2\2\u04bf\u04be\3")
        buf.write("\2\2\2\u04bf\u04c0\3\2\2\2\u04c0\u04c5\3\2\2\2\u04c1\u04c3")
        buf.write("\7.\2\2\u04c2\u04c4\7h\2\2\u04c3\u04c2\3\2\2\2\u04c3\u04c4")
        buf.write("\3\2\2\2\u04c4\u04c6\3\2\2\2\u04c5\u04c1\3\2\2\2\u04c5")
        buf.write("\u04c6\3\2\2\2\u04c6\u04d8\3\2\2\2\u04c7\u04c9\5^\60\2")
        buf.write("\u04c8\u04ca\7h\2\2\u04c9\u04c8\3\2\2\2\u04c9\u04ca\3")
        buf.write("\2\2\2\u04ca\u04d5\3\2\2\2\u04cb\u04cd\7\4\2\2\u04cc\u04ce")
        buf.write("\7h\2\2\u04cd\u04cc\3\2\2\2\u04cd\u04ce\3\2\2\2\u04ce")
        buf.write("\u04cf\3\2\2\2\u04cf\u04d1\5^\60\2\u04d0\u04d2\7h\2\2")
        buf.write("\u04d1\u04d0\3\2\2\2\u04d1\u04d2\3\2\2\2\u04d2\u04d4\3")
        buf.write("\2\2\2\u04d3\u04cb\3\2\2\2\u04d4\u04d7\3\2\2\2\u04d5\u04d3")
        buf.write("\3\2\2\2\u04d5\u04d6\3\2\2\2\u04d6\u04d9\3\2\2\2\u04d7")
        buf.write("\u04d5\3\2\2\2\u04d8\u04c7\3\2\2\2\u04d8\u04d9\3\2\2\2")
        buf.write("\u04d9\u04da\3\2\2\2\u04da\u04db\7\n\2\2\u04db\u0089\3")
        buf.write("\2\2\2\u04dc\u04df\5\u00b2Z\2\u04dd\u04df\7K\2\2\u04de")
        buf.write("\u04dc\3\2\2\2\u04de\u04dd\3\2\2\2\u04df\u008b\3\2\2\2")
        buf.write("\u04e0\u04e2\5\u0092J\2\u04e1\u04e3\7h\2\2\u04e2\u04e1")
        buf.write("\3\2\2\2\u04e2\u04e3\3\2\2\2\u04e3\u04e4\3\2\2\2\u04e4")
        buf.write("\u04e6\7\t\2\2\u04e5\u04e7\7h\2\2\u04e6\u04e5\3\2\2\2")
        buf.write("\u04e6\u04e7\3\2\2\2\u04e7\u04f9\3\2\2\2\u04e8\u04ea\5")
        buf.write("^\60\2\u04e9\u04eb\7h\2\2\u04ea\u04e9\3\2\2\2\u04ea\u04eb")
        buf.write("\3\2\2\2\u04eb\u04f6\3\2\2\2\u04ec\u04ee\7\4\2\2\u04ed")
        buf.write("\u04ef\7h\2\2\u04ee\u04ed\3\2\2\2\u04ee\u04ef\3\2\2\2")
        buf.write("\u04ef\u04f0\3\2\2\2\u04f0\u04f2\5^\60\2\u04f1\u04f3\7")
        buf.write("h\2\2\u04f2\u04f1\3\2\2\2\u04f2\u04f3\3\2\2\2\u04f3\u04f5")
        buf.write("\3\2\2\2\u04f4\u04ec\3\2\2\2\u04f5\u04f8\3\2\2\2\u04f6")
        buf.write("\u04f4\3\2\2\2\u04f6\u04f7\3\2\2\2\u04f7\u04fa\3\2\2\2")
        buf.write("\u04f8\u04f6\3\2\2\2\u04f9\u04e8\3\2\2\2\u04f9\u04fa\3")
        buf.write("\2\2\2\u04fa\u04fb\3\2\2\2\u04fb\u04fc\7\n\2\2\u04fc\u008d")
        buf.write("\3\2\2\2\u04fd\u04fe\5\u0092J\2\u04fe\u008f\3\2\2\2\u04ff")
        buf.write("\u0500\5\u00b2Z\2\u0500\u0091\3\2\2\2\u0501\u0502\5\u00b2")
        buf.write("Z\2\u0502\u0093\3\2\2\2\u0503\u0505\7\13\2\2\u0504\u0506")
        buf.write("\7h\2\2\u0505\u0504\3\2\2\2\u0505\u0506\3\2\2\2\u0506")
        buf.write("\u0507\3\2\2\2\u0507\u0510\5\u0084C\2\u0508\u050a\7h\2")
        buf.write("\2\u0509\u0508\3\2\2\2\u0509\u050a\3\2\2\2\u050a\u050b")
        buf.write("\3\2\2\2\u050b\u050d\7\16\2\2\u050c\u050e\7h\2\2\u050d")
        buf.write("\u050c\3\2\2\2\u050d\u050e\3\2\2\2\u050e\u050f\3\2\2\2")
        buf.write("\u050f\u0511\5^\60\2\u0510\u0509\3\2\2\2\u0510\u0511\3")
        buf.write("\2\2\2\u0511\u0513\3\2\2\2\u0512\u0514\7h\2\2\u0513\u0512")
        buf.write("\3\2\2\2\u0513\u0514\3\2\2\2\u0514\u0515\3\2\2\2\u0515")
        buf.write("\u0516\7\f\2\2\u0516\u0095\3\2\2\2\u0517\u0519\7\13\2")
        buf.write("\2\u0518\u051a\7h\2\2\u0519\u0518\3\2\2\2\u0519\u051a")
        buf.write("\3\2\2\2\u051a\u0523\3\2\2\2\u051b\u051d\5\u009eP\2\u051c")
        buf.write("\u051e\7h\2\2\u051d\u051c\3\2\2\2\u051d\u051e\3\2\2\2")
        buf.write("\u051e\u051f\3\2\2\2\u051f\u0521\7\5\2\2\u0520\u0522\7")
        buf.write("h\2\2\u0521\u0520\3\2\2\2\u0521\u0522\3\2\2\2\u0522\u0524")
        buf.write("\3\2\2\2\u0523\u051b\3\2\2\2\u0523\u0524\3\2\2\2\u0524")
        buf.write("\u0525\3\2\2\2\u0525\u0527\5\u0082B\2\u0526\u0528\7h\2")
        buf.write("\2\u0527\u0526\3\2\2\2\u0527\u0528\3\2\2\2\u0528\u0531")
        buf.write("\3\2\2\2\u0529\u052b\78\2\2\u052a\u052c\7h\2\2\u052b\u052a")
        buf.write("\3\2\2\2\u052b\u052c\3\2\2\2\u052c\u052d\3\2\2\2\u052d")
        buf.write("\u052f\5^\60\2\u052e\u0530\7h\2\2\u052f\u052e\3\2\2\2")
        buf.write("\u052f\u0530\3\2\2\2\u0530\u0532\3\2\2\2\u0531\u0529\3")
        buf.write("\2\2\2\u0531\u0532\3\2\2\2\u0532\u0533\3\2\2\2\u0533\u0535")
        buf.write("\7\16\2\2\u0534\u0536\7h\2\2\u0535\u0534\3\2\2\2\u0535")
        buf.write("\u0536\3\2\2\2\u0536\u0537\3\2\2\2\u0537\u0539\5^\60\2")
        buf.write("\u0538\u053a\7h\2\2\u0539\u0538\3\2\2\2\u0539\u053a\3")
        buf.write("\2\2\2\u053a\u053b\3\2\2\2\u053b\u053c\7\f\2\2\u053c\u0097")
        buf.write("\3\2\2\2\u053d\u053f\7\32\2\2\u053e\u0540\7h\2\2\u053f")
        buf.write("\u053e\3\2\2\2\u053f\u0540\3\2\2\2\u0540\u0541\3\2\2\2")
        buf.write("\u0541\u0542\5\u00a8U\2\u0542\u0099\3\2\2\2\u0543\u0548")
        buf.write("\7L\2\2\u0544\u0546\7h\2\2\u0545\u0544\3\2\2\2\u0545\u0546")
        buf.write("\3\2\2\2\u0546\u0547\3\2\2\2\u0547\u0549\5\u009cO\2\u0548")
        buf.write("\u0545\3\2\2\2\u0549\u054a\3\2\2\2\u054a\u0548\3\2\2\2")
        buf.write("\u054a\u054b\3\2\2\2\u054b\u055a\3\2\2\2\u054c\u054e\7")
        buf.write("L\2\2\u054d\u054f\7h\2\2\u054e\u054d\3\2\2\2\u054e\u054f")
        buf.write("\3\2\2\2\u054f\u0550\3\2\2\2\u0550\u0555\5^\60\2\u0551")
        buf.write("\u0553\7h\2\2\u0552\u0551\3\2\2\2\u0552\u0553\3\2\2\2")
        buf.write("\u0553\u0554\3\2\2\2\u0554\u0556\5\u009cO\2\u0555\u0552")
        buf.write("\3\2\2\2\u0556\u0557\3\2\2\2\u0557\u0555\3\2\2\2\u0557")
        buf.write("\u0558\3\2\2\2\u0558\u055a\3\2\2\2\u0559\u0543\3\2\2\2")
        buf.write("\u0559\u054c\3\2\2\2\u055a\u0563\3\2\2\2\u055b\u055d\7")
        buf.write("h\2\2\u055c\u055b\3\2\2\2\u055c\u055d\3\2\2\2\u055d\u055e")
        buf.write("\3\2\2\2\u055e\u0560\7M\2\2\u055f\u0561\7h\2\2\u0560\u055f")
        buf.write("\3\2\2\2\u0560\u0561\3\2\2\2\u0561\u0562\3\2\2\2\u0562")
        buf.write("\u0564\5^\60\2\u0563\u055c\3\2\2\2\u0563\u0564\3\2\2\2")
        buf.write("\u0564\u0566\3\2\2\2\u0565\u0567\7h\2\2\u0566\u0565\3")
        buf.write("\2\2\2\u0566\u0567\3\2\2\2\u0567\u0568\3\2\2\2\u0568\u0569")
        buf.write("\7N\2\2\u0569\u009b\3\2\2\2\u056a\u056c\7O\2\2\u056b\u056d")
        buf.write("\7h\2\2\u056c\u056b\3\2\2\2\u056c\u056d\3\2\2\2\u056d")
        buf.write("\u056e\3\2\2\2\u056e\u0570\5^\60\2\u056f\u0571\7h\2\2")
        buf.write("\u0570\u056f\3\2\2\2\u0570\u0571\3\2\2\2\u0571\u0572\3")
        buf.write("\2\2\2\u0572\u0574\7P\2\2\u0573\u0575\7h\2\2\u0574\u0573")
        buf.write("\3\2\2\2\u0574\u0575\3\2\2\2\u0575\u0576\3\2\2\2\u0576")
        buf.write("\u0577\5^\60\2\u0577\u009d\3\2\2\2\u0578\u0579\5\u00b2")
        buf.write("Z\2\u0579\u009f\3\2\2\2\u057a\u057d\5\u00acW\2\u057b\u057d")
        buf.write("\5\u00aaV\2\u057c\u057a\3\2\2\2\u057c\u057b\3\2\2\2\u057d")
        buf.write("\u00a1\3\2\2\2\u057e\u0580\7\33\2\2\u057f\u0581\7h\2\2")
        buf.write("\u0580\u057f\3\2\2\2\u0580\u0581\3\2\2\2\u0581\u05a3\3")
        buf.write("\2\2\2\u0582\u0584\5\u00a8U\2\u0583\u0585\7h\2\2\u0584")
        buf.write("\u0583\3\2\2\2\u0584\u0585\3\2\2\2\u0585\u0586\3\2\2\2")
        buf.write("\u0586\u0588\7\r\2\2\u0587\u0589\7h\2\2\u0588\u0587\3")
        buf.write("\2\2\2\u0588\u0589\3\2\2\2\u0589\u058a\3\2\2\2\u058a\u058c")
        buf.write("\5^\60\2\u058b\u058d\7h\2\2\u058c\u058b\3\2\2\2\u058c")
        buf.write("\u058d\3\2\2\2\u058d\u05a0\3\2\2\2\u058e\u0590\7\4\2\2")
        buf.write("\u058f\u0591\7h\2\2\u0590\u058f\3\2\2\2\u0590\u0591\3")
        buf.write("\2\2\2\u0591\u0592\3\2\2\2\u0592\u0594\5\u00a8U\2\u0593")
        buf.write("\u0595\7h\2\2\u0594\u0593\3\2\2\2\u0594\u0595\3\2\2\2")
        buf.write("\u0595\u0596\3\2\2\2\u0596\u0598\7\r\2\2\u0597\u0599\7")
        buf.write("h\2\2\u0598\u0597\3\2\2\2\u0598\u0599\3\2\2\2\u0599\u059a")
        buf.write("\3\2\2\2\u059a\u059c\5^\60\2\u059b\u059d\7h\2\2\u059c")
        buf.write("\u059b\3\2\2\2\u059c\u059d\3\2\2\2\u059d\u059f\3\2\2\2")
        buf.write("\u059e\u058e\3\2\2\2\u059f\u05a2\3\2\2\2\u05a0\u059e\3")
        buf.write("\2\2\2\u05a0\u05a1\3\2\2\2\u05a1\u05a4\3\2\2\2\u05a2\u05a0")
        buf.write("\3\2\2\2\u05a3\u0582\3\2\2\2\u05a3\u05a4\3\2\2\2\u05a4")
        buf.write("\u05a5\3\2\2\2\u05a5\u05a6\7\34\2\2\u05a6\u00a3\3\2\2")
        buf.write("\2\u05a7\u05aa\7\35\2\2\u05a8\u05ab\5\u00b2Z\2\u05a9\u05ab")
        buf.write("\7T\2\2\u05aa\u05a8\3\2\2\2\u05aa\u05a9\3\2\2\2\u05ab")
        buf.write("\u00a5\3\2\2\2\u05ac\u05b1\5v<\2\u05ad\u05af\7h\2\2\u05ae")
        buf.write("\u05ad\3\2\2\2\u05ae\u05af\3\2\2\2\u05af\u05b0\3\2\2\2")
        buf.write("\u05b0\u05b2\5\u0098M\2\u05b1\u05ae\3\2\2\2\u05b2\u05b3")
        buf.write("\3\2\2\2\u05b3\u05b1\3\2\2\2\u05b3\u05b4\3\2\2\2\u05b4")
        buf.write("\u00a7\3\2\2\2\u05b5\u05b6\5\u00aeX\2\u05b6\u00a9\3\2")
        buf.write("\2\2\u05b7\u05b8\t\5\2\2\u05b8\u00ab\3\2\2\2\u05b9\u05ba")
        buf.write("\t\6\2\2\u05ba\u00ad\3\2\2\2\u05bb\u05be\5\u00b2Z\2\u05bc")
        buf.write("\u05be\5\u00b0Y\2\u05bd\u05bb\3\2\2\2\u05bd\u05bc\3\2")
        buf.write("\2\2\u05be\u00af\3\2\2\2\u05bf\u05c0\t\7\2\2\u05c0\u00b1")
        buf.write("\3\2\2\2\u05c1\u05c2\t\b\2\2\u05c2\u00b3\3\2\2\2\u05c3")
        buf.write("\u05c4\7\26\2\2\u05c4\u00b5\3\2\2\2\u05c5\u05c6\7\27\2")
        buf.write("\2\u05c6\u00b7\3\2\2\2\u05c7\u05c8\7\7\2\2\u05c8\u00b9")
        buf.write("\3\2\2\2\u0112\u00bb\u00bf\u00c2\u00c5\u00cb\u00cf\u00d4")
        buf.write("\u00d9\u00de\u00e5\u00ea\u00ed\u00f9\u00fd\u0101\u0105")
        buf.write("\u0108\u010c\u0116\u011d\u012a\u012e\u0134\u013b\u0140")
        buf.write("\u0144\u014a\u014e\u0154\u0158\u015e\u0162\u0166\u016a")
        buf.write("\u016e\u0172\u0177\u017e\u0182\u0187\u018e\u0194\u0199")
        buf.write("\u019f\u01a5\u01a9\u01ad\u01b2\u01b6\u01bd\u01c3\u01c6")
        buf.write("\u01cb\u01ce\u01d2\u01d5\u01dd\u01e1\u01e5\u01e9\u01ed")
        buf.write("\u01f2\u01f7\u01fb\u0200\u0203\u020c\u0215\u021a\u0227")
        buf.write("\u022a\u0232\u0236\u023b\u0240\u0244\u0249\u024f\u0254")
        buf.write("\u025b\u025f\u0263\u0265\u0269\u026b\u026f\u0271\u0277")
        buf.write("\u027d\u0281\u0284\u0287\u028b\u0291\u0295\u0298\u029b")
        buf.write("\u02a1\u02a4\u02a7\u02ab\u02b1\u02b4\u02b7\u02bb\u02bf")
        buf.write("\u02c3\u02c5\u02c9\u02cb\u02ce\u02d2\u02d4\u02da\u02de")
        buf.write("\u02e2\u02e6\u02e9\u02ee\u02f3\u02f8\u02fd\u0303\u0307")
        buf.write("\u0309\u030d\u0311\u0313\u0315\u0324\u032e\u0338\u033d")
        buf.write("\u0341\u0348\u034d\u0352\u0356\u035a\u035e\u0361\u0363")
        buf.write("\u0368\u036c\u0370\u0374\u0378\u037c\u037f\u0381\u0386")
        buf.write("\u038a\u038f\u0394\u0398\u039f\u03a6\u03aa\u03ae\u03b2")
        buf.write("\u03c1\u03c4\u03d1\u03d3\u03d8\u03dc\u03e0\u03e8\u03ec")
        buf.write("\u03f0\u03f7\u03fb\u03ff\u0405\u0409\u040d\u0410\u0414")
        buf.write("\u041a\u041e\u0422\u0428\u042c\u0430\u0436\u043a\u043e")
        buf.write("\u0444\u0448\u044c\u0454\u045c\u0462\u0466\u046a\u046e")
        buf.write("\u0472\u0475\u047b\u0480\u0485\u048a\u048f\u0494\u0497")
        buf.write("\u049b\u049f\u04a5\u04aa\u04ae\u04b1\u04bb\u04bf\u04c3")
        buf.write("\u04c5\u04c9\u04cd\u04d1\u04d5\u04d8\u04de\u04e2\u04e6")
        buf.write("\u04ea\u04ee\u04f2\u04f6\u04f9\u0505\u0509\u050d\u0510")
        buf.write("\u0513\u0519\u051d\u0521\u0523\u0527\u052b\u052f\u0531")
        buf.write("\u0535\u0539\u053f\u0545\u054a\u054e\u0552\u0557\u0559")
        buf.write("\u055c\u0560\u0563\u0566\u056c\u0570\u0574\u057c\u0580")
        buf.write("\u0584\u0588\u058c\u0590\u0594\u0598\u059c\u05a0\u05a3")
        buf.write("\u05aa\u05ae\u05b3\u05bd")
        return buf.getvalue()


class CypherParser ( Parser ):

    grammarFileName = "Cypher.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "','", "'='", "'+='", "'-'", "'*'", 
                     "'('", "')'", "'['", "']'", "':'", "'|'", "'..'", "'+'", 
                     "'/'", "'%'", "'^'", "'=~'", "'<>'", "'<'", "'>'", 
                     "'<='", "'>='", "'.'", "'{'", "'}'", "'$'", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'0'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "UNION", "ALL", "OPTIONAL", "MATCH", "UNWIND", "AS", 
                      "MERGE", "ON", "CREATE", "SET", "DETACH", "DELETE", 
                      "REMOVE", "CALL", "YIELD", "WITH", "DISTINCT", "RETURN", 
                      "ORDER", "BY", "L_SKIP", "LIMIT", "ASCENDING", "ASC", 
                      "DESCENDING", "DESC", "WHERE", "OR", "XOR", "AND", 
                      "NOT", "IN", "STARTS", "ENDS", "CONTAINS", "IS", "NULL", 
                      "COUNT", "FILTER", "EXTRACT", "ANY", "NONE", "SINGLE", 
                      "TRUE", "FALSE", "EXISTS", "CASE", "ELSE", "END", 
                      "WHEN", "THEN", "StringLiteral", "EscapedChar", "HexInteger", 
                      "DecimalInteger", "OctalInteger", "HexLetter", "HexDigit", 
                      "Digit", "NonZeroDigit", "NonZeroOctDigit", "OctDigit", 
                      "ZeroDigit", "ExponentDecimalReal", "RegularDecimalReal", 
                      "CONSTRAINT", "DO", "FOR", "REQUIRE", "UNIQUE", "UnescapedSymbolicName", 
                      "IdentifierStart", "IdentifierPart", "EscapedSymbolicName", 
                      "SP", "WHITESPACE", "Comment" ]

    RULE_cypher = 0
    RULE_statement = 1
    RULE_query = 2
    RULE_regularQuery = 3
    RULE_singleQuery = 4
    RULE_union = 5
    RULE_clause = 6
    RULE_match_ = 7
    RULE_unwind = 8
    RULE_merge = 9
    RULE_mergeAction = 10
    RULE_create = 11
    RULE_set_ = 12
    RULE_setItem = 13
    RULE_delete = 14
    RULE_remove = 15
    RULE_removeItem = 16
    RULE_inQueryCall = 17
    RULE_standaloneCall = 18
    RULE_yieldItems = 19
    RULE_yieldItem = 20
    RULE_with_ = 21
    RULE_return_ = 22
    RULE_returnBody = 23
    RULE_returnItems = 24
    RULE_returnItem = 25
    RULE_order = 26
    RULE_skip = 27
    RULE_limit = 28
    RULE_sortItem = 29
    RULE_where = 30
    RULE_pattern = 31
    RULE_patternPart = 32
    RULE_anonymousPatternPart = 33
    RULE_patternElement = 34
    RULE_nodePattern = 35
    RULE_patternElementChain = 36
    RULE_relationshipPattern = 37
    RULE_relationshipDetail = 38
    RULE_properties = 39
    RULE_relationshipTypes = 40
    RULE_nodeLabels = 41
    RULE_nodeLabel = 42
    RULE_rangeLiteral = 43
    RULE_labelName = 44
    RULE_relTypeName = 45
    RULE_expression = 46
    RULE_orExpression = 47
    RULE_xorExpression = 48
    RULE_andExpression = 49
    RULE_notExpression = 50
    RULE_comparisonExpression = 51
    RULE_addOrSubtractExpression = 52
    RULE_multiplyDivideModuloExpression = 53
    RULE_powerOfExpression = 54
    RULE_unaryAddOrSubtractExpression = 55
    RULE_stringListNullOperatorExpression = 56
    RULE_propertyOrLabelsExpression = 57
    RULE_atom = 58
    RULE_literal = 59
    RULE_booleanLiteral = 60
    RULE_listLiteral = 61
    RULE_partialComparisonExpression = 62
    RULE_parenthesizedExpression = 63
    RULE_relationshipsPattern = 64
    RULE_filterExpression = 65
    RULE_idInColl = 66
    RULE_functionInvocation = 67
    RULE_functionName = 68
    RULE_explicitProcedureInvocation = 69
    RULE_implicitProcedureInvocation = 70
    RULE_procedureResultField = 71
    RULE_procedureName = 72
    RULE_listComprehension = 73
    RULE_patternComprehension = 74
    RULE_propertyLookup = 75
    RULE_caseExpression = 76
    RULE_caseAlternatives = 77
    RULE_variable = 78
    RULE_numberLiteral = 79
    RULE_mapLiteral = 80
    RULE_parameter = 81
    RULE_propertyExpression = 82
    RULE_propertyKeyName = 83
    RULE_integerLiteral = 84
    RULE_doubleLiteral = 85
    RULE_schemaName = 86
    RULE_reservedWord = 87
    RULE_symbolicName = 88
    RULE_leftArrowHead = 89
    RULE_rightArrowHead = 90
    RULE_dash = 91

    ruleNames =  [ "cypher", "statement", "query", "regularQuery", "singleQuery", 
                   "union", "clause", "match_", "unwind", "merge", "mergeAction", 
                   "create", "set_", "setItem", "delete", "remove", "removeItem", 
                   "inQueryCall", "standaloneCall", "yieldItems", "yieldItem", 
                   "with_", "return_", "returnBody", "returnItems", "returnItem", 
                   "order", "skip", "limit", "sortItem", "where", "pattern", 
                   "patternPart", "anonymousPatternPart", "patternElement", 
                   "nodePattern", "patternElementChain", "relationshipPattern", 
                   "relationshipDetail", "properties", "relationshipTypes", 
                   "nodeLabels", "nodeLabel", "rangeLiteral", "labelName", 
                   "relTypeName", "expression", "orExpression", "xorExpression", 
                   "andExpression", "notExpression", "comparisonExpression", 
                   "addOrSubtractExpression", "multiplyDivideModuloExpression", 
                   "powerOfExpression", "unaryAddOrSubtractExpression", 
                   "stringListNullOperatorExpression", "propertyOrLabelsExpression", 
                   "atom", "literal", "booleanLiteral", "listLiteral", "partialComparisonExpression", 
                   "parenthesizedExpression", "relationshipsPattern", "filterExpression", 
                   "idInColl", "functionInvocation", "functionName", "explicitProcedureInvocation", 
                   "implicitProcedureInvocation", "procedureResultField", 
                   "procedureName", "listComprehension", "patternComprehension", 
                   "propertyLookup", "caseExpression", "caseAlternatives", 
                   "variable", "numberLiteral", "mapLiteral", "parameter", 
                   "propertyExpression", "propertyKeyName", "integerLiteral", 
                   "doubleLiteral", "schemaName", "reservedWord", "symbolicName", 
                   "leftArrowHead", "rightArrowHead", "dash" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    UNION=28
    ALL=29
    OPTIONAL=30
    MATCH=31
    UNWIND=32
    AS=33
    MERGE=34
    ON=35
    CREATE=36
    SET=37
    DETACH=38
    DELETE=39
    REMOVE=40
    CALL=41
    YIELD=42
    WITH=43
    DISTINCT=44
    RETURN=45
    ORDER=46
    BY=47
    L_SKIP=48
    LIMIT=49
    ASCENDING=50
    ASC=51
    DESCENDING=52
    DESC=53
    WHERE=54
    OR=55
    XOR=56
    AND=57
    NOT=58
    IN=59
    STARTS=60
    ENDS=61
    CONTAINS=62
    IS=63
    NULL=64
    COUNT=65
    FILTER=66
    EXTRACT=67
    ANY=68
    NONE=69
    SINGLE=70
    TRUE=71
    FALSE=72
    EXISTS=73
    CASE=74
    ELSE=75
    END=76
    WHEN=77
    THEN=78
    StringLiteral=79
    EscapedChar=80
    HexInteger=81
    DecimalInteger=82
    OctalInteger=83
    HexLetter=84
    HexDigit=85
    Digit=86
    NonZeroDigit=87
    NonZeroOctDigit=88
    OctDigit=89
    ZeroDigit=90
    ExponentDecimalReal=91
    RegularDecimalReal=92
    CONSTRAINT=93
    DO=94
    FOR=95
    REQUIRE=96
    UNIQUE=97
    UnescapedSymbolicName=98
    IdentifierStart=99
    IdentifierPart=100
    EscapedSymbolicName=101
    SP=102
    WHITESPACE=103
    Comment=104

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class CypherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(CypherParser.StatementContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_cypher

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCypher" ):
                listener.enterCypher(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCypher" ):
                listener.exitCypher(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCypher" ):
                return visitor.visitCypher(self)
            else:
                return visitor.visitChildren(self)




    def cypher(self):

        localctx = CypherParser.CypherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_cypher)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 184
                self.match(CypherParser.SP)


            self.state = 187
            self.statement()
            self.state = 192
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 189
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 188
                    self.match(CypherParser.SP)


                self.state = 191
                self.match(CypherParser.T__0)


            self.state = 195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 194
                self.match(CypherParser.SP)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def query(self):
            return self.getTypedRuleContext(CypherParser.QueryContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = CypherParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.query()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def regularQuery(self):
            return self.getTypedRuleContext(CypherParser.RegularQueryContext,0)


        def standaloneCall(self):
            return self.getTypedRuleContext(CypherParser.StandaloneCallContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuery" ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuery" ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuery" ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)




    def query(self):

        localctx = CypherParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_query)
        try:
            self.state = 201
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 199
                self.regularQuery()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 200
                self.standaloneCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RegularQueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def singleQuery(self):
            return self.getTypedRuleContext(CypherParser.SingleQueryContext,0)


        def union(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.UnionContext)
            else:
                return self.getTypedRuleContext(CypherParser.UnionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_regularQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRegularQuery" ):
                listener.enterRegularQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRegularQuery" ):
                listener.exitRegularQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegularQuery" ):
                return visitor.visitRegularQuery(self)
            else:
                return visitor.visitChildren(self)




    def regularQuery(self):

        localctx = CypherParser.RegularQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_regularQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.singleQuery()
            self.state = 210
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 205
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 204
                        self.match(CypherParser.SP)


                    self.state = 207
                    self.union() 
                self.state = 212
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SingleQueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ClauseContext)
            else:
                return self.getTypedRuleContext(CypherParser.ClauseContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_singleQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleQuery" ):
                listener.enterSingleQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleQuery" ):
                listener.exitSingleQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleQuery" ):
                return visitor.visitSingleQuery(self)
            else:
                return visitor.visitChildren(self)




    def singleQuery(self):

        localctx = CypherParser.SingleQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_singleQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.clause()
            self.state = 220
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 215
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 214
                        self.match(CypherParser.SP)


                    self.state = 217
                    self.clause() 
                self.state = 222
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION(self):
            return self.getToken(CypherParser.UNION, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def singleQuery(self):
            return self.getTypedRuleContext(CypherParser.SingleQueryContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_union

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnion" ):
                listener.enterUnion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnion" ):
                listener.exitUnion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnion" ):
                return visitor.visitUnion(self)
            else:
                return visitor.visitChildren(self)




    def union(self):

        localctx = CypherParser.UnionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_union)
        self._la = 0 # Token type
        try:
            self.state = 235
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 223
                self.match(CypherParser.UNION)
                self.state = 224
                self.match(CypherParser.SP)
                self.state = 225
                self.match(CypherParser.ALL)
                self.state = 227
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 226
                    self.match(CypherParser.SP)


                self.state = 229
                self.singleQuery()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 230
                self.match(CypherParser.UNION)
                self.state = 232
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 231
                    self.match(CypherParser.SP)


                self.state = 234
                self.singleQuery()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def match_(self):
            return self.getTypedRuleContext(CypherParser.Match_Context,0)


        def unwind(self):
            return self.getTypedRuleContext(CypherParser.UnwindContext,0)


        def merge(self):
            return self.getTypedRuleContext(CypherParser.MergeContext,0)


        def create(self):
            return self.getTypedRuleContext(CypherParser.CreateContext,0)


        def set_(self):
            return self.getTypedRuleContext(CypherParser.Set_Context,0)


        def delete(self):
            return self.getTypedRuleContext(CypherParser.DeleteContext,0)


        def remove(self):
            return self.getTypedRuleContext(CypherParser.RemoveContext,0)


        def inQueryCall(self):
            return self.getTypedRuleContext(CypherParser.InQueryCallContext,0)


        def with_(self):
            return self.getTypedRuleContext(CypherParser.With_Context,0)


        def return_(self):
            return self.getTypedRuleContext(CypherParser.Return_Context,0)


        def getRuleIndex(self):
            return CypherParser.RULE_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClause" ):
                listener.enterClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClause" ):
                listener.exitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClause" ):
                return visitor.visitClause(self)
            else:
                return visitor.visitChildren(self)




    def clause(self):

        localctx = CypherParser.ClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_clause)
        try:
            self.state = 247
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.OPTIONAL, CypherParser.MATCH]:
                self.enterOuterAlt(localctx, 1)
                self.state = 237
                self.match_()
                pass
            elif token in [CypherParser.UNWIND]:
                self.enterOuterAlt(localctx, 2)
                self.state = 238
                self.unwind()
                pass
            elif token in [CypherParser.MERGE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 239
                self.merge()
                pass
            elif token in [CypherParser.CREATE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 240
                self.create()
                pass
            elif token in [CypherParser.SET]:
                self.enterOuterAlt(localctx, 5)
                self.state = 241
                self.set_()
                pass
            elif token in [CypherParser.DETACH, CypherParser.DELETE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 242
                self.delete()
                pass
            elif token in [CypherParser.REMOVE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 243
                self.remove()
                pass
            elif token in [CypherParser.CALL]:
                self.enterOuterAlt(localctx, 8)
                self.state = 244
                self.inQueryCall()
                pass
            elif token in [CypherParser.WITH]:
                self.enterOuterAlt(localctx, 9)
                self.state = 245
                self.with_()
                pass
            elif token in [CypherParser.RETURN]:
                self.enterOuterAlt(localctx, 10)
                self.state = 246
                self.return_()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Match_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def pattern(self):
            return self.getTypedRuleContext(CypherParser.PatternContext,0)


        def OPTIONAL(self):
            return self.getToken(CypherParser.OPTIONAL, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_match_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatch_" ):
                listener.enterMatch_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatch_" ):
                listener.exitMatch_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatch_" ):
                return visitor.visitMatch_(self)
            else:
                return visitor.visitChildren(self)




    def match_(self):

        localctx = CypherParser.Match_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_match_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.OPTIONAL:
                self.state = 249
                self.match(CypherParser.OPTIONAL)
                self.state = 250
                self.match(CypherParser.SP)


            self.state = 253
            self.match(CypherParser.MATCH)
            self.state = 255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 254
                self.match(CypherParser.SP)


            self.state = 257
            self.pattern()
            self.state = 262
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 258
                    self.match(CypherParser.SP)


                self.state = 261
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnwindContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNWIND(self):
            return self.getToken(CypherParser.UNWIND, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_unwind

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnwind" ):
                listener.enterUnwind(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnwind" ):
                listener.exitUnwind(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnwind" ):
                return visitor.visitUnwind(self)
            else:
                return visitor.visitChildren(self)




    def unwind(self):

        localctx = CypherParser.UnwindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unwind)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            self.match(CypherParser.UNWIND)
            self.state = 266
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 265
                self.match(CypherParser.SP)


            self.state = 268
            self.expression()
            self.state = 269
            self.match(CypherParser.SP)
            self.state = 270
            self.match(CypherParser.AS)
            self.state = 271
            self.match(CypherParser.SP)
            self.state = 272
            self.variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MergeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MERGE(self):
            return self.getToken(CypherParser.MERGE, 0)

        def patternPart(self):
            return self.getTypedRuleContext(CypherParser.PatternPartContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def mergeAction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.MergeActionContext)
            else:
                return self.getTypedRuleContext(CypherParser.MergeActionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_merge

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMerge" ):
                listener.enterMerge(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMerge" ):
                listener.exitMerge(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMerge" ):
                return visitor.visitMerge(self)
            else:
                return visitor.visitChildren(self)




    def merge(self):

        localctx = CypherParser.MergeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_merge)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(CypherParser.MERGE)
            self.state = 276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 275
                self.match(CypherParser.SP)


            self.state = 278
            self.patternPart()
            self.state = 283
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 279
                    self.match(CypherParser.SP)
                    self.state = 280
                    self.mergeAction() 
                self.state = 285
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MergeActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(CypherParser.ON, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def set_(self):
            return self.getTypedRuleContext(CypherParser.Set_Context,0)


        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_mergeAction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMergeAction" ):
                listener.enterMergeAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMergeAction" ):
                listener.exitMergeAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMergeAction" ):
                return visitor.visitMergeAction(self)
            else:
                return visitor.visitChildren(self)




    def mergeAction(self):

        localctx = CypherParser.MergeActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_mergeAction)
        try:
            self.state = 296
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 286
                self.match(CypherParser.ON)
                self.state = 287
                self.match(CypherParser.SP)
                self.state = 288
                self.match(CypherParser.MATCH)
                self.state = 289
                self.match(CypherParser.SP)
                self.state = 290
                self.set_()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 291
                self.match(CypherParser.ON)
                self.state = 292
                self.match(CypherParser.SP)
                self.state = 293
                self.match(CypherParser.CREATE)
                self.state = 294
                self.match(CypherParser.SP)
                self.state = 295
                self.set_()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CreateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def pattern(self):
            return self.getTypedRuleContext(CypherParser.PatternContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_create

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate" ):
                listener.enterCreate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate" ):
                listener.exitCreate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreate" ):
                return visitor.visitCreate(self)
            else:
                return visitor.visitChildren(self)




    def create(self):

        localctx = CypherParser.CreateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_create)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.match(CypherParser.CREATE)
            self.state = 300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 299
                self.match(CypherParser.SP)


            self.state = 302
            self.pattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Set_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(CypherParser.SET, 0)

        def setItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.SetItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.SetItemContext,i)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_set_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_" ):
                listener.enterSet_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_" ):
                listener.exitSet_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSet_" ):
                return visitor.visitSet_(self)
            else:
                return visitor.visitChildren(self)




    def set_(self):

        localctx = CypherParser.Set_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_set_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 304
            self.match(CypherParser.SET)
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 305
                self.match(CypherParser.SP)


            self.state = 308
            self.setItem()
            self.state = 313
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CypherParser.T__1:
                self.state = 309
                self.match(CypherParser.T__1)
                self.state = 310
                self.setItem()
                self.state = 315
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SetItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyExpressionContext,0)


        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_setItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetItem" ):
                listener.enterSetItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetItem" ):
                listener.exitSetItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetItem" ):
                return visitor.visitSetItem(self)
            else:
                return visitor.visitChildren(self)




    def setItem(self):

        localctx = CypherParser.SetItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_setItem)
        self._la = 0 # Token type
        try:
            self.state = 352
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 316
                self.propertyExpression()
                self.state = 318
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 317
                    self.match(CypherParser.SP)


                self.state = 320
                self.match(CypherParser.T__2)
                self.state = 322
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 321
                    self.match(CypherParser.SP)


                self.state = 324
                self.expression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 326
                self.variable()
                self.state = 328
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 327
                    self.match(CypherParser.SP)


                self.state = 330
                self.match(CypherParser.T__2)
                self.state = 332
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 331
                    self.match(CypherParser.SP)


                self.state = 334
                self.expression()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 336
                self.variable()
                self.state = 338
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 337
                    self.match(CypherParser.SP)


                self.state = 340
                self.match(CypherParser.T__3)
                self.state = 342
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 341
                    self.match(CypherParser.SP)


                self.state = 344
                self.expression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 346
                self.variable()
                self.state = 348
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 347
                    self.match(CypherParser.SP)


                self.state = 350
                self.nodeLabels()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DeleteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(CypherParser.DELETE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def DETACH(self):
            return self.getToken(CypherParser.DETACH, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_delete

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete" ):
                listener.enterDelete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete" ):
                listener.exitDelete(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelete" ):
                return visitor.visitDelete(self)
            else:
                return visitor.visitChildren(self)




    def delete(self):

        localctx = CypherParser.DeleteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_delete)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.DETACH:
                self.state = 354
                self.match(CypherParser.DETACH)
                self.state = 355
                self.match(CypherParser.SP)


            self.state = 358
            self.match(CypherParser.DELETE)
            self.state = 360
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 359
                self.match(CypherParser.SP)


            self.state = 362
            self.expression()
            self.state = 373
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,36,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 364
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 363
                        self.match(CypherParser.SP)


                    self.state = 366
                    self.match(CypherParser.T__1)
                    self.state = 368
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 367
                        self.match(CypherParser.SP)


                    self.state = 370
                    self.expression() 
                self.state = 375
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,36,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RemoveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REMOVE(self):
            return self.getToken(CypherParser.REMOVE, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def removeItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.RemoveItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.RemoveItemContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_remove

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemove" ):
                listener.enterRemove(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemove" ):
                listener.exitRemove(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemove" ):
                return visitor.visitRemove(self)
            else:
                return visitor.visitChildren(self)




    def remove(self):

        localctx = CypherParser.RemoveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_remove)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(CypherParser.REMOVE)
            self.state = 377
            self.match(CypherParser.SP)
            self.state = 378
            self.removeItem()
            self.state = 389
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,39,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 380
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 379
                        self.match(CypherParser.SP)


                    self.state = 382
                    self.match(CypherParser.T__1)
                    self.state = 384
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 383
                        self.match(CypherParser.SP)


                    self.state = 386
                    self.removeItem() 
                self.state = 391
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,39,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RemoveItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def propertyExpression(self):
            return self.getTypedRuleContext(CypherParser.PropertyExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_removeItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRemoveItem" ):
                listener.enterRemoveItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRemoveItem" ):
                listener.exitRemoveItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRemoveItem" ):
                return visitor.visitRemoveItem(self)
            else:
                return visitor.visitChildren(self)




    def removeItem(self):

        localctx = CypherParser.RemoveItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_removeItem)
        try:
            self.state = 396
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,40,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 392
                self.variable()
                self.state = 393
                self.nodeLabels()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 395
                self.propertyExpression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InQueryCallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL(self):
            return self.getToken(CypherParser.CALL, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def explicitProcedureInvocation(self):
            return self.getTypedRuleContext(CypherParser.ExplicitProcedureInvocationContext,0)


        def YIELD(self):
            return self.getToken(CypherParser.YIELD, 0)

        def yieldItems(self):
            return self.getTypedRuleContext(CypherParser.YieldItemsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_inQueryCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInQueryCall" ):
                listener.enterInQueryCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInQueryCall" ):
                listener.exitInQueryCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInQueryCall" ):
                return visitor.visitInQueryCall(self)
            else:
                return visitor.visitChildren(self)




    def inQueryCall(self):

        localctx = CypherParser.InQueryCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_inQueryCall)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 398
            self.match(CypherParser.CALL)
            self.state = 399
            self.match(CypherParser.SP)
            self.state = 400
            self.explicitProcedureInvocation()
            self.state = 407
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.state = 402
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 401
                    self.match(CypherParser.SP)


                self.state = 404
                self.match(CypherParser.YIELD)
                self.state = 405
                self.match(CypherParser.SP)
                self.state = 406
                self.yieldItems()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StandaloneCallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CALL(self):
            return self.getToken(CypherParser.CALL, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def explicitProcedureInvocation(self):
            return self.getTypedRuleContext(CypherParser.ExplicitProcedureInvocationContext,0)


        def implicitProcedureInvocation(self):
            return self.getTypedRuleContext(CypherParser.ImplicitProcedureInvocationContext,0)


        def YIELD(self):
            return self.getToken(CypherParser.YIELD, 0)

        def yieldItems(self):
            return self.getTypedRuleContext(CypherParser.YieldItemsContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_standaloneCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStandaloneCall" ):
                listener.enterStandaloneCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStandaloneCall" ):
                listener.exitStandaloneCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStandaloneCall" ):
                return visitor.visitStandaloneCall(self)
            else:
                return visitor.visitChildren(self)




    def standaloneCall(self):

        localctx = CypherParser.StandaloneCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_standaloneCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 409
            self.match(CypherParser.CALL)
            self.state = 410
            self.match(CypherParser.SP)
            self.state = 413
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                self.state = 411
                self.explicitProcedureInvocation()
                pass

            elif la_ == 2:
                self.state = 412
                self.implicitProcedureInvocation()
                pass


            self.state = 419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.state = 415
                self.match(CypherParser.SP)
                self.state = 416
                self.match(CypherParser.YIELD)
                self.state = 417
                self.match(CypherParser.SP)
                self.state = 418
                self.yieldItems()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YieldItemsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yieldItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.YieldItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.YieldItemContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_yieldItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldItems" ):
                listener.enterYieldItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldItems" ):
                listener.exitYieldItems(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYieldItems" ):
                return visitor.visitYieldItems(self)
            else:
                return visitor.visitChildren(self)




    def yieldItems(self):

        localctx = CypherParser.YieldItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_yieldItems)
        self._la = 0 # Token type
        try:
            self.state = 436
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.ALL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.HexLetter, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.enterOuterAlt(localctx, 1)
                self.state = 421
                self.yieldItem()
                self.state = 432
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,47,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 423
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 422
                            self.match(CypherParser.SP)


                        self.state = 425
                        self.match(CypherParser.T__1)
                        self.state = 427
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 426
                            self.match(CypherParser.SP)


                        self.state = 429
                        self.yieldItem() 
                    self.state = 434
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,47,self._ctx)

                pass
            elif token in [CypherParser.T__4]:
                self.enterOuterAlt(localctx, 2)
                self.state = 435
                self.match(CypherParser.T__4)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YieldItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def procedureResultField(self):
            return self.getTypedRuleContext(CypherParser.ProcedureResultFieldContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_yieldItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYieldItem" ):
                listener.enterYieldItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYieldItem" ):
                listener.exitYieldItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYieldItem" ):
                return visitor.visitYieldItem(self)
            else:
                return visitor.visitChildren(self)




    def yieldItem(self):

        localctx = CypherParser.YieldItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_yieldItem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 443
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.state = 438
                self.procedureResultField()
                self.state = 439
                self.match(CypherParser.SP)
                self.state = 440
                self.match(CypherParser.AS)
                self.state = 441
                self.match(CypherParser.SP)


            self.state = 445
            self.variable()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class With_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(CypherParser.WITH, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def returnBody(self):
            return self.getTypedRuleContext(CypherParser.ReturnBodyContext,0)


        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_with_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWith_" ):
                listener.enterWith_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWith_" ):
                listener.exitWith_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWith_" ):
                return visitor.visitWith_(self)
            else:
                return visitor.visitChildren(self)




    def with_(self):

        localctx = CypherParser.With_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_with_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.match(CypherParser.WITH)
            self.state = 452
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.state = 449
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 448
                    self.match(CypherParser.SP)


                self.state = 451
                self.match(CypherParser.DISTINCT)


            self.state = 454
            self.match(CypherParser.SP)
            self.state = 455
            self.returnBody()
            self.state = 460
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 457
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 456
                    self.match(CypherParser.SP)


                self.state = 459
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Return_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(CypherParser.RETURN, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def returnBody(self):
            return self.getTypedRuleContext(CypherParser.ReturnBodyContext,0)


        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_return_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturn_" ):
                listener.enterReturn_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturn_" ):
                listener.exitReturn_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturn_" ):
                return visitor.visitReturn_(self)
            else:
                return visitor.visitChildren(self)




    def return_(self):

        localctx = CypherParser.Return_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_return_)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self.match(CypherParser.RETURN)
            self.state = 467
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                self.state = 464
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 463
                    self.match(CypherParser.SP)


                self.state = 466
                self.match(CypherParser.DISTINCT)


            self.state = 469
            self.match(CypherParser.SP)
            self.state = 470
            self.returnBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnBodyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def returnItems(self):
            return self.getTypedRuleContext(CypherParser.ReturnItemsContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def order(self):
            return self.getTypedRuleContext(CypherParser.OrderContext,0)


        def skip(self):
            return self.getTypedRuleContext(CypherParser.SkipContext,0)


        def limit(self):
            return self.getTypedRuleContext(CypherParser.LimitContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_returnBody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnBody" ):
                listener.enterReturnBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnBody" ):
                listener.exitReturnBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnBody" ):
                return visitor.visitReturnBody(self)
            else:
                return visitor.visitChildren(self)




    def returnBody(self):

        localctx = CypherParser.ReturnBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_returnBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 472
            self.returnItems()
            self.state = 475
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.state = 473
                self.match(CypherParser.SP)
                self.state = 474
                self.order()


            self.state = 479
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
            if la_ == 1:
                self.state = 477
                self.match(CypherParser.SP)
                self.state = 478
                self.skip()


            self.state = 483
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.state = 481
                self.match(CypherParser.SP)
                self.state = 482
                self.limit()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnItemsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def returnItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ReturnItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.ReturnItemContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_returnItems

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnItems" ):
                listener.enterReturnItems(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnItems" ):
                listener.exitReturnItems(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnItems" ):
                return visitor.visitReturnItems(self)
            else:
                return visitor.visitChildren(self)




    def returnItems(self):

        localctx = CypherParser.ReturnItemsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_returnItems)
        self._la = 0 # Token type
        try:
            self.state = 513
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.T__5]:
                self.enterOuterAlt(localctx, 1)
                self.state = 485
                self.match(CypherParser.T__5)
                self.state = 496
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,61,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 487
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 486
                            self.match(CypherParser.SP)


                        self.state = 489
                        self.match(CypherParser.T__1)
                        self.state = 491
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 490
                            self.match(CypherParser.SP)


                        self.state = 493
                        self.returnItem() 
                    self.state = 498
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,61,self._ctx)

                pass
            elif token in [CypherParser.T__4, CypherParser.T__6, CypherParser.T__8, CypherParser.T__13, CypherParser.T__24, CypherParser.T__26, CypherParser.ALL, CypherParser.NOT, CypherParser.NULL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.TRUE, CypherParser.FALSE, CypherParser.EXISTS, CypherParser.CASE, CypherParser.StringLiteral, CypherParser.HexInteger, CypherParser.DecimalInteger, CypherParser.OctalInteger, CypherParser.HexLetter, CypherParser.ExponentDecimalReal, CypherParser.RegularDecimalReal, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.enterOuterAlt(localctx, 2)
                self.state = 499
                self.returnItem()
                self.state = 510
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 501
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 500
                            self.match(CypherParser.SP)


                        self.state = 503
                        self.match(CypherParser.T__1)
                        self.state = 505
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 504
                            self.match(CypherParser.SP)


                        self.state = 507
                        self.returnItem() 
                    self.state = 512
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_returnItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnItem" ):
                listener.enterReturnItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnItem" ):
                listener.exitReturnItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnItem" ):
                return visitor.visitReturnItem(self)
            else:
                return visitor.visitChildren(self)




    def returnItem(self):

        localctx = CypherParser.ReturnItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_returnItem)
        try:
            self.state = 522
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 515
                self.expression()
                self.state = 516
                self.match(CypherParser.SP)
                self.state = 517
                self.match(CypherParser.AS)
                self.state = 518
                self.match(CypherParser.SP)
                self.state = 519
                self.variable()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 521
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrderContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(CypherParser.ORDER, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def BY(self):
            return self.getToken(CypherParser.BY, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.SortItemContext)
            else:
                return self.getTypedRuleContext(CypherParser.SortItemContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder" ):
                listener.enterOrder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder" ):
                listener.exitOrder(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrder" ):
                return visitor.visitOrder(self)
            else:
                return visitor.visitChildren(self)




    def order(self):

        localctx = CypherParser.OrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 524
            self.match(CypherParser.ORDER)
            self.state = 525
            self.match(CypherParser.SP)
            self.state = 526
            self.match(CypherParser.BY)
            self.state = 527
            self.match(CypherParser.SP)
            self.state = 528
            self.sortItem()
            self.state = 536
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CypherParser.T__1:
                self.state = 529
                self.match(CypherParser.T__1)
                self.state = 531
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 530
                    self.match(CypherParser.SP)


                self.state = 533
                self.sortItem()
                self.state = 538
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SkipContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def L_SKIP(self):
            return self.getToken(CypherParser.L_SKIP, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_skip

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSkip" ):
                listener.enterSkip(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSkip" ):
                listener.exitSkip(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkip" ):
                return visitor.visitSkip(self)
            else:
                return visitor.visitChildren(self)




    def skip(self):

        localctx = CypherParser.SkipContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_skip)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 539
            self.match(CypherParser.L_SKIP)
            self.state = 540
            self.match(CypherParser.SP)
            self.state = 541
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LimitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT(self):
            return self.getToken(CypherParser.LIMIT, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_limit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLimit" ):
                listener.enterLimit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLimit" ):
                listener.exitLimit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimit" ):
                return visitor.visitLimit(self)
            else:
                return visitor.visitChildren(self)




    def limit(self):

        localctx = CypherParser.LimitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_limit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 543
            self.match(CypherParser.LIMIT)
            self.state = 544
            self.match(CypherParser.SP)
            self.state = 545
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SortItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def ASCENDING(self):
            return self.getToken(CypherParser.ASCENDING, 0)

        def ASC(self):
            return self.getToken(CypherParser.ASC, 0)

        def DESCENDING(self):
            return self.getToken(CypherParser.DESCENDING, 0)

        def DESC(self):
            return self.getToken(CypherParser.DESC, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_sortItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSortItem" ):
                listener.enterSortItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSortItem" ):
                listener.exitSortItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortItem" ):
                return visitor.visitSortItem(self)
            else:
                return visitor.visitChildren(self)




    def sortItem(self):

        localctx = CypherParser.SortItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_sortItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.expression()
            self.state = 552
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 549
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 548
                    self.match(CypherParser.SP)


                self.state = 551
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.ASCENDING) | (1 << CypherParser.ASC) | (1 << CypherParser.DESCENDING) | (1 << CypherParser.DESC))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhereContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_where

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhere" ):
                listener.enterWhere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhere" ):
                listener.exitWhere(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhere" ):
                return visitor.visitWhere(self)
            else:
                return visitor.visitChildren(self)




    def where(self):

        localctx = CypherParser.WhereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_where)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.match(CypherParser.WHERE)
            self.state = 555
            self.match(CypherParser.SP)
            self.state = 556
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patternPart(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternPartContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternPartContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPattern" ):
                return visitor.visitPattern(self)
            else:
                return visitor.visitChildren(self)




    def pattern(self):

        localctx = CypherParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 558
            self.patternPart()
            self.state = 569
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,73,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 560
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 559
                        self.match(CypherParser.SP)


                    self.state = 562
                    self.match(CypherParser.T__1)
                    self.state = 564
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 563
                        self.match(CypherParser.SP)


                    self.state = 566
                    self.patternPart() 
                self.state = 571
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,73,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternPartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def anonymousPatternPart(self):
            return self.getTypedRuleContext(CypherParser.AnonymousPatternPartContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_patternPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternPart" ):
                listener.enterPatternPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternPart" ):
                listener.exitPatternPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternPart" ):
                return visitor.visitPatternPart(self)
            else:
                return visitor.visitChildren(self)




    def patternPart(self):

        localctx = CypherParser.PatternPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_patternPart)
        self._la = 0 # Token type
        try:
            self.state = 583
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.ALL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.HexLetter, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.enterOuterAlt(localctx, 1)
                self.state = 572
                self.variable()
                self.state = 574
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 573
                    self.match(CypherParser.SP)


                self.state = 576
                self.match(CypherParser.T__2)
                self.state = 578
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 577
                    self.match(CypherParser.SP)


                self.state = 580
                self.anonymousPatternPart()
                pass
            elif token in [CypherParser.T__6]:
                self.enterOuterAlt(localctx, 2)
                self.state = 582
                self.anonymousPatternPart()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AnonymousPatternPartContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def patternElement(self):
            return self.getTypedRuleContext(CypherParser.PatternElementContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_anonymousPatternPart

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnonymousPatternPart" ):
                listener.enterAnonymousPatternPart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnonymousPatternPart" ):
                listener.exitAnonymousPatternPart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnonymousPatternPart" ):
                return visitor.visitAnonymousPatternPart(self)
            else:
                return visitor.visitChildren(self)




    def anonymousPatternPart(self):

        localctx = CypherParser.AnonymousPatternPartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_anonymousPatternPart)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 585
            self.patternElement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternElementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def patternElementChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternElementChainContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternElementChainContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def patternElement(self):
            return self.getTypedRuleContext(CypherParser.PatternElementContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_patternElement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternElement" ):
                listener.enterPatternElement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternElement" ):
                listener.exitPatternElement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternElement" ):
                return visitor.visitPatternElement(self)
            else:
                return visitor.visitChildren(self)




    def patternElement(self):

        localctx = CypherParser.PatternElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_patternElement)
        self._la = 0 # Token type
        try:
            self.state = 601
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 587
                self.nodePattern()
                self.state = 594
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,78,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 589
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 588
                            self.match(CypherParser.SP)


                        self.state = 591
                        self.patternElementChain() 
                    self.state = 596
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,78,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 597
                self.match(CypherParser.T__6)
                self.state = 598
                self.patternElement()
                self.state = 599
                self.match(CypherParser.T__7)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NodePatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def nodeLabels(self):
            return self.getTypedRuleContext(CypherParser.NodeLabelsContext,0)


        def properties(self):
            return self.getTypedRuleContext(CypherParser.PropertiesContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_nodePattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodePattern" ):
                listener.enterNodePattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodePattern" ):
                listener.exitNodePattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodePattern" ):
                return visitor.visitNodePattern(self)
            else:
                return visitor.visitChildren(self)




    def nodePattern(self):

        localctx = CypherParser.NodePatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_nodePattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 603
            self.match(CypherParser.T__6)
            self.state = 605
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 604
                self.match(CypherParser.SP)


            self.state = 611
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.ALL or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (CypherParser.COUNT - 65)) | (1 << (CypherParser.FILTER - 65)) | (1 << (CypherParser.EXTRACT - 65)) | (1 << (CypherParser.ANY - 65)) | (1 << (CypherParser.NONE - 65)) | (1 << (CypherParser.SINGLE - 65)) | (1 << (CypherParser.HexLetter - 65)) | (1 << (CypherParser.UnescapedSymbolicName - 65)) | (1 << (CypherParser.EscapedSymbolicName - 65)))) != 0):
                self.state = 607
                self.variable()
                self.state = 609
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 608
                    self.match(CypherParser.SP)




            self.state = 617
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.T__10:
                self.state = 613
                self.nodeLabels()
                self.state = 615
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 614
                    self.match(CypherParser.SP)




            self.state = 623
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.T__24 or _la==CypherParser.T__26:
                self.state = 619
                self.properties()
                self.state = 621
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 620
                    self.match(CypherParser.SP)




            self.state = 625
            self.match(CypherParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternElementChainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationshipPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipPatternContext,0)


        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_patternElementChain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternElementChain" ):
                listener.enterPatternElementChain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternElementChain" ):
                listener.exitPatternElementChain(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternElementChain" ):
                return visitor.visitPatternElementChain(self)
            else:
                return visitor.visitChildren(self)




    def patternElementChain(self):

        localctx = CypherParser.PatternElementChainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_patternElementChain)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 627
            self.relationshipPattern()
            self.state = 629
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 628
                self.match(CypherParser.SP)


            self.state = 631
            self.nodePattern()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipPatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def leftArrowHead(self):
            return self.getTypedRuleContext(CypherParser.LeftArrowHeadContext,0)


        def dash(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.DashContext)
            else:
                return self.getTypedRuleContext(CypherParser.DashContext,i)


        def rightArrowHead(self):
            return self.getTypedRuleContext(CypherParser.RightArrowHeadContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def relationshipDetail(self):
            return self.getTypedRuleContext(CypherParser.RelationshipDetailContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_relationshipPattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipPattern" ):
                listener.enterRelationshipPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipPattern" ):
                listener.exitRelationshipPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipPattern" ):
                return visitor.visitRelationshipPattern(self)
            else:
                return visitor.visitChildren(self)




    def relationshipPattern(self):

        localctx = CypherParser.RelationshipPatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_relationshipPattern)
        self._la = 0 # Token type
        try:
            self.state = 697
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 633
                self.leftArrowHead()
                self.state = 635
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 634
                    self.match(CypherParser.SP)


                self.state = 637
                self.dash()
                self.state = 639
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
                if la_ == 1:
                    self.state = 638
                    self.match(CypherParser.SP)


                self.state = 642
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.T__8:
                    self.state = 641
                    self.relationshipDetail()


                self.state = 645
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 644
                    self.match(CypherParser.SP)


                self.state = 647
                self.dash()
                self.state = 649
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 648
                    self.match(CypherParser.SP)


                self.state = 651
                self.rightArrowHead()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 653
                self.leftArrowHead()
                self.state = 655
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 654
                    self.match(CypherParser.SP)


                self.state = 657
                self.dash()
                self.state = 659
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
                if la_ == 1:
                    self.state = 658
                    self.match(CypherParser.SP)


                self.state = 662
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.T__8:
                    self.state = 661
                    self.relationshipDetail()


                self.state = 665
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 664
                    self.match(CypherParser.SP)


                self.state = 667
                self.dash()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 669
                self.dash()
                self.state = 671
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
                if la_ == 1:
                    self.state = 670
                    self.match(CypherParser.SP)


                self.state = 674
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.T__8:
                    self.state = 673
                    self.relationshipDetail()


                self.state = 677
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 676
                    self.match(CypherParser.SP)


                self.state = 679
                self.dash()
                self.state = 681
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 680
                    self.match(CypherParser.SP)


                self.state = 683
                self.rightArrowHead()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 685
                self.dash()
                self.state = 687
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
                if la_ == 1:
                    self.state = 686
                    self.match(CypherParser.SP)


                self.state = 690
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.T__8:
                    self.state = 689
                    self.relationshipDetail()


                self.state = 693
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 692
                    self.match(CypherParser.SP)


                self.state = 695
                self.dash()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipDetailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def relationshipTypes(self):
            return self.getTypedRuleContext(CypherParser.RelationshipTypesContext,0)


        def rangeLiteral(self):
            return self.getTypedRuleContext(CypherParser.RangeLiteralContext,0)


        def properties(self):
            return self.getTypedRuleContext(CypherParser.PropertiesContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_relationshipDetail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipDetail" ):
                listener.enterRelationshipDetail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipDetail" ):
                listener.exitRelationshipDetail(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipDetail" ):
                return visitor.visitRelationshipDetail(self)
            else:
                return visitor.visitChildren(self)




    def relationshipDetail(self):

        localctx = CypherParser.RelationshipDetailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_relationshipDetail)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 699
            self.match(CypherParser.T__8)
            self.state = 701
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 700
                self.match(CypherParser.SP)


            self.state = 707
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.ALL or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (CypherParser.COUNT - 65)) | (1 << (CypherParser.FILTER - 65)) | (1 << (CypherParser.EXTRACT - 65)) | (1 << (CypherParser.ANY - 65)) | (1 << (CypherParser.NONE - 65)) | (1 << (CypherParser.SINGLE - 65)) | (1 << (CypherParser.HexLetter - 65)) | (1 << (CypherParser.UnescapedSymbolicName - 65)) | (1 << (CypherParser.EscapedSymbolicName - 65)))) != 0):
                self.state = 703
                self.variable()
                self.state = 705
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 704
                    self.match(CypherParser.SP)




            self.state = 713
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.T__10:
                self.state = 709
                self.relationshipTypes()
                self.state = 711
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 710
                    self.match(CypherParser.SP)




            self.state = 716
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.T__5:
                self.state = 715
                self.rangeLiteral()


            self.state = 722
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.T__24 or _la==CypherParser.T__26:
                self.state = 718
                self.properties()
                self.state = 720
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 719
                    self.match(CypherParser.SP)




            self.state = 724
            self.match(CypherParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertiesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mapLiteral(self):
            return self.getTypedRuleContext(CypherParser.MapLiteralContext,0)


        def parameter(self):
            return self.getTypedRuleContext(CypherParser.ParameterContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_properties

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProperties" ):
                listener.enterProperties(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProperties" ):
                listener.exitProperties(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProperties" ):
                return visitor.visitProperties(self)
            else:
                return visitor.visitChildren(self)




    def properties(self):

        localctx = CypherParser.PropertiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_properties)
        try:
            self.state = 728
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.T__24]:
                self.enterOuterAlt(localctx, 1)
                self.state = 726
                self.mapLiteral()
                pass
            elif token in [CypherParser.T__26]:
                self.enterOuterAlt(localctx, 2)
                self.state = 727
                self.parameter()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipTypesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relTypeName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.RelTypeNameContext)
            else:
                return self.getTypedRuleContext(CypherParser.RelTypeNameContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_relationshipTypes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipTypes" ):
                listener.enterRelationshipTypes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipTypes" ):
                listener.exitRelationshipTypes(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipTypes" ):
                return visitor.visitRelationshipTypes(self)
            else:
                return visitor.visitChildren(self)




    def relationshipTypes(self):

        localctx = CypherParser.RelationshipTypesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_relationshipTypes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 730
            self.match(CypherParser.T__10)
            self.state = 732
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 731
                self.match(CypherParser.SP)


            self.state = 734
            self.relTypeName()
            self.state = 748
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,118,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 736
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 735
                        self.match(CypherParser.SP)


                    self.state = 738
                    self.match(CypherParser.T__11)
                    self.state = 740
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.T__10:
                        self.state = 739
                        self.match(CypherParser.T__10)


                    self.state = 743
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 742
                        self.match(CypherParser.SP)


                    self.state = 745
                    self.relTypeName() 
                self.state = 750
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,118,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NodeLabelsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodeLabel(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NodeLabelContext)
            else:
                return self.getTypedRuleContext(CypherParser.NodeLabelContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_nodeLabels

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeLabels" ):
                listener.enterNodeLabels(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeLabels" ):
                listener.exitNodeLabels(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeLabels" ):
                return visitor.visitNodeLabels(self)
            else:
                return visitor.visitChildren(self)




    def nodeLabels(self):

        localctx = CypherParser.NodeLabelsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_nodeLabels)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 751
            self.nodeLabel()
            self.state = 758
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,120,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 753
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 752
                        self.match(CypherParser.SP)


                    self.state = 755
                    self.nodeLabel() 
                self.state = 760
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,120,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NodeLabelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def labelName(self):
            return self.getTypedRuleContext(CypherParser.LabelNameContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_nodeLabel

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNodeLabel" ):
                listener.enterNodeLabel(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNodeLabel" ):
                listener.exitNodeLabel(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNodeLabel" ):
                return visitor.visitNodeLabel(self)
            else:
                return visitor.visitChildren(self)




    def nodeLabel(self):

        localctx = CypherParser.NodeLabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_nodeLabel)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 761
            self.match(CypherParser.T__10)
            self.state = 763
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 762
                self.match(CypherParser.SP)


            self.state = 765
            self.labelName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RangeLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def integerLiteral(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.IntegerLiteralContext)
            else:
                return self.getTypedRuleContext(CypherParser.IntegerLiteralContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_rangeLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRangeLiteral" ):
                listener.enterRangeLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRangeLiteral" ):
                listener.exitRangeLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRangeLiteral" ):
                return visitor.visitRangeLiteral(self)
            else:
                return visitor.visitChildren(self)




    def rangeLiteral(self):

        localctx = CypherParser.RangeLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_rangeLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self.match(CypherParser.T__5)
            self.state = 769
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 768
                self.match(CypherParser.SP)


            self.state = 775
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & ((1 << (CypherParser.HexInteger - 81)) | (1 << (CypherParser.DecimalInteger - 81)) | (1 << (CypherParser.OctalInteger - 81)))) != 0):
                self.state = 771
                self.integerLiteral()
                self.state = 773
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 772
                    self.match(CypherParser.SP)




            self.state = 787
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.T__12:
                self.state = 777
                self.match(CypherParser.T__12)
                self.state = 779
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 778
                    self.match(CypherParser.SP)


                self.state = 785
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & ((1 << (CypherParser.HexInteger - 81)) | (1 << (CypherParser.DecimalInteger - 81)) | (1 << (CypherParser.OctalInteger - 81)))) != 0):
                    self.state = 781
                    self.integerLiteral()
                    self.state = 783
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 782
                        self.match(CypherParser.SP)






        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LabelNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schemaName(self):
            return self.getTypedRuleContext(CypherParser.SchemaNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_labelName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabelName" ):
                listener.enterLabelName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabelName" ):
                listener.exitLabelName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabelName" ):
                return visitor.visitLabelName(self)
            else:
                return visitor.visitChildren(self)




    def labelName(self):

        localctx = CypherParser.LabelNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_labelName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 789
            self.schemaName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelTypeNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schemaName(self):
            return self.getTypedRuleContext(CypherParser.SchemaNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_relTypeName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelTypeName" ):
                listener.enterRelTypeName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelTypeName" ):
                listener.exitRelTypeName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelTypeName" ):
                return visitor.visitRelTypeName(self)
            else:
                return visitor.visitChildren(self)




    def relTypeName(self):

        localctx = CypherParser.RelTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_relTypeName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 791
            self.schemaName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orExpression(self):
            return self.getTypedRuleContext(CypherParser.OrExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = CypherParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 793
            self.orExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OrExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def xorExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.XorExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.XorExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.OR)
            else:
                return self.getToken(CypherParser.OR, i)

        def getRuleIndex(self):
            return CypherParser.RULE_orExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrExpression" ):
                listener.enterOrExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrExpression" ):
                listener.exitOrExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrExpression" ):
                return visitor.visitOrExpression(self)
            else:
                return visitor.visitChildren(self)




    def orExpression(self):

        localctx = CypherParser.OrExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_orExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 795
            self.xorExpression()
            self.state = 802
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,129,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 796
                    self.match(CypherParser.SP)
                    self.state = 797
                    self.match(CypherParser.OR)
                    self.state = 798
                    self.match(CypherParser.SP)
                    self.state = 799
                    self.xorExpression() 
                self.state = 804
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,129,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class XorExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def andExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.AndExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.AndExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def XOR(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.XOR)
            else:
                return self.getToken(CypherParser.XOR, i)

        def getRuleIndex(self):
            return CypherParser.RULE_xorExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXorExpression" ):
                listener.enterXorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXorExpression" ):
                listener.exitXorExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitXorExpression" ):
                return visitor.visitXorExpression(self)
            else:
                return visitor.visitChildren(self)




    def xorExpression(self):

        localctx = CypherParser.XorExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_xorExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 805
            self.andExpression()
            self.state = 812
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,130,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 806
                    self.match(CypherParser.SP)
                    self.state = 807
                    self.match(CypherParser.XOR)
                    self.state = 808
                    self.match(CypherParser.SP)
                    self.state = 809
                    self.andExpression() 
                self.state = 814
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,130,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AndExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def notExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NotExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.NotExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.AND)
            else:
                return self.getToken(CypherParser.AND, i)

        def getRuleIndex(self):
            return CypherParser.RULE_andExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAndExpression" ):
                listener.enterAndExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAndExpression" ):
                listener.exitAndExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAndExpression" ):
                return visitor.visitAndExpression(self)
            else:
                return visitor.visitChildren(self)




    def andExpression(self):

        localctx = CypherParser.AndExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_andExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 815
            self.notExpression()
            self.state = 822
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,131,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 816
                    self.match(CypherParser.SP)
                    self.state = 817
                    self.match(CypherParser.AND)
                    self.state = 818
                    self.match(CypherParser.SP)
                    self.state = 819
                    self.notExpression() 
                self.state = 824
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,131,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NotExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparisonExpression(self):
            return self.getTypedRuleContext(CypherParser.ComparisonExpressionContext,0)


        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.NOT)
            else:
                return self.getToken(CypherParser.NOT, i)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_notExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotExpression" ):
                listener.enterNotExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotExpression" ):
                listener.exitNotExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotExpression" ):
                return visitor.visitNotExpression(self)
            else:
                return visitor.visitChildren(self)




    def notExpression(self):

        localctx = CypherParser.NotExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_notExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 831
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CypherParser.NOT:
                self.state = 825
                self.match(CypherParser.NOT)
                self.state = 827
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 826
                    self.match(CypherParser.SP)


                self.state = 833
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 834
            self.comparisonExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ComparisonExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addOrSubtractExpression(self):
            return self.getTypedRuleContext(CypherParser.AddOrSubtractExpressionContext,0)


        def partialComparisonExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PartialComparisonExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.PartialComparisonExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_comparisonExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparisonExpression" ):
                listener.enterComparisonExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparisonExpression" ):
                listener.exitComparisonExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonExpression" ):
                return visitor.visitComparisonExpression(self)
            else:
                return visitor.visitChildren(self)




    def comparisonExpression(self):

        localctx = CypherParser.ComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_comparisonExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 836
            self.addOrSubtractExpression()
            self.state = 843
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,135,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 838
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 837
                        self.match(CypherParser.SP)


                    self.state = 840
                    self.partialComparisonExpression() 
                self.state = 845
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,135,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AddOrSubtractExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiplyDivideModuloExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.MultiplyDivideModuloExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.MultiplyDivideModuloExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_addOrSubtractExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddOrSubtractExpression" ):
                listener.enterAddOrSubtractExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddOrSubtractExpression" ):
                listener.exitAddOrSubtractExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddOrSubtractExpression" ):
                return visitor.visitAddOrSubtractExpression(self)
            else:
                return visitor.visitChildren(self)




    def addOrSubtractExpression(self):

        localctx = CypherParser.AddOrSubtractExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_addOrSubtractExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 846
            self.multiplyDivideModuloExpression()
            self.state = 865
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,141,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 863
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,140,self._ctx)
                    if la_ == 1:
                        self.state = 848
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 847
                            self.match(CypherParser.SP)


                        self.state = 850
                        self.match(CypherParser.T__13)
                        self.state = 852
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 851
                            self.match(CypherParser.SP)


                        self.state = 854
                        self.multiplyDivideModuloExpression()
                        pass

                    elif la_ == 2:
                        self.state = 856
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 855
                            self.match(CypherParser.SP)


                        self.state = 858
                        self.match(CypherParser.T__4)
                        self.state = 860
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 859
                            self.match(CypherParser.SP)


                        self.state = 862
                        self.multiplyDivideModuloExpression()
                        pass

             
                self.state = 867
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,141,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MultiplyDivideModuloExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def powerOfExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PowerOfExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.PowerOfExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_multiplyDivideModuloExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplyDivideModuloExpression" ):
                listener.enterMultiplyDivideModuloExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplyDivideModuloExpression" ):
                listener.exitMultiplyDivideModuloExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplyDivideModuloExpression" ):
                return visitor.visitMultiplyDivideModuloExpression(self)
            else:
                return visitor.visitChildren(self)




    def multiplyDivideModuloExpression(self):

        localctx = CypherParser.MultiplyDivideModuloExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_multiplyDivideModuloExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 868
            self.powerOfExpression()
            self.state = 895
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,149,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 893
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
                    if la_ == 1:
                        self.state = 870
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 869
                            self.match(CypherParser.SP)


                        self.state = 872
                        self.match(CypherParser.T__5)
                        self.state = 874
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 873
                            self.match(CypherParser.SP)


                        self.state = 876
                        self.powerOfExpression()
                        pass

                    elif la_ == 2:
                        self.state = 878
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 877
                            self.match(CypherParser.SP)


                        self.state = 880
                        self.match(CypherParser.T__14)
                        self.state = 882
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 881
                            self.match(CypherParser.SP)


                        self.state = 884
                        self.powerOfExpression()
                        pass

                    elif la_ == 3:
                        self.state = 886
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 885
                            self.match(CypherParser.SP)


                        self.state = 888
                        self.match(CypherParser.T__15)
                        self.state = 890
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 889
                            self.match(CypherParser.SP)


                        self.state = 892
                        self.powerOfExpression()
                        pass

             
                self.state = 897
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,149,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PowerOfExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unaryAddOrSubtractExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.UnaryAddOrSubtractExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.UnaryAddOrSubtractExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_powerOfExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPowerOfExpression" ):
                listener.enterPowerOfExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPowerOfExpression" ):
                listener.exitPowerOfExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerOfExpression" ):
                return visitor.visitPowerOfExpression(self)
            else:
                return visitor.visitChildren(self)




    def powerOfExpression(self):

        localctx = CypherParser.PowerOfExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_powerOfExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 898
            self.unaryAddOrSubtractExpression()
            self.state = 909
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,152,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 900
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 899
                        self.match(CypherParser.SP)


                    self.state = 902
                    self.match(CypherParser.T__16)
                    self.state = 904
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 903
                        self.match(CypherParser.SP)


                    self.state = 906
                    self.unaryAddOrSubtractExpression() 
                self.state = 911
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,152,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnaryAddOrSubtractExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringListNullOperatorExpression(self):
            return self.getTypedRuleContext(CypherParser.StringListNullOperatorExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_unaryAddOrSubtractExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryAddOrSubtractExpression" ):
                listener.enterUnaryAddOrSubtractExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryAddOrSubtractExpression" ):
                listener.exitUnaryAddOrSubtractExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryAddOrSubtractExpression" ):
                return visitor.visitUnaryAddOrSubtractExpression(self)
            else:
                return visitor.visitChildren(self)




    def unaryAddOrSubtractExpression(self):

        localctx = CypherParser.UnaryAddOrSubtractExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_unaryAddOrSubtractExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 918
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==CypherParser.T__4 or _la==CypherParser.T__13:
                self.state = 912
                _la = self._input.LA(1)
                if not(_la==CypherParser.T__4 or _la==CypherParser.T__13):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 914
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 913
                    self.match(CypherParser.SP)


                self.state = 920
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 921
            self.stringListNullOperatorExpression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StringListNullOperatorExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyOrLabelsExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PropertyOrLabelsExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.PropertyOrLabelsExpressionContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def IS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.IS)
            else:
                return self.getToken(CypherParser.IS, i)

        def NULL(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.NULL)
            else:
                return self.getToken(CypherParser.NULL, i)

        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.NOT)
            else:
                return self.getToken(CypherParser.NOT, i)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.IN)
            else:
                return self.getToken(CypherParser.IN, i)

        def STARTS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.STARTS)
            else:
                return self.getToken(CypherParser.STARTS, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.WITH)
            else:
                return self.getToken(CypherParser.WITH, i)

        def ENDS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.ENDS)
            else:
                return self.getToken(CypherParser.ENDS, i)

        def CONTAINS(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.CONTAINS)
            else:
                return self.getToken(CypherParser.CONTAINS, i)

        def getRuleIndex(self):
            return CypherParser.RULE_stringListNullOperatorExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringListNullOperatorExpression" ):
                listener.enterStringListNullOperatorExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringListNullOperatorExpression" ):
                listener.exitStringListNullOperatorExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringListNullOperatorExpression" ):
                return visitor.visitStringListNullOperatorExpression(self)
            else:
                return visitor.visitChildren(self)




    def stringListNullOperatorExpression(self):

        localctx = CypherParser.StringListNullOperatorExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_stringListNullOperatorExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 923
            self.propertyOrLabelsExpression()
            self.state = 977
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,163,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 975
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,162,self._ctx)
                    if la_ == 1:
                        self.state = 925
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 924
                            self.match(CypherParser.SP)


                        self.state = 927
                        self.match(CypherParser.T__8)
                        self.state = 928
                        self.expression()
                        self.state = 929
                        self.match(CypherParser.T__9)
                        pass

                    elif la_ == 2:
                        self.state = 932
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 931
                            self.match(CypherParser.SP)


                        self.state = 934
                        self.match(CypherParser.T__8)
                        self.state = 936
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__4) | (1 << CypherParser.T__6) | (1 << CypherParser.T__8) | (1 << CypherParser.T__13) | (1 << CypherParser.T__24) | (1 << CypherParser.T__26) | (1 << CypherParser.ALL) | (1 << CypherParser.NOT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.EXISTS - 64)) | (1 << (CypherParser.CASE - 64)) | (1 << (CypherParser.StringLiteral - 64)) | (1 << (CypherParser.HexInteger - 64)) | (1 << (CypherParser.DecimalInteger - 64)) | (1 << (CypherParser.OctalInteger - 64)) | (1 << (CypherParser.HexLetter - 64)) | (1 << (CypherParser.ExponentDecimalReal - 64)) | (1 << (CypherParser.RegularDecimalReal - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                            self.state = 935
                            self.expression()


                        self.state = 938
                        self.match(CypherParser.T__12)
                        self.state = 940
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__4) | (1 << CypherParser.T__6) | (1 << CypherParser.T__8) | (1 << CypherParser.T__13) | (1 << CypherParser.T__24) | (1 << CypherParser.T__26) | (1 << CypherParser.ALL) | (1 << CypherParser.NOT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.EXISTS - 64)) | (1 << (CypherParser.CASE - 64)) | (1 << (CypherParser.StringLiteral - 64)) | (1 << (CypherParser.HexInteger - 64)) | (1 << (CypherParser.DecimalInteger - 64)) | (1 << (CypherParser.OctalInteger - 64)) | (1 << (CypherParser.HexLetter - 64)) | (1 << (CypherParser.ExponentDecimalReal - 64)) | (1 << (CypherParser.RegularDecimalReal - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                            self.state = 939
                            self.expression()


                        self.state = 942
                        self.match(CypherParser.T__9)
                        pass

                    elif la_ == 3:
                        self.state = 959
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
                        if la_ == 1:
                            self.state = 944
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==CypherParser.SP:
                                self.state = 943
                                self.match(CypherParser.SP)


                            self.state = 946
                            self.match(CypherParser.T__17)
                            pass

                        elif la_ == 2:
                            self.state = 947
                            self.match(CypherParser.SP)
                            self.state = 948
                            self.match(CypherParser.IN)
                            pass

                        elif la_ == 3:
                            self.state = 949
                            self.match(CypherParser.SP)
                            self.state = 950
                            self.match(CypherParser.STARTS)
                            self.state = 951
                            self.match(CypherParser.SP)
                            self.state = 952
                            self.match(CypherParser.WITH)
                            pass

                        elif la_ == 4:
                            self.state = 953
                            self.match(CypherParser.SP)
                            self.state = 954
                            self.match(CypherParser.ENDS)
                            self.state = 955
                            self.match(CypherParser.SP)
                            self.state = 956
                            self.match(CypherParser.WITH)
                            pass

                        elif la_ == 5:
                            self.state = 957
                            self.match(CypherParser.SP)
                            self.state = 958
                            self.match(CypherParser.CONTAINS)
                            pass


                        self.state = 962
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 961
                            self.match(CypherParser.SP)


                        self.state = 964
                        self.propertyOrLabelsExpression()
                        pass

                    elif la_ == 4:
                        self.state = 965
                        self.match(CypherParser.SP)
                        self.state = 966
                        self.match(CypherParser.IS)
                        self.state = 967
                        self.match(CypherParser.SP)
                        self.state = 968
                        self.match(CypherParser.NULL)
                        pass

                    elif la_ == 5:
                        self.state = 969
                        self.match(CypherParser.SP)
                        self.state = 970
                        self.match(CypherParser.IS)
                        self.state = 971
                        self.match(CypherParser.SP)
                        self.state = 972
                        self.match(CypherParser.NOT)
                        self.state = 973
                        self.match(CypherParser.SP)
                        self.state = 974
                        self.match(CypherParser.NULL)
                        pass

             
                self.state = 979
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,163,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertyOrLabelsExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CypherParser.AtomContext,0)


        def propertyLookup(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PropertyLookupContext)
            else:
                return self.getTypedRuleContext(CypherParser.PropertyLookupContext,i)


        def nodeLabels(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.NodeLabelsContext)
            else:
                return self.getTypedRuleContext(CypherParser.NodeLabelsContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_propertyOrLabelsExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyOrLabelsExpression" ):
                listener.enterPropertyOrLabelsExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyOrLabelsExpression" ):
                listener.exitPropertyOrLabelsExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyOrLabelsExpression" ):
                return visitor.visitPropertyOrLabelsExpression(self)
            else:
                return visitor.visitChildren(self)




    def propertyOrLabelsExpression(self):

        localctx = CypherParser.PropertyOrLabelsExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_propertyOrLabelsExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 980
            self.atom()
            self.state = 990
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,166,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 982
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 981
                        self.match(CypherParser.SP)


                    self.state = 986
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [CypherParser.T__23]:
                        self.state = 984
                        self.propertyLookup()
                        pass
                    elif token in [CypherParser.T__10]:
                        self.state = 985
                        self.nodeLabels()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 992
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,166,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AtomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal(self):
            return self.getTypedRuleContext(CypherParser.LiteralContext,0)


        def parameter(self):
            return self.getTypedRuleContext(CypherParser.ParameterContext,0)


        def caseExpression(self):
            return self.getTypedRuleContext(CypherParser.CaseExpressionContext,0)


        def COUNT(self):
            return self.getToken(CypherParser.COUNT, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def listComprehension(self):
            return self.getTypedRuleContext(CypherParser.ListComprehensionContext,0)


        def patternComprehension(self):
            return self.getTypedRuleContext(CypherParser.PatternComprehensionContext,0)


        def FILTER(self):
            return self.getToken(CypherParser.FILTER, 0)

        def filterExpression(self):
            return self.getTypedRuleContext(CypherParser.FilterExpressionContext,0)


        def EXTRACT(self):
            return self.getToken(CypherParser.EXTRACT, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def ANY(self):
            return self.getToken(CypherParser.ANY, 0)

        def NONE(self):
            return self.getToken(CypherParser.NONE, 0)

        def SINGLE(self):
            return self.getToken(CypherParser.SINGLE, 0)

        def relationshipsPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipsPatternContext,0)


        def parenthesizedExpression(self):
            return self.getTypedRuleContext(CypherParser.ParenthesizedExpressionContext,0)


        def functionInvocation(self):
            return self.getTypedRuleContext(CypherParser.FunctionInvocationContext,0)


        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = CypherParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_atom)
        self._la = 0 # Token type
        try:
            self.state = 1106
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 993
                self.literal()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 994
                self.parameter()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 995
                self.caseExpression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 996
                self.match(CypherParser.COUNT)
                self.state = 998
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 997
                    self.match(CypherParser.SP)


                self.state = 1000
                self.match(CypherParser.T__6)
                self.state = 1002
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1001
                    self.match(CypherParser.SP)


                self.state = 1004
                self.match(CypherParser.T__5)
                self.state = 1006
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1005
                    self.match(CypherParser.SP)


                self.state = 1008
                self.match(CypherParser.T__7)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1009
                self.listComprehension()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1010
                self.patternComprehension()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1011
                self.match(CypherParser.FILTER)
                self.state = 1013
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1012
                    self.match(CypherParser.SP)


                self.state = 1015
                self.match(CypherParser.T__6)
                self.state = 1017
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1016
                    self.match(CypherParser.SP)


                self.state = 1019
                self.filterExpression()
                self.state = 1021
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1020
                    self.match(CypherParser.SP)


                self.state = 1023
                self.match(CypherParser.T__7)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1025
                self.match(CypherParser.EXTRACT)
                self.state = 1027
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1026
                    self.match(CypherParser.SP)


                self.state = 1029
                self.match(CypherParser.T__6)
                self.state = 1031
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1030
                    self.match(CypherParser.SP)


                self.state = 1033
                self.filterExpression()
                self.state = 1035
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
                if la_ == 1:
                    self.state = 1034
                    self.match(CypherParser.SP)


                self.state = 1042
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.T__11 or _la==CypherParser.SP:
                    self.state = 1038
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1037
                        self.match(CypherParser.SP)


                    self.state = 1040
                    self.match(CypherParser.T__11)
                    self.state = 1041
                    self.expression()


                self.state = 1044
                self.match(CypherParser.T__7)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1046
                self.match(CypherParser.ALL)
                self.state = 1048
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1047
                    self.match(CypherParser.SP)


                self.state = 1050
                self.match(CypherParser.T__6)
                self.state = 1052
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1051
                    self.match(CypherParser.SP)


                self.state = 1054
                self.filterExpression()
                self.state = 1056
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1055
                    self.match(CypherParser.SP)


                self.state = 1058
                self.match(CypherParser.T__7)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1060
                self.match(CypherParser.ANY)
                self.state = 1062
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1061
                    self.match(CypherParser.SP)


                self.state = 1064
                self.match(CypherParser.T__6)
                self.state = 1066
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1065
                    self.match(CypherParser.SP)


                self.state = 1068
                self.filterExpression()
                self.state = 1070
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1069
                    self.match(CypherParser.SP)


                self.state = 1072
                self.match(CypherParser.T__7)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1074
                self.match(CypherParser.NONE)
                self.state = 1076
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1075
                    self.match(CypherParser.SP)


                self.state = 1078
                self.match(CypherParser.T__6)
                self.state = 1080
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1079
                    self.match(CypherParser.SP)


                self.state = 1082
                self.filterExpression()
                self.state = 1084
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1083
                    self.match(CypherParser.SP)


                self.state = 1086
                self.match(CypherParser.T__7)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1088
                self.match(CypherParser.SINGLE)
                self.state = 1090
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1089
                    self.match(CypherParser.SP)


                self.state = 1092
                self.match(CypherParser.T__6)
                self.state = 1094
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1093
                    self.match(CypherParser.SP)


                self.state = 1096
                self.filterExpression()
                self.state = 1098
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1097
                    self.match(CypherParser.SP)


                self.state = 1100
                self.match(CypherParser.T__7)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1102
                self.relationshipsPattern()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1103
                self.parenthesizedExpression()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1104
                self.functionInvocation()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1105
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberLiteral(self):
            return self.getTypedRuleContext(CypherParser.NumberLiteralContext,0)


        def StringLiteral(self):
            return self.getToken(CypherParser.StringLiteral, 0)

        def booleanLiteral(self):
            return self.getTypedRuleContext(CypherParser.BooleanLiteralContext,0)


        def NULL(self):
            return self.getToken(CypherParser.NULL, 0)

        def mapLiteral(self):
            return self.getTypedRuleContext(CypherParser.MapLiteralContext,0)


        def listLiteral(self):
            return self.getTypedRuleContext(CypherParser.ListLiteralContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = CypherParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_literal)
        try:
            self.state = 1114
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.HexInteger, CypherParser.DecimalInteger, CypherParser.OctalInteger, CypherParser.ExponentDecimalReal, CypherParser.RegularDecimalReal]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1108
                self.numberLiteral()
                pass
            elif token in [CypherParser.StringLiteral]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1109
                self.match(CypherParser.StringLiteral)
                pass
            elif token in [CypherParser.TRUE, CypherParser.FALSE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1110
                self.booleanLiteral()
                pass
            elif token in [CypherParser.NULL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1111
                self.match(CypherParser.NULL)
                pass
            elif token in [CypherParser.T__24]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1112
                self.mapLiteral()
                pass
            elif token in [CypherParser.T__8]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1113
                self.listLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BooleanLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(CypherParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(CypherParser.FALSE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_booleanLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooleanLiteral" ):
                listener.enterBooleanLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooleanLiteral" ):
                listener.exitBooleanLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanLiteral" ):
                return visitor.visitBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)




    def booleanLiteral(self):

        localctx = CypherParser.BooleanLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_booleanLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1116
            _la = self._input.LA(1)
            if not(_la==CypherParser.TRUE or _la==CypherParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_listLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListLiteral" ):
                listener.enterListLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListLiteral" ):
                listener.exitListLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListLiteral" ):
                return visitor.visitListLiteral(self)
            else:
                return visitor.visitChildren(self)




    def listLiteral(self):

        localctx = CypherParser.ListLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_listLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1118
            self.match(CypherParser.T__8)
            self.state = 1120
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1119
                self.match(CypherParser.SP)


            self.state = 1139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__4) | (1 << CypherParser.T__6) | (1 << CypherParser.T__8) | (1 << CypherParser.T__13) | (1 << CypherParser.T__24) | (1 << CypherParser.T__26) | (1 << CypherParser.ALL) | (1 << CypherParser.NOT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.EXISTS - 64)) | (1 << (CypherParser.CASE - 64)) | (1 << (CypherParser.StringLiteral - 64)) | (1 << (CypherParser.HexInteger - 64)) | (1 << (CypherParser.DecimalInteger - 64)) | (1 << (CypherParser.OctalInteger - 64)) | (1 << (CypherParser.HexLetter - 64)) | (1 << (CypherParser.ExponentDecimalReal - 64)) | (1 << (CypherParser.RegularDecimalReal - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                self.state = 1122
                self.expression()
                self.state = 1124
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1123
                    self.match(CypherParser.SP)


                self.state = 1136
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CypherParser.T__1:
                    self.state = 1126
                    self.match(CypherParser.T__1)
                    self.state = 1128
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1127
                        self.match(CypherParser.SP)


                    self.state = 1130
                    self.expression()
                    self.state = 1132
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1131
                        self.match(CypherParser.SP)


                    self.state = 1138
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1141
            self.match(CypherParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PartialComparisonExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addOrSubtractExpression(self):
            return self.getTypedRuleContext(CypherParser.AddOrSubtractExpressionContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_partialComparisonExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartialComparisonExpression" ):
                listener.enterPartialComparisonExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartialComparisonExpression" ):
                listener.exitPartialComparisonExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartialComparisonExpression" ):
                return visitor.visitPartialComparisonExpression(self)
            else:
                return visitor.visitChildren(self)




    def partialComparisonExpression(self):

        localctx = CypherParser.PartialComparisonExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_partialComparisonExpression)
        self._la = 0 # Token type
        try:
            self.state = 1173
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.T__2]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1143
                self.match(CypherParser.T__2)
                self.state = 1145
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1144
                    self.match(CypherParser.SP)


                self.state = 1147
                self.addOrSubtractExpression()
                pass
            elif token in [CypherParser.T__18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1148
                self.match(CypherParser.T__18)
                self.state = 1150
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1149
                    self.match(CypherParser.SP)


                self.state = 1152
                self.addOrSubtractExpression()
                pass
            elif token in [CypherParser.T__19]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1153
                self.match(CypherParser.T__19)
                self.state = 1155
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1154
                    self.match(CypherParser.SP)


                self.state = 1157
                self.addOrSubtractExpression()
                pass
            elif token in [CypherParser.T__20]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1158
                self.match(CypherParser.T__20)
                self.state = 1160
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1159
                    self.match(CypherParser.SP)


                self.state = 1162
                self.addOrSubtractExpression()
                pass
            elif token in [CypherParser.T__21]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1163
                self.match(CypherParser.T__21)
                self.state = 1165
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1164
                    self.match(CypherParser.SP)


                self.state = 1167
                self.addOrSubtractExpression()
                pass
            elif token in [CypherParser.T__22]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1168
                self.match(CypherParser.T__22)
                self.state = 1170
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1169
                    self.match(CypherParser.SP)


                self.state = 1172
                self.addOrSubtractExpression()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParenthesizedExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_parenthesizedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenthesizedExpression" ):
                listener.enterParenthesizedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenthesizedExpression" ):
                listener.exitParenthesizedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedExpression" ):
                return visitor.visitParenthesizedExpression(self)
            else:
                return visitor.visitChildren(self)




    def parenthesizedExpression(self):

        localctx = CypherParser.ParenthesizedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_parenthesizedExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1175
            self.match(CypherParser.T__6)
            self.state = 1177
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1176
                self.match(CypherParser.SP)


            self.state = 1179
            self.expression()
            self.state = 1181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1180
                self.match(CypherParser.SP)


            self.state = 1183
            self.match(CypherParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RelationshipsPatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nodePattern(self):
            return self.getTypedRuleContext(CypherParser.NodePatternContext,0)


        def patternElementChain(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PatternElementChainContext)
            else:
                return self.getTypedRuleContext(CypherParser.PatternElementChainContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_relationshipsPattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelationshipsPattern" ):
                listener.enterRelationshipsPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelationshipsPattern" ):
                listener.exitRelationshipsPattern(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelationshipsPattern" ):
                return visitor.visitRelationshipsPattern(self)
            else:
                return visitor.visitChildren(self)




    def relationshipsPattern(self):

        localctx = CypherParser.RelationshipsPatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_relationshipsPattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1185
            self.nodePattern()
            self.state = 1190 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1187
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1186
                        self.match(CypherParser.SP)


                    self.state = 1189
                    self.patternElementChain()

                else:
                    raise NoViableAltException(self)
                self.state = 1192 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,208,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FilterExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def idInColl(self):
            return self.getTypedRuleContext(CypherParser.IdInCollContext,0)


        def where(self):
            return self.getTypedRuleContext(CypherParser.WhereContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_filterExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilterExpression" ):
                listener.enterFilterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilterExpression" ):
                listener.exitFilterExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilterExpression" ):
                return visitor.visitFilterExpression(self)
            else:
                return visitor.visitChildren(self)




    def filterExpression(self):

        localctx = CypherParser.FilterExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_filterExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1194
            self.idInColl()
            self.state = 1199
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,210,self._ctx)
            if la_ == 1:
                self.state = 1196
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1195
                    self.match(CypherParser.SP)


                self.state = 1198
                self.where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdInCollContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def IN(self):
            return self.getToken(CypherParser.IN, 0)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_idInColl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdInColl" ):
                listener.enterIdInColl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdInColl" ):
                listener.exitIdInColl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdInColl" ):
                return visitor.visitIdInColl(self)
            else:
                return visitor.visitChildren(self)




    def idInColl(self):

        localctx = CypherParser.IdInCollContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_idInColl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1201
            self.variable()
            self.state = 1202
            self.match(CypherParser.SP)
            self.state = 1203
            self.match(CypherParser.IN)
            self.state = 1204
            self.match(CypherParser.SP)
            self.state = 1205
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionInvocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionName(self):
            return self.getTypedRuleContext(CypherParser.FunctionNameContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_functionInvocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionInvocation" ):
                listener.enterFunctionInvocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionInvocation" ):
                listener.exitFunctionInvocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionInvocation" ):
                return visitor.visitFunctionInvocation(self)
            else:
                return visitor.visitChildren(self)




    def functionInvocation(self):

        localctx = CypherParser.FunctionInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_functionInvocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1207
            self.functionName()
            self.state = 1209
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1208
                self.match(CypherParser.SP)


            self.state = 1211
            self.match(CypherParser.T__6)
            self.state = 1213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1212
                self.match(CypherParser.SP)


            self.state = 1219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.DISTINCT:
                self.state = 1215
                self.match(CypherParser.DISTINCT)
                self.state = 1217
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1216
                    self.match(CypherParser.SP)




            self.state = 1238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__4) | (1 << CypherParser.T__6) | (1 << CypherParser.T__8) | (1 << CypherParser.T__13) | (1 << CypherParser.T__24) | (1 << CypherParser.T__26) | (1 << CypherParser.ALL) | (1 << CypherParser.NOT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.EXISTS - 64)) | (1 << (CypherParser.CASE - 64)) | (1 << (CypherParser.StringLiteral - 64)) | (1 << (CypherParser.HexInteger - 64)) | (1 << (CypherParser.DecimalInteger - 64)) | (1 << (CypherParser.OctalInteger - 64)) | (1 << (CypherParser.HexLetter - 64)) | (1 << (CypherParser.ExponentDecimalReal - 64)) | (1 << (CypherParser.RegularDecimalReal - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                self.state = 1221
                self.expression()
                self.state = 1223
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1222
                    self.match(CypherParser.SP)


                self.state = 1235
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CypherParser.T__1:
                    self.state = 1225
                    self.match(CypherParser.T__1)
                    self.state = 1227
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1226
                        self.match(CypherParser.SP)


                    self.state = 1229
                    self.expression()
                    self.state = 1231
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1230
                        self.match(CypherParser.SP)


                    self.state = 1237
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1240
            self.match(CypherParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def EXISTS(self):
            return self.getToken(CypherParser.EXISTS, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_functionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionName" ):
                listener.enterFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionName" ):
                listener.exitFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionName" ):
                return visitor.visitFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def functionName(self):

        localctx = CypherParser.FunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_functionName)
        try:
            self.state = 1244
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.ALL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.HexLetter, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1242
                self.symbolicName()
                pass
            elif token in [CypherParser.EXISTS]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1243
                self.match(CypherParser.EXISTS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExplicitProcedureInvocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procedureName(self):
            return self.getTypedRuleContext(CypherParser.ProcedureNameContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_explicitProcedureInvocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplicitProcedureInvocation" ):
                listener.enterExplicitProcedureInvocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplicitProcedureInvocation" ):
                listener.exitExplicitProcedureInvocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplicitProcedureInvocation" ):
                return visitor.visitExplicitProcedureInvocation(self)
            else:
                return visitor.visitChildren(self)




    def explicitProcedureInvocation(self):

        localctx = CypherParser.ExplicitProcedureInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_explicitProcedureInvocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1246
            self.procedureName()
            self.state = 1248
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1247
                self.match(CypherParser.SP)


            self.state = 1250
            self.match(CypherParser.T__6)
            self.state = 1252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1251
                self.match(CypherParser.SP)


            self.state = 1271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.T__4) | (1 << CypherParser.T__6) | (1 << CypherParser.T__8) | (1 << CypherParser.T__13) | (1 << CypherParser.T__24) | (1 << CypherParser.T__26) | (1 << CypherParser.ALL) | (1 << CypherParser.NOT))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.EXISTS - 64)) | (1 << (CypherParser.CASE - 64)) | (1 << (CypherParser.StringLiteral - 64)) | (1 << (CypherParser.HexInteger - 64)) | (1 << (CypherParser.DecimalInteger - 64)) | (1 << (CypherParser.OctalInteger - 64)) | (1 << (CypherParser.HexLetter - 64)) | (1 << (CypherParser.ExponentDecimalReal - 64)) | (1 << (CypherParser.RegularDecimalReal - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                self.state = 1254
                self.expression()
                self.state = 1256
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1255
                    self.match(CypherParser.SP)


                self.state = 1268
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CypherParser.T__1:
                    self.state = 1258
                    self.match(CypherParser.T__1)
                    self.state = 1260
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1259
                        self.match(CypherParser.SP)


                    self.state = 1262
                    self.expression()
                    self.state = 1264
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1263
                        self.match(CypherParser.SP)


                    self.state = 1270
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1273
            self.match(CypherParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ImplicitProcedureInvocationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def procedureName(self):
            return self.getTypedRuleContext(CypherParser.ProcedureNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_implicitProcedureInvocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImplicitProcedureInvocation" ):
                listener.enterImplicitProcedureInvocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImplicitProcedureInvocation" ):
                listener.exitImplicitProcedureInvocation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImplicitProcedureInvocation" ):
                return visitor.visitImplicitProcedureInvocation(self)
            else:
                return visitor.visitChildren(self)




    def implicitProcedureInvocation(self):

        localctx = CypherParser.ImplicitProcedureInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_implicitProcedureInvocation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1275
            self.procedureName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProcedureResultFieldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_procedureResultField

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedureResultField" ):
                listener.enterProcedureResultField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedureResultField" ):
                listener.exitProcedureResultField(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedureResultField" ):
                return visitor.visitProcedureResultField(self)
            else:
                return visitor.visitChildren(self)




    def procedureResultField(self):

        localctx = CypherParser.ProcedureResultFieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_procedureResultField)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1277
            self.symbolicName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProcedureNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_procedureName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProcedureName" ):
                listener.enterProcedureName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProcedureName" ):
                listener.exitProcedureName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProcedureName" ):
                return visitor.visitProcedureName(self)
            else:
                return visitor.visitChildren(self)




    def procedureName(self):

        localctx = CypherParser.ProcedureNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_procedureName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1279
            self.symbolicName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ListComprehensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def filterExpression(self):
            return self.getTypedRuleContext(CypherParser.FilterExpressionContext,0)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def expression(self):
            return self.getTypedRuleContext(CypherParser.ExpressionContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_listComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterListComprehension" ):
                listener.enterListComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitListComprehension" ):
                listener.exitListComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitListComprehension" ):
                return visitor.visitListComprehension(self)
            else:
                return visitor.visitChildren(self)




    def listComprehension(self):

        localctx = CypherParser.ListComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_listComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1281
            self.match(CypherParser.T__8)
            self.state = 1283
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1282
                self.match(CypherParser.SP)


            self.state = 1285
            self.filterExpression()
            self.state = 1294
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,231,self._ctx)
            if la_ == 1:
                self.state = 1287
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1286
                    self.match(CypherParser.SP)


                self.state = 1289
                self.match(CypherParser.T__11)
                self.state = 1291
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1290
                    self.match(CypherParser.SP)


                self.state = 1293
                self.expression()


            self.state = 1297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1296
                self.match(CypherParser.SP)


            self.state = 1299
            self.match(CypherParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PatternComprehensionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationshipsPattern(self):
            return self.getTypedRuleContext(CypherParser.RelationshipsPatternContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def variable(self):
            return self.getTypedRuleContext(CypherParser.VariableContext,0)


        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_patternComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPatternComprehension" ):
                listener.enterPatternComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPatternComprehension" ):
                listener.exitPatternComprehension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPatternComprehension" ):
                return visitor.visitPatternComprehension(self)
            else:
                return visitor.visitChildren(self)




    def patternComprehension(self):

        localctx = CypherParser.PatternComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_patternComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1301
            self.match(CypherParser.T__8)
            self.state = 1303
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1302
                self.match(CypherParser.SP)


            self.state = 1313
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.ALL or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (CypherParser.COUNT - 65)) | (1 << (CypherParser.FILTER - 65)) | (1 << (CypherParser.EXTRACT - 65)) | (1 << (CypherParser.ANY - 65)) | (1 << (CypherParser.NONE - 65)) | (1 << (CypherParser.SINGLE - 65)) | (1 << (CypherParser.HexLetter - 65)) | (1 << (CypherParser.UnescapedSymbolicName - 65)) | (1 << (CypherParser.EscapedSymbolicName - 65)))) != 0):
                self.state = 1305
                self.variable()
                self.state = 1307
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1306
                    self.match(CypherParser.SP)


                self.state = 1309
                self.match(CypherParser.T__2)
                self.state = 1311
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1310
                    self.match(CypherParser.SP)




            self.state = 1315
            self.relationshipsPattern()
            self.state = 1317
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1316
                self.match(CypherParser.SP)


            self.state = 1327
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.WHERE:
                self.state = 1319
                self.match(CypherParser.WHERE)
                self.state = 1321
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1320
                    self.match(CypherParser.SP)


                self.state = 1323
                self.expression()
                self.state = 1325
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1324
                    self.match(CypherParser.SP)




            self.state = 1329
            self.match(CypherParser.T__11)
            self.state = 1331
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1330
                self.match(CypherParser.SP)


            self.state = 1333
            self.expression()
            self.state = 1335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1334
                self.match(CypherParser.SP)


            self.state = 1337
            self.match(CypherParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertyLookupContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def propertyKeyName(self):
            return self.getTypedRuleContext(CypherParser.PropertyKeyNameContext,0)


        def SP(self):
            return self.getToken(CypherParser.SP, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_propertyLookup

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyLookup" ):
                listener.enterPropertyLookup(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyLookup" ):
                listener.exitPropertyLookup(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyLookup" ):
                return visitor.visitPropertyLookup(self)
            else:
                return visitor.visitChildren(self)




    def propertyLookup(self):

        localctx = CypherParser.PropertyLookupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_propertyLookup)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1339
            self.match(CypherParser.T__23)
            self.state = 1341
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1340
                self.match(CypherParser.SP)


            self.state = 1343
            self.propertyKeyName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CaseExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END(self):
            return self.getToken(CypherParser.END, 0)

        def ELSE(self):
            return self.getToken(CypherParser.ELSE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def CASE(self):
            return self.getToken(CypherParser.CASE, 0)

        def caseAlternatives(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.CaseAlternativesContext)
            else:
                return self.getTypedRuleContext(CypherParser.CaseAlternativesContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpression" ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpression" ):
                listener.exitCaseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseExpression" ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpression(self):

        localctx = CypherParser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_caseExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1367
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,249,self._ctx)
            if la_ == 1:
                self.state = 1345
                self.match(CypherParser.CASE)
                self.state = 1350 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1347
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 1346
                            self.match(CypherParser.SP)


                        self.state = 1349
                        self.caseAlternatives()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1352 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,245,self._ctx)

                pass

            elif la_ == 2:
                self.state = 1354
                self.match(CypherParser.CASE)
                self.state = 1356
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1355
                    self.match(CypherParser.SP)


                self.state = 1358
                self.expression()
                self.state = 1363 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1360
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==CypherParser.SP:
                            self.state = 1359
                            self.match(CypherParser.SP)


                        self.state = 1362
                        self.caseAlternatives()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1365 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,248,self._ctx)

                pass


            self.state = 1377
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,252,self._ctx)
            if la_ == 1:
                self.state = 1370
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1369
                    self.match(CypherParser.SP)


                self.state = 1372
                self.match(CypherParser.ELSE)
                self.state = 1374
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1373
                    self.match(CypherParser.SP)


                self.state = 1376
                self.expression()


            self.state = 1380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1379
                self.match(CypherParser.SP)


            self.state = 1382
            self.match(CypherParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CaseAlternativesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(CypherParser.WHEN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def THEN(self):
            return self.getToken(CypherParser.THEN, 0)

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_caseAlternatives

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseAlternatives" ):
                listener.enterCaseAlternatives(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseAlternatives" ):
                listener.exitCaseAlternatives(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCaseAlternatives" ):
                return visitor.visitCaseAlternatives(self)
            else:
                return visitor.visitChildren(self)




    def caseAlternatives(self):

        localctx = CypherParser.CaseAlternativesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_caseAlternatives)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1384
            self.match(CypherParser.WHEN)
            self.state = 1386
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1385
                self.match(CypherParser.SP)


            self.state = 1388
            self.expression()
            self.state = 1390
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1389
                self.match(CypherParser.SP)


            self.state = 1392
            self.match(CypherParser.THEN)
            self.state = 1394
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1393
                self.match(CypherParser.SP)


            self.state = 1396
            self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = CypherParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1398
            self.symbolicName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def doubleLiteral(self):
            return self.getTypedRuleContext(CypherParser.DoubleLiteralContext,0)


        def integerLiteral(self):
            return self.getTypedRuleContext(CypherParser.IntegerLiteralContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_numberLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberLiteral" ):
                listener.enterNumberLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberLiteral" ):
                listener.exitNumberLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberLiteral" ):
                return visitor.visitNumberLiteral(self)
            else:
                return visitor.visitChildren(self)




    def numberLiteral(self):

        localctx = CypherParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_numberLiteral)
        try:
            self.state = 1402
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.ExponentDecimalReal, CypherParser.RegularDecimalReal]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1400
                self.doubleLiteral()
                pass
            elif token in [CypherParser.HexInteger, CypherParser.DecimalInteger, CypherParser.OctalInteger]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1401
                self.integerLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MapLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def propertyKeyName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PropertyKeyNameContext)
            else:
                return self.getTypedRuleContext(CypherParser.PropertyKeyNameContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(CypherParser.ExpressionContext,i)


        def getRuleIndex(self):
            return CypherParser.RULE_mapLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapLiteral" ):
                listener.enterMapLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapLiteral" ):
                listener.exitMapLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMapLiteral" ):
                return visitor.visitMapLiteral(self)
            else:
                return visitor.visitChildren(self)




    def mapLiteral(self):

        localctx = CypherParser.MapLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_mapLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1404
            self.match(CypherParser.T__24)
            self.state = 1406
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==CypherParser.SP:
                self.state = 1405
                self.match(CypherParser.SP)


            self.state = 1441
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.UNION) | (1 << CypherParser.ALL) | (1 << CypherParser.OPTIONAL) | (1 << CypherParser.MATCH) | (1 << CypherParser.UNWIND) | (1 << CypherParser.AS) | (1 << CypherParser.MERGE) | (1 << CypherParser.ON) | (1 << CypherParser.CREATE) | (1 << CypherParser.SET) | (1 << CypherParser.DETACH) | (1 << CypherParser.DELETE) | (1 << CypherParser.REMOVE) | (1 << CypherParser.WITH) | (1 << CypherParser.DISTINCT) | (1 << CypherParser.RETURN) | (1 << CypherParser.ORDER) | (1 << CypherParser.BY) | (1 << CypherParser.L_SKIP) | (1 << CypherParser.LIMIT) | (1 << CypherParser.ASCENDING) | (1 << CypherParser.ASC) | (1 << CypherParser.DESCENDING) | (1 << CypherParser.DESC) | (1 << CypherParser.WHERE) | (1 << CypherParser.OR) | (1 << CypherParser.XOR) | (1 << CypherParser.AND) | (1 << CypherParser.NOT) | (1 << CypherParser.IN) | (1 << CypherParser.STARTS) | (1 << CypherParser.ENDS) | (1 << CypherParser.CONTAINS) | (1 << CypherParser.IS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.COUNT - 64)) | (1 << (CypherParser.FILTER - 64)) | (1 << (CypherParser.EXTRACT - 64)) | (1 << (CypherParser.ANY - 64)) | (1 << (CypherParser.NONE - 64)) | (1 << (CypherParser.SINGLE - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.EXISTS - 64)) | (1 << (CypherParser.CASE - 64)) | (1 << (CypherParser.ELSE - 64)) | (1 << (CypherParser.END - 64)) | (1 << (CypherParser.WHEN - 64)) | (1 << (CypherParser.THEN - 64)) | (1 << (CypherParser.HexLetter - 64)) | (1 << (CypherParser.CONSTRAINT - 64)) | (1 << (CypherParser.DO - 64)) | (1 << (CypherParser.FOR - 64)) | (1 << (CypherParser.REQUIRE - 64)) | (1 << (CypherParser.UNIQUE - 64)) | (1 << (CypherParser.UnescapedSymbolicName - 64)) | (1 << (CypherParser.EscapedSymbolicName - 64)))) != 0):
                self.state = 1408
                self.propertyKeyName()
                self.state = 1410
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1409
                    self.match(CypherParser.SP)


                self.state = 1412
                self.match(CypherParser.T__10)
                self.state = 1414
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1413
                    self.match(CypherParser.SP)


                self.state = 1416
                self.expression()
                self.state = 1418
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==CypherParser.SP:
                    self.state = 1417
                    self.match(CypherParser.SP)


                self.state = 1438
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==CypherParser.T__1:
                    self.state = 1420
                    self.match(CypherParser.T__1)
                    self.state = 1422
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1421
                        self.match(CypherParser.SP)


                    self.state = 1424
                    self.propertyKeyName()
                    self.state = 1426
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1425
                        self.match(CypherParser.SP)


                    self.state = 1428
                    self.match(CypherParser.T__10)
                    self.state = 1430
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1429
                        self.match(CypherParser.SP)


                    self.state = 1432
                    self.expression()
                    self.state = 1434
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1433
                        self.match(CypherParser.SP)


                    self.state = 1440
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1443
            self.match(CypherParser.T__25)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def DecimalInteger(self):
            return self.getToken(CypherParser.DecimalInteger, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = CypherParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1445
            self.match(CypherParser.T__26)
            self.state = 1448
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [CypherParser.ALL, CypherParser.COUNT, CypherParser.FILTER, CypherParser.EXTRACT, CypherParser.ANY, CypherParser.NONE, CypherParser.SINGLE, CypherParser.HexLetter, CypherParser.UnescapedSymbolicName, CypherParser.EscapedSymbolicName]:
                self.state = 1446
                self.symbolicName()
                pass
            elif token in [CypherParser.DecimalInteger]:
                self.state = 1447
                self.match(CypherParser.DecimalInteger)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertyExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(CypherParser.AtomContext,0)


        def propertyLookup(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(CypherParser.PropertyLookupContext)
            else:
                return self.getTypedRuleContext(CypherParser.PropertyLookupContext,i)


        def SP(self, i:int=None):
            if i is None:
                return self.getTokens(CypherParser.SP)
            else:
                return self.getToken(CypherParser.SP, i)

        def getRuleIndex(self):
            return CypherParser.RULE_propertyExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyExpression" ):
                listener.enterPropertyExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyExpression" ):
                listener.exitPropertyExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyExpression" ):
                return visitor.visitPropertyExpression(self)
            else:
                return visitor.visitChildren(self)




    def propertyExpression(self):

        localctx = CypherParser.PropertyExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_propertyExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1450
            self.atom()
            self.state = 1455 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1452
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==CypherParser.SP:
                        self.state = 1451
                        self.match(CypherParser.SP)


                    self.state = 1454
                    self.propertyLookup()

                else:
                    raise NoViableAltException(self)
                self.state = 1457 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,270,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PropertyKeyNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schemaName(self):
            return self.getTypedRuleContext(CypherParser.SchemaNameContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_propertyKeyName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPropertyKeyName" ):
                listener.enterPropertyKeyName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPropertyKeyName" ):
                listener.exitPropertyKeyName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPropertyKeyName" ):
                return visitor.visitPropertyKeyName(self)
            else:
                return visitor.visitChildren(self)




    def propertyKeyName(self):

        localctx = CypherParser.PropertyKeyNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_propertyKeyName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1459
            self.schemaName()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IntegerLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HexInteger(self):
            return self.getToken(CypherParser.HexInteger, 0)

        def OctalInteger(self):
            return self.getToken(CypherParser.OctalInteger, 0)

        def DecimalInteger(self):
            return self.getToken(CypherParser.DecimalInteger, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_integerLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntegerLiteral" ):
                listener.enterIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntegerLiteral" ):
                listener.exitIntegerLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerLiteral" ):
                return visitor.visitIntegerLiteral(self)
            else:
                return visitor.visitChildren(self)




    def integerLiteral(self):

        localctx = CypherParser.IntegerLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_integerLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1461
            _la = self._input.LA(1)
            if not(((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & ((1 << (CypherParser.HexInteger - 81)) | (1 << (CypherParser.DecimalInteger - 81)) | (1 << (CypherParser.OctalInteger - 81)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DoubleLiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ExponentDecimalReal(self):
            return self.getToken(CypherParser.ExponentDecimalReal, 0)

        def RegularDecimalReal(self):
            return self.getToken(CypherParser.RegularDecimalReal, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_doubleLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDoubleLiteral" ):
                listener.enterDoubleLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDoubleLiteral" ):
                listener.exitDoubleLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoubleLiteral" ):
                return visitor.visitDoubleLiteral(self)
            else:
                return visitor.visitChildren(self)




    def doubleLiteral(self):

        localctx = CypherParser.DoubleLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_doubleLiteral)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1463
            _la = self._input.LA(1)
            if not(_la==CypherParser.ExponentDecimalReal or _la==CypherParser.RegularDecimalReal):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SchemaNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def symbolicName(self):
            return self.getTypedRuleContext(CypherParser.SymbolicNameContext,0)


        def reservedWord(self):
            return self.getTypedRuleContext(CypherParser.ReservedWordContext,0)


        def getRuleIndex(self):
            return CypherParser.RULE_schemaName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchemaName" ):
                listener.enterSchemaName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchemaName" ):
                listener.exitSchemaName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchemaName" ):
                return visitor.visitSchemaName(self)
            else:
                return visitor.visitChildren(self)




    def schemaName(self):

        localctx = CypherParser.SchemaNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_schemaName)
        try:
            self.state = 1467
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,271,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1465
                self.symbolicName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1466
                self.reservedWord()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReservedWordContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def ASC(self):
            return self.getToken(CypherParser.ASC, 0)

        def ASCENDING(self):
            return self.getToken(CypherParser.ASCENDING, 0)

        def BY(self):
            return self.getToken(CypherParser.BY, 0)

        def CREATE(self):
            return self.getToken(CypherParser.CREATE, 0)

        def DELETE(self):
            return self.getToken(CypherParser.DELETE, 0)

        def DESC(self):
            return self.getToken(CypherParser.DESC, 0)

        def DESCENDING(self):
            return self.getToken(CypherParser.DESCENDING, 0)

        def DETACH(self):
            return self.getToken(CypherParser.DETACH, 0)

        def EXISTS(self):
            return self.getToken(CypherParser.EXISTS, 0)

        def LIMIT(self):
            return self.getToken(CypherParser.LIMIT, 0)

        def MATCH(self):
            return self.getToken(CypherParser.MATCH, 0)

        def MERGE(self):
            return self.getToken(CypherParser.MERGE, 0)

        def ON(self):
            return self.getToken(CypherParser.ON, 0)

        def OPTIONAL(self):
            return self.getToken(CypherParser.OPTIONAL, 0)

        def ORDER(self):
            return self.getToken(CypherParser.ORDER, 0)

        def REMOVE(self):
            return self.getToken(CypherParser.REMOVE, 0)

        def RETURN(self):
            return self.getToken(CypherParser.RETURN, 0)

        def SET(self):
            return self.getToken(CypherParser.SET, 0)

        def L_SKIP(self):
            return self.getToken(CypherParser.L_SKIP, 0)

        def WHERE(self):
            return self.getToken(CypherParser.WHERE, 0)

        def WITH(self):
            return self.getToken(CypherParser.WITH, 0)

        def UNION(self):
            return self.getToken(CypherParser.UNION, 0)

        def UNWIND(self):
            return self.getToken(CypherParser.UNWIND, 0)

        def AND(self):
            return self.getToken(CypherParser.AND, 0)

        def AS(self):
            return self.getToken(CypherParser.AS, 0)

        def CONTAINS(self):
            return self.getToken(CypherParser.CONTAINS, 0)

        def DISTINCT(self):
            return self.getToken(CypherParser.DISTINCT, 0)

        def ENDS(self):
            return self.getToken(CypherParser.ENDS, 0)

        def IN(self):
            return self.getToken(CypherParser.IN, 0)

        def IS(self):
            return self.getToken(CypherParser.IS, 0)

        def NOT(self):
            return self.getToken(CypherParser.NOT, 0)

        def OR(self):
            return self.getToken(CypherParser.OR, 0)

        def STARTS(self):
            return self.getToken(CypherParser.STARTS, 0)

        def XOR(self):
            return self.getToken(CypherParser.XOR, 0)

        def FALSE(self):
            return self.getToken(CypherParser.FALSE, 0)

        def TRUE(self):
            return self.getToken(CypherParser.TRUE, 0)

        def NULL(self):
            return self.getToken(CypherParser.NULL, 0)

        def CONSTRAINT(self):
            return self.getToken(CypherParser.CONSTRAINT, 0)

        def DO(self):
            return self.getToken(CypherParser.DO, 0)

        def FOR(self):
            return self.getToken(CypherParser.FOR, 0)

        def REQUIRE(self):
            return self.getToken(CypherParser.REQUIRE, 0)

        def UNIQUE(self):
            return self.getToken(CypherParser.UNIQUE, 0)

        def CASE(self):
            return self.getToken(CypherParser.CASE, 0)

        def WHEN(self):
            return self.getToken(CypherParser.WHEN, 0)

        def THEN(self):
            return self.getToken(CypherParser.THEN, 0)

        def ELSE(self):
            return self.getToken(CypherParser.ELSE, 0)

        def END(self):
            return self.getToken(CypherParser.END, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_reservedWord

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReservedWord" ):
                listener.enterReservedWord(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReservedWord" ):
                listener.exitReservedWord(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReservedWord" ):
                return visitor.visitReservedWord(self)
            else:
                return visitor.visitChildren(self)




    def reservedWord(self):

        localctx = CypherParser.ReservedWordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_reservedWord)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1469
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << CypherParser.UNION) | (1 << CypherParser.ALL) | (1 << CypherParser.OPTIONAL) | (1 << CypherParser.MATCH) | (1 << CypherParser.UNWIND) | (1 << CypherParser.AS) | (1 << CypherParser.MERGE) | (1 << CypherParser.ON) | (1 << CypherParser.CREATE) | (1 << CypherParser.SET) | (1 << CypherParser.DETACH) | (1 << CypherParser.DELETE) | (1 << CypherParser.REMOVE) | (1 << CypherParser.WITH) | (1 << CypherParser.DISTINCT) | (1 << CypherParser.RETURN) | (1 << CypherParser.ORDER) | (1 << CypherParser.BY) | (1 << CypherParser.L_SKIP) | (1 << CypherParser.LIMIT) | (1 << CypherParser.ASCENDING) | (1 << CypherParser.ASC) | (1 << CypherParser.DESCENDING) | (1 << CypherParser.DESC) | (1 << CypherParser.WHERE) | (1 << CypherParser.OR) | (1 << CypherParser.XOR) | (1 << CypherParser.AND) | (1 << CypherParser.NOT) | (1 << CypherParser.IN) | (1 << CypherParser.STARTS) | (1 << CypherParser.ENDS) | (1 << CypherParser.CONTAINS) | (1 << CypherParser.IS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (CypherParser.NULL - 64)) | (1 << (CypherParser.TRUE - 64)) | (1 << (CypherParser.FALSE - 64)) | (1 << (CypherParser.EXISTS - 64)) | (1 << (CypherParser.CASE - 64)) | (1 << (CypherParser.ELSE - 64)) | (1 << (CypherParser.END - 64)) | (1 << (CypherParser.WHEN - 64)) | (1 << (CypherParser.THEN - 64)) | (1 << (CypherParser.CONSTRAINT - 64)) | (1 << (CypherParser.DO - 64)) | (1 << (CypherParser.FOR - 64)) | (1 << (CypherParser.REQUIRE - 64)) | (1 << (CypherParser.UNIQUE - 64)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SymbolicNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UnescapedSymbolicName(self):
            return self.getToken(CypherParser.UnescapedSymbolicName, 0)

        def EscapedSymbolicName(self):
            return self.getToken(CypherParser.EscapedSymbolicName, 0)

        def HexLetter(self):
            return self.getToken(CypherParser.HexLetter, 0)

        def COUNT(self):
            return self.getToken(CypherParser.COUNT, 0)

        def FILTER(self):
            return self.getToken(CypherParser.FILTER, 0)

        def EXTRACT(self):
            return self.getToken(CypherParser.EXTRACT, 0)

        def ANY(self):
            return self.getToken(CypherParser.ANY, 0)

        def ALL(self):
            return self.getToken(CypherParser.ALL, 0)

        def NONE(self):
            return self.getToken(CypherParser.NONE, 0)

        def SINGLE(self):
            return self.getToken(CypherParser.SINGLE, 0)

        def getRuleIndex(self):
            return CypherParser.RULE_symbolicName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSymbolicName" ):
                listener.enterSymbolicName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSymbolicName" ):
                listener.exitSymbolicName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSymbolicName" ):
                return visitor.visitSymbolicName(self)
            else:
                return visitor.visitChildren(self)




    def symbolicName(self):

        localctx = CypherParser.SymbolicNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_symbolicName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1471
            _la = self._input.LA(1)
            if not(_la==CypherParser.ALL or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (CypherParser.COUNT - 65)) | (1 << (CypherParser.FILTER - 65)) | (1 << (CypherParser.EXTRACT - 65)) | (1 << (CypherParser.ANY - 65)) | (1 << (CypherParser.NONE - 65)) | (1 << (CypherParser.SINGLE - 65)) | (1 << (CypherParser.HexLetter - 65)) | (1 << (CypherParser.UnescapedSymbolicName - 65)) | (1 << (CypherParser.EscapedSymbolicName - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LeftArrowHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CypherParser.RULE_leftArrowHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLeftArrowHead" ):
                listener.enterLeftArrowHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLeftArrowHead" ):
                listener.exitLeftArrowHead(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLeftArrowHead" ):
                return visitor.visitLeftArrowHead(self)
            else:
                return visitor.visitChildren(self)




    def leftArrowHead(self):

        localctx = CypherParser.LeftArrowHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_leftArrowHead)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1473
            self.match(CypherParser.T__19)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RightArrowHeadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CypherParser.RULE_rightArrowHead

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRightArrowHead" ):
                listener.enterRightArrowHead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRightArrowHead" ):
                listener.exitRightArrowHead(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRightArrowHead" ):
                return visitor.visitRightArrowHead(self)
            else:
                return visitor.visitChildren(self)




    def rightArrowHead(self):

        localctx = CypherParser.RightArrowHeadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_rightArrowHead)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1475
            self.match(CypherParser.T__20)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DashContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return CypherParser.RULE_dash

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDash" ):
                listener.enterDash(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDash" ):
                listener.exitDash(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDash" ):
                return visitor.visitDash(self)
            else:
                return visitor.visitChildren(self)




    def dash(self):

        localctx = CypherParser.DashContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_dash)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1477
            self.match(CypherParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





